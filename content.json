{"meta":{"title":"Anoyer's Blog","subtitle":"","description":"一个ACMer的个人博客","author":"John Doe","url":"https://anoyer.cn"},"pages":[{"title":"","date":"2019-01-24T11:59:23.304Z","updated":"2018-11-29T04:34:06.081Z","comments":true,"path":"404.html","permalink":"https://anoyer.cn/404.html","excerpt":"","text":"404错误@import url('https://fonts.googleapis.com/css?family=Montserrat:400,600,700'); @import url('https://fonts.googleapis.com/css?family=Catamaran:400,800'); .error-container { text-align: center; font-size: 180px; font-family: 'Catamaran', sans-serif; font-weight: 800; margin: 20px 15px; } .error-container > span { display: inline-block; line-height: 0.7; position: relative; color: #FFB485; } .error-container > span { display: inline-block; position: relative; vertical-align: middle; } .error-container > span:nth-of-type(1) { color: #D1F2A5; animation: colordancing 4s infinite; } .error-container > span:nth-of-type(3) { color: #F56991; animation: colordancing2 4s infinite; } .error-container > span:nth-of-type(2) { width: 120px; height: 120px; border-radius: 999px; } .error-container > span:nth-of-type(2):before, .error-container > span:nth-of-type(2):after { border-radius: 0%; content:\"\"; position: absolute; top: 0; left: 0; width: inherit; height: inherit; border-radius: 999px; box-shadow: inset 30px 0 0 rgba(209, 242, 165, 0.4), inset 0 30px 0 rgba(239, 250, 180, 0.4), inset -30px 0 0 rgba(255, 196, 140, 0.4), inset 0 -30px 0 rgba(245, 105, 145, 0.4); animation: shadowsdancing 4s infinite; } .error-container > span:nth-of-type(2):before { -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); transform: rotate(45deg); } .screen-reader-text { position: absolute; top: -9999em; left: -9999em; } @keyframes shadowsdancing { 0% { box-shadow: inset 30px 0 0 rgba(209, 242, 165, 0.4), inset 0 30px 0 rgba(239, 250, 180, 0.4), inset -30px 0 0 rgba(255, 196, 140, 0.4), inset 0 -30px 0 rgba(245, 105, 145, 0.4); } 25% { box-shadow: inset 30px 0 0 rgba(245, 105, 145, 0.4), inset 0 30px 0 rgba(209, 242, 165, 0.4), inset -30px 0 0 rgba(239, 250, 180, 0.4), inset 0 -30px 0 rgba(255, 196, 140, 0.4); } 50% { box-shadow: inset 30px 0 0 rgba(255, 196, 140, 0.4), inset 0 30px 0 rgba(245, 105, 145, 0.4), inset -30px 0 0 rgba(209, 242, 165, 0.4), inset 0 -30px 0 rgba(239, 250, 180, 0.4); } 75% { box-shadow: inset 30px 0 0 rgba(239, 250, 180, 0.4), inset 0 30px 0 rgba(255, 196, 140, 0.4), inset -30px 0 0 rgba(245, 105, 145, 0.4), inset 0 -30px 0 rgba(209, 242, 165, 0.4); } 100% { box-shadow: inset 30px 0 0 rgba(209, 242, 165, 0.4), inset 0 30px 0 rgba(239, 250, 180, 0.4), inset -30px 0 0 rgba(255, 196, 140, 0.4), inset 0 -30px 0 rgba(245, 105, 145, 0.4); } } @keyframes colordancing { 0% { color: #D1F2A5; } 25% { color: #F56991; } 50% { color: #FFC48C; } 75% { color: #EFFAB4; } 100% { color: #D1F2A5; } } @keyframes colordancing2 { 0% { color: #FFC48C; } 25% { color: #EFFAB4; } 50% { color: #D1F2A5; } 75% { color: #F56991; } 100% { color: #FFC48C; } } /* demo stuff */ * { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } body { background-color: #666666; margin-bottom: 50px; } html, button, input, select, textarea { font-family: 'Montserrat', Helvetica, sans-serif; color: #92a4ad; } h1 { text-align: center; margin: 30px 15px; } .zoom-area { max-width: 490px; margin: 30px auto 30px; font-size: 19px; text-align: center; } .link-container { text-align: center; } a.more-link { text-transform: uppercase; font-size: 13px; background-color: #92a4ad; padding: 10px 15px; border-radius: 0; color: #416475; display: inline-block; margin-right: 5px; margin-bottom: 5px; line-height: 1.5; text-decoration: none; margin-top: 50px; letter-spacing: 1px; } .button { background-color: #4CAF50; /* Green */ border: none; color: white; padding: 16px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; margin: 4px 2px; -webkit-transition-duration: 0.4s; /* Safari */ transition-duration: 0.4s; cursor: pointer; border-radius: 50px; } .button1 { background-color: #666666; color: #00B09F; border: 2px solid #00B09F; } .button1:hover { background-color: #00B09F; color: white; }4 0 4木有找到你所请求的页面"},{"title":"","date":"2018-12-02T15:22:36.000Z","updated":"2018-12-03T14:24:55.671Z","comments":false,"path":"Library/index.html","permalink":"https://anoyer.cn/Library/index.html","excerpt":"","text":"此页会不定时的发布各种学习资料，内容涵盖ACM模板、C/C++学习资料、数据结构学习资料、各种IT类学习资料…等等等等，资源会以直链、软件官网、网盘等形式提供下载。温馨提示如果你发现有资源无法下载或者资源失效等情况可以联系我，我会马上进行处理。本站保证站内提供的所有可下载资源（软件等等）都是按”原样”提供，本站未做过任何改动；但不保证本站提供的下载资源的准确性、安全性和完整性；同时本站也不承担用户因使用这些下载的资源对自己和他人造成任何形式的损失或伤害。本站上的所有资源均来自互联网，仅供学习和研究使用，不得用于任何商业用途。如有侵犯你版权的，请联系我本人，本站将立即更改。ACM模板ACM算法模板ACM及算法学习书籍ACM模板-f_zyj[挑战程序设计竞赛(第2版)].巫泽俊ACM模板Deeplearning深度学习笔记v5.41kuangbin的ACM模板（新）027933-算法设计与分析基础 第二版[hejizhan.com]ACM模版-sxy算法导论_原书第3版_CHSACM模板-Anoyer刘汝佳《算法艺术与信息学竞赛》电子版oeis核心数列网算法竞赛入门经典 紫书dp进阶之路国际大学生程序设计竞赛指南IT类学习资料汇集C/C++学习资料数据结构学习资料狂人C程序员入门必备【大话数据结构】程杰C和指针（中文版）C陷阱与缺陷C专家编程C语言与C++语言程序设计其他学习资料英语Github入门教程四级单词一笑而过-俞敏洪亲笔力荐的词汇宝典从+0+开始学习+GitHub+系列视频学习资源C语言C++学习指南2017（零基础入门）Python全能自动化开发-基础入门汇编语言视频课程oeasy的ps教程，我们一起来玩ps(photoshop)"},{"title":"为什么在Coding上搭建的博客有时打不开呢？","date":"2018-12-08T07:50:18.000Z","updated":"2018-12-08T09:42:36.432Z","comments":true,"path":"article/201812081538.html","permalink":"https://anoyer.cn/article/201812081538.html","excerpt":"","text":"今天（2018年12月8日），大概过了中午之后Coding的pages服务又出现了瘫痪现象，ping了下域名，整个地图全爆红。与上次Coding瘫痪（2018年11月18日下午）的情况基本一致。上一次Coding瘫痪的第二天中午我就联系了Coding的客服，以下是我和客服的聊天记录请大家过目，别的我也就不多说的，因为我早不信任它了。"},{"title":"","date":"2018-09-16T14:15:00.000Z","updated":"2018-12-01T16:39:40.756Z","comments":false,"path":"check-link/index.html","permalink":"https://anoyer.cn/check-link/index.html","excerpt":"","text":"友链检查记录以下是各个友链的撤链信息，若需恢复友链请联系我本人名称网址撤链原因撤链时间能否恢复阳一的博客http://www.heyangli.com链接错误2018.11.26能帖子http://www.tiezi.xyz链接错误2018.11.26能JasonYu的博客https://www.yuhuizhen.com/未加链接2018.11.26能JunMohttps://mo3.top/未加友链2018.11.26能最初的墨https://www.taitan.tech/域名错误2018.11.20能"},{"title":"","date":"2018-09-15T03:49:07.000Z","updated":"2018-12-03T04:09:47.428Z","comments":false,"path":"about/index.html","permalink":"https://anoyer.cn/about/index.html","excerpt":"","text":"本人介绍一名大闲人在役ACMer铁牌选手有点强迫症喜欢HIFI喜欢旅游收藏名言“今日的我要超越昨日的我，明日的我要胜过今日的我”“人一我百！人十我万！永不放弃~~~怀着自信的心，去追逐梦想”“咕咕咕”“人类的本质是复读机”“过不了就是OJ有问题”联系方式Github：@AnoyerWeiBo：@Anoy_虚伪QQ：@在头像下方在线联系E-Mail：zhihuangliu@foxmail.com本站备用站点CSDN: https://me.csdn.net/Anoy_acer"},{"title":"categories","date":"2018-09-15T02:29:41.000Z","updated":"2018-09-15T02:30:42.835Z","comments":true,"path":"categories/index.html","permalink":"https://anoyer.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-24T11:59:23.967Z","updated":"2018-11-23T01:04:46.056Z","comments":true,"path":"js/cover.js","permalink":"https://anoyer.cn/js/cover.js","excerpt":"","text":"var brightness; //��ʾ���� function cover(brightness) { if (typeof(div) == 'undefined') { div = document.createElement('div'); div.setAttribute('style', 'position:fixed;top:0;left:0;outline:5000px solid;z-index:99999;'); document.body.appendChild(div); } else { div.style.display = ''; } div.style.outlineColor = 'rgba(0,0,0,' + brightness + ')'; } //�¼����� window.addEventListener('keydown', function(e) { if (e.altKey && e.keyCode == 90) { //Alt+Z:��ҹ��ģʽ cover(brightness = 0.3); } if (e.altKey && e.keyCode == 88) { //Alt+X:�ر� cover(brightness = 0); } if (e.altKey && e.keyCode == 38) { //Alt+��:�������� if (brightness - 0.05 > 0.05) cover(brightness -= 0.05); } if (e.altKey && e.keyCode == 40) { //Alt+��:�������� if (brightness + 0.05 < 0.95) cover(brightness += 0.05); } }, false);"},{"title":"","date":"2019-01-24T11:59:23.966Z","updated":"2018-11-21T11:27:50.515Z","comments":true,"path":"js/back.top.js","permalink":"https://anoyer.cn/js/back.top.js","excerpt":"","text":"$(document).ready(function($){ // browser window scroll (in pixels) after which the \"back to top\" link is shown var offset = 300, //duration of the top scrolling animation (in ms) scroll_top_duration = 200, //grab the \"back to top\" link $back_to_top = $('.cd-top'); //hide or show the \"back to top\" link $(window).scroll(function(){ ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out'); }); //smooth scroll to top $back_to_top.on('click', function(event){ event.preventDefault(); $('body,html').animate({ scrollTop: 0 , }, scroll_top_duration ); }); });"},{"title":"","date":"2018-09-16T14:15:00.000Z","updated":"2018-12-02T09:04:11.086Z","comments":false,"path":"link-sq/index.html","permalink":"https://anoyer.cn/link-sq/index.html","excerpt":"","text":"申请友情链接申请条件必须是非营利性且可以稳定运营的网站。网站内90%的内容属于原创，只接受博客网站，技术类博客优先。不接受包含色情、毒品、恐怖、赌博等含有违法内容以及包含大量广告的网站。不接受通过第三方网站代建平台（如“凡科建站”、“搜狐快站”等）搭建的博客网站。网站内容需要经常更新。申请须知友情链接只是结交朋友，而不是为了SEO。单方若需要撤销友链务必先通知另一方。除特殊友链外，友情链接都按正常顺序排列，不分排名前后。本博客将不定时对无法访问或含有违规内容以及私自撤链的网址，进行清理。在申请前请先将本博客添加至你博客的友情链接栏目中，在24小时内不要删除（我会在24小时内查收邮件）。本博客会精选出优质博客将其链接会另外在网站页脚显示，链接也会定期检查和重选。若发现我方先行撤链，请进入检查记录页面查看撤链的原因。后需恢复友链请联系我本人。阅读友情链接的申请条件和须知后可点击下方的申请按钮，浏览器会自动启动你客户端的邮件程序并自动载入申请模板，你只需在模板中填写博客地址和名称即可，若浏览器未成功启动邮件程序，请确认客户端是否已安装了邮件程序并绑定了自己的邮箱账号。当然，你也可以直接通过博主的联系方式来联系我交换友链，但必须需要说明你的博客名称和博客地址。申 请 友 情 链 接"},{"title":"","date":"2019-01-24T11:59:23.970Z","updated":"2018-11-26T02:26:20.273Z","comments":true,"path":"js/get.time.js","permalink":"https://anoyer.cn/js/get.time.js","excerpt":"","text":"function clock_12h() { var today = new Date(); //获得当前时间 //获得年、月、日，Date()函数中的月份是从0－11计算 var year = today.getFullYear(); var month = today.getMonth()+1; var date = today.getDate(); var hour = today.getHours(); //获得小时、分钟、秒 var minute = today.getMinutes(); var second = today.getSeconds(); var apm=\"AM\"; //默认显示上午: AM if (hour>12) //按12小时制显示 { hour=hour-12; apm=\"PM\" ; } var weekday = 0; switch(today.getDay()){ case 0: weekday = \"星期日\"; break; case 1: weekday = \"星期一\"; break; case 2: weekday = \"星期二\"; break; case 3: weekday = \"星期三\"; break; case 4: weekday = \"星期四\"; break; case 5: weekday = \"星期五\"; break; case 6: weekday = \"星期六\"; break; } /*设置div的内容为当前时间*/ document.getElementById(\"myclock\").innerHTML=\"\"+year+\"年\"+month+\"月\"+date+\"日\"+weekday; } /*使用setInterval()每间隔指定毫秒后调用clock_12h()*/ var myTime = setInterval(\"clock_12h()\",1000);"},{"title":"","date":"2019-01-24T11:59:23.992Z","updated":"2018-12-02T08:43:55.253Z","comments":false,"path":"statement/index.html","permalink":"https://anoyer.cn/statement/index.html","excerpt":"","text":"网站声明本博客属个人所有，不涉及商业目的，非经允许，不得用于盈利目的。原创声明本站大部分内容属于原创，凡是本站发表的内容，请大家在转载的时候声明原文出处。博客中的所有文章或者本站的其他页面中使用的大部分图片或图标来自于网络，如果侵权与zhihuangliu@foxmail.com联系删除！转载声明转载本站文章可酌情修改内容，但需保证文章的语义完整性，以免让读者错误理会作者的真实意图。修改内容需通知源作者。任何转载自其他站点的文章，本站都会在文章结尾处声明原文链接，如果您的文章不希望被我转载，请及时联系我进行删除处理。评论审核制度任何评论无需审核即可通过评论，如发现有恶意评论以及垃圾评论我会及时处理掉。本人不会以任何理由在任何页面留下恶意评论、诽谤、谩骂，也不会留下任何对您有不良影响的评论，如果您发现有人盗用我的名义用来进行恶意评论，希望您能及时联系我，谢谢！"},{"title":"","date":"2019-01-24T11:59:23.982Z","updated":"2019-01-22T14:36:26.547Z","comments":false,"path":"links/index.html","permalink":"https://anoyer.cn/links/index.html","excerpt":"","text":"友 链海内存知己，天涯若比邻——以下为各位小白大佬的友链，优秀的博客友链还会放在博客的页脚哟~如果需要申请友链可以点击最下方的申请按钮！头像名称网站Anoyerhttps://blog.csdn.net/Anoy_acerf_zyjhttps://me.csdn.net/f_zyjCaprYanghttps://blog.csdn.net/CaprYangAererhttps://me.csdn.net/qq_41785863Leon_ldyhttps://blog.csdn.net/iamldyxumengnanhttps://blog.csdn.net/qq_40727946wzazzyhttps://blog.csdn.net/wzazzySXYhttps://orzsxy.github.ioCupccinohttps://me.csdn.net/qq_39898553小吴博客https://www.wushile.tophandsomehttps://www.ihewro.comChungZHhttps://chungzh.cnMitscherlichhttps://mitscherlich.me/申请友情链接"},{"title":"tags","date":"2018-09-15T02:31:15.000Z","updated":"2018-09-15T02:31:46.964Z","comments":true,"path":"tags/index.html","permalink":"https://anoyer.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-09-15T03:50:12.000Z","updated":"2018-12-03T14:25:00.153Z","comments":false,"path":"resources/index.html","permalink":"https://anoyer.cn/resources/index.html","excerpt":"这是藏有博主不可告人密码的小仓库哦。","text":"这是藏有博主不可告人密码的小仓库哦。 Incorrect Password! No content to display! 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"}],"posts":[{"title":"UVA - 11624 - Fire!(BFS逃生问题)","slug":"UVA-11624-Fire","date":"2019-02-25T09:40:34.000Z","updated":"2019-02-25T09:50:13.223Z","comments":true,"path":"article/UVA-11624-Fire.html","link":"","permalink":"https://anoyer.cn/article/UVA-11624-Fire.html","excerpt":"","text":"题目链接题意：在迷宫内，J表示人，F表示火，火可能不止一处，但是人只有一个，火会向上下左右蔓延，蔓延速度和人移动速度一至（每次一格，但是可以同时向四个方向）问是否可以成功逃出迷宫，不能输出IMPOSSIBLE，能的画话输出最短路径。题解：每步先让火走–然后人走其他的路–就可以保证人不会被火烧了先将火入队列最后将人入队列，走的时候判断下是人还是火，如果是人的话看看是否无路可走注：也可以跑两次BFS，先跑火，再跑人，看人到当前格时间是否小于火的AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char ma[1010][1010];int n,m,rx,ry,fx,fy;int xx[4]=&#123;0,0,1,-1&#125;;int yy[4]=&#123;1,-1,0,0&#125;;struct node&#123; int x,y,step; bool fafe;&#125;now,qian,ff;int bfs()&#123; queue &lt;node&gt; que; for (int i=0;i&lt;n;i++) for (int j=0;j&lt;m;j++)&#123; if (ma[i][j]=='F')&#123; now.x=i;now.y=j;now.step=0; now.fafe=true; que.push(now); ma[i][j]='#'; &#125; &#125; now.x=rx;now.y=ry;now.step=0;now.fafe=false; que.push(now); while (!que.empty())&#123; now=que.front(); que.pop(); if (now.fafe)&#123; for (int i=0;i&lt;4;i++)&#123; int kx=now.x+xx[i]; int ky=now.y+yy[i]; if (kx&lt;0||ky&lt;0||kx==n||ky==m||ma[kx][ky]=='#') continue; &#123; ma[kx][ky]='#'; qian.x=kx;qian.y=ky; qian.step=now.step+1; qian.fafe=true; que.push(qian); &#125; &#125; &#125; else&#123; for (int i=0;i&lt;4;i++)&#123; int kx=now.x+xx[i]; int ky=now.y+yy[i]; if (kx&lt;0||ky&lt;0||kx==n||ky==m)&#123; return now.step+1; &#125; if (ma[kx][ky]!='#')&#123; ma[kx][ky]='#'; qian.x=kx;qian.y=ky; qian.step=now.step+1; qian.fafe=false; que.push(qian); &#125; &#125; &#125; &#125; return 0;&#125;int main()&#123; int t;scanf(\"%d\",&amp;t); while (t--)&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=0;i&lt;n;i++)&#123; scanf(\"%s\",ma[i]); for (int j=0;j&lt;m;j++)&#123; if (ma[i][j]=='J')&#123; rx=i;ry=j; ma[i][j]='#'; &#125; &#125; &#125; int ans=bfs(); if (ans) printf(\"%d\\n\",ans); else printf(\"IMPOSSIBLE\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"},{"name":"UVA","slug":"UVA","permalink":"https://anoyer.cn/tags/UVA/"}]},{"title":"POJ - 3984 - 迷宫问题(路径记录)","slug":"POJ-3984","date":"2019-02-25T09:36:16.000Z","updated":"2019-02-25T09:49:54.260Z","comments":true,"path":"article/POJ-3984.html","link":"","permalink":"https://anoyer.cn/article/POJ-3984.html","excerpt":"","text":"题目链接题意：给你一个5*5的迷宫，0代表通路，1代表墙，找到从迷宫左上角到达右下角的最短路径，并输出路径。题解：先进行一遍BFS，得到vis数组，表示到该位置最少需要多少时间，然后从(4,4)位置倒着查路径，查到符合的就直接break，防止重复AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;const int maxn=7;struct node&#123; int x,y; node(int i=0,int j=0)&#123;x=i,y=j;&#125;;&#125;;int mp[maxn][maxn];int vis[maxn][maxn];int dis[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;void bfs()&#123; queue&lt;node&gt;dq; node now(0,0),nex; dq.push(now); vis[0][0]=1; while(!dq.empty())&#123; now=dq.front(); dq.pop(); for(int i=0;i&lt;4;i++)&#123; nex.x=now.x+dis[i][0]; nex.y=now.y+dis[i][1]; if(nex.x&gt;=0&amp;&amp;nex.x&lt;5&amp;&amp;nex.y&gt;=0&amp;&amp;nex.y&lt;5&amp;&amp;mp[nex.x][nex.y]==0&amp;&amp;vis[nex.x][nex.y]==0)&#123; dq.push(nex); vis[nex.x][nex.y]=vis[now.x][now.y]+1; if(nex.x==4&amp;&amp;nex.y==4)return; &#125; &#125; &#125;&#125;int main()&#123; stack&lt;node&gt;ds; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;5;j++)scanf(\"%d\",&amp;mp[i][j]); bfs(); node nw(4,4),ne; int ans=vis[4][4]; ds.push(nw); while(true)&#123; for(int i=0;i&lt;5;i++)&#123; ne.x=nw.x+dis[i][0]; ne.y=nw.y+dis[i][1]; if(ne.x&gt;=0&amp;&amp;ne.x&lt;5&amp;&amp;ne.y&gt;=0&amp;&amp;ne.y&lt;5&amp;&amp;vis[ne.x][ne.y]==ans-1)&#123; nw=ne; ans=ans-1; ds.push(nw); break; &#125; &#125; if(nw.x==0&amp;&amp;nw.y==0)break; &#125; while(!ds.empty())&#123; nw=ds.top(); ds.pop(); printf(\"(%d, %d)\\n\",nw.x,nw.y); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"POJ - 3278 - Catch That Cow(裸BFS)","slug":"POJ-3278-Catch-That-Cow","date":"2019-02-25T09:29:05.000Z","updated":"2019-02-25T09:35:30.552Z","comments":true,"path":"article/POJ-3278-Catch-That-Cow.html","link":"","permalink":"https://anoyer.cn/article/POJ-3278-Catch-That-Cow.html","excerpt":"","text":"题目链接题意：给定两个整数n和k，通过 n+1或n-1 或n*2 这3种操作，使得n==k，输出最少的操作次数题解：简单的对每个节点进行三个方向（三种走法）的BFSAC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005;int vis[maxn];int n,k;int bfs()&#123; queue&lt;int&gt;dq; dq.push(n); vis[n]=1; while(!dq.empty())&#123; int x=dq.front(); dq.pop(); if(x+1&gt;=0&amp;&amp;x+1&lt;maxn&amp;&amp;vis[x+1]==0)&#123; dq.push(x+1); vis[x+1]=vis[x]+1; if(x+1==k)return vis[x+1]; &#125; if(x-1&gt;=0&amp;&amp;x-1&lt;maxn&amp;&amp;vis[x-1]==0)&#123; dq.push(x-1); vis[x-1]=vis[x]+1; if(x-1==k)return vis[x-1]; &#125; if(2*x&gt;=0&amp;&amp;2*x&lt;maxn&amp;&amp;vis[2*x]==0)&#123; dq.push(2*x); vis[2*x]=vis[x]+1; if(2*x==k)return vis[2*x]; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); if(n&gt;=k)&#123; printf(\"%d\\n\",n-k); return 0; &#125; int ans=bfs(); printf(\"%d\\n\",ans-1);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"POJ - 3126 - Prime Path(BFS枚举)","slug":"POJ-3126-Prime-Path","date":"2019-02-25T09:24:31.000Z","updated":"2019-02-25T09:28:46.369Z","comments":true,"path":"article/POJ-3126-Prime-Path.html","link":"","permalink":"https://anoyer.cn/article/POJ-3126-Prime-Path.html","excerpt":"","text":"题目链接题意：给出两个四位数的素数a,b，求从a变到b最少要花几步？每一步只能将a中的一位改变，且改变后的数也要是素数。题解：BFS枚举个位，十位，百位，千位变换的数，用素数表判断变换后是否为一个素数AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=1e4+5;bool prime[maxn];int vis[maxn];void Prime()&#123; prime[0]=prime[1]=1; for(int i=2;i&lt;maxn;i++)&#123; if(!prime[i]) for(int j=2;j*i&lt;maxn;j++)prime[i*j]=1; &#125;&#125;int n,m;int bfs()&#123; int ans=0; queue&lt;int&gt;dq; dq.push(n); vis[n]=1; if(n==m)return vis[n]; while(!dq.empty())&#123; int x=dq.front(); dq.pop(); if(x==m)return vis[x]; for(int i=1;i&lt;10;i+=2)&#123; //个位 int xx=x-x%10+i; if(!prime[xx]&amp;&amp;vis[xx]==0)&#123; dq.push(xx); vis[xx]=vis[x]+1; if(xx==m)return vis[xx]; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; //十位 int xx=x-(x%100-x%10)+i*10; if(!prime[xx]&amp;&amp;vis[xx]==0)&#123; dq.push(xx); vis[xx]=vis[x]+1; if(xx==m)return vis[xx]; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; //百位 int xx=x-(x%1000-x%100)+i*100; if(!prime[xx]&amp;&amp;vis[xx]==0)&#123; dq.push(xx); vis[xx]=vis[x]+1; if(xx==m)return vis[xx]; &#125; &#125; for(int i=1;i&lt;10;i++)&#123; //千位 int xx=x-(x%10000-x%1000)+i*1000; if(!prime[xx]&amp;&amp;vis[xx]==0)&#123; dq.push(xx); vis[xx]=vis[x]+1; if(xx==m)return vis[xx]; &#125; &#125; &#125; return -1;&#125;int main()&#123; Prime(); int t; scanf(\"%d\",&amp;t); while(t--)&#123; memset(vis,0,sizeof(vis)); scanf(\"%d%d\",&amp;n,&amp;m); int ans=bfs(); if(ans==-1)printf(\"Impossible\\n\"); else printf(\"%d\\n\",ans-1); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"POJ - 3087 - Shuffle'm Up(模拟)","slug":"POJ-3087-Shuffle-m-Up","date":"2019-02-25T09:18:44.000Z","updated":"2019-02-25T09:49:13.488Z","comments":true,"path":"article/POJ-3087-Shuffle-m-Up.html","link":"","permalink":"https://anoyer.cn/article/POJ-3087-Shuffle-m-Up.html","excerpt":"","text":"题目链接题意：已知两堆牌s1和s2的初始状态， 其牌数均为c，按给定规则能将他们相互交叉组合成一堆牌s12，再将s12的最底下的c块牌归为s1，最顶的c块牌归为s2，依此循环下去。现在输入s1和s2的初始状态 以及 预想的最终状态s12问s1 s2经过多少次洗牌之后，最终能达到状态s12，若永远不可能相同，则输出”-1”。题解：虽然归类于kuangbin搜索专题，但个人感觉模拟更好做，直接用map判重，进行模拟就可以。如果出现了一个出现过的非目标串，则输出-1，因为此时操作是一个环无法到达目标串AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;const int maxn=120;string s1,s2,s,s12;int main()&#123; int t,n,tt=1; cin&gt;&gt;t; while(tt&lt;=t)&#123; cin&gt;&gt;n; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s; map&lt;string,bool&gt;vis; vis[s]=1; int cnt=0; while(1)&#123; s12=\"\"; for(int i=0;i&lt;n;i++)&#123; s12+=s2[i]; s12+=s1[i]; &#125; s12+=\"\\0\"; cnt++; if(s12==s)&#123; cout&lt;&lt;tt&lt;&lt;\" \"&lt;&lt;cnt&lt;&lt;endl; break; &#125; if(vis[s12])&#123; cout&lt;&lt;tt&lt;&lt;\" \"&lt;&lt;-1&lt;&lt;endl; break; &#125; vis[s12]=1; s1=\"\"; s2=\"\"; for(int i=0;i&lt;n;i++)&#123; s1+=s12[i]; s2+=s12[i+n]; &#125; s1+=\"\\0\"; s2+=\"\\0\"; &#125; tt++; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"},{"name":"模拟题","slug":"模拟题","permalink":"https://anoyer.cn/tags/模拟题/"}]},{"title":"POJ - 2251 - Dungeon Master(分层BFS)","slug":"POJ-2251-Dungeon-Master","date":"2019-02-25T09:14:37.000Z","updated":"2019-02-25T09:18:18.668Z","comments":true,"path":"article/POJ-2251-Dungeon-Master.html","link":"","permalink":"https://anoyer.cn/article/POJ-2251-Dungeon-Master.html","excerpt":"","text":"题目链接题意：给一个三维图，可以前后左右上下6种走法，走一步1分钟，求最少时间（其实就是最短路）题解：最短路Bfs，和二维的基本一样，就是原来4个方向，现在6个方向，原来数组是二维，现在是三维，也相当于模板题了。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=50;struct node&#123; int x,y,z; node(int xx=0,int yy=0,int zz=0)&#123;x=xx,y=yy,z=zz;&#125;;&#125;;char mp[maxn][maxn][maxn];int vis[maxn][maxn][maxn];int mov[6][3]=&#123;&#123;1,0,0&#125;,&#123;-1,0,0&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,0,-1&#125;&#125;;int l,n,m;int sx,sy,sz,ex,ey,ez;bool check(node a)&#123; if(a.z&lt;l&amp;&amp;a.z&gt;=0&amp;&amp;a.x&lt;n&amp;&amp;a.x&gt;=0&amp;&amp;a.y&lt;m&amp;&amp;a.y&gt;=0)return true; else return false;&#125;int bfs()&#123; queue&lt;node&gt; dq; node now(sx,sy,sz),next; dq.push(now); vis[sz][sx][sy]=1; while(!dq.empty())&#123; now=dq.front(); dq.pop(); for(int i=0;i&lt;6;i++)&#123; next.z=now.z+mov[i][0]; next.x=now.x+mov[i][1]; next.y=now.y+mov[i][2]; if(check(next)&amp;&amp;vis[next.z][next.x][next.y]==0&amp;&amp;mp[next.z][next.x][next.y]!='#')&#123; dq.push(next); vis[next.z][next.x][next.y]=vis[now.z][now.x][now.y]+1; if(mp[next.z][next.x][next.y]=='E')return vis[next.z][next.x][next.y]; &#125; &#125; &#125; return -1;&#125;int main()&#123; while(scanf(\"%d%d%d\",&amp;l,&amp;n,&amp;m))&#123; if(!n&amp;&amp;!m&amp;&amp;!l)break; getchar(); memset(mp,0,sizeof(mp)); memset(vis,0,sizeof(vis)); for(int i=0;i&lt;l;i++)&#123; for(int j=0;j&lt;n;j++)&#123; for(int k=0;k&lt;m;k++)&#123; scanf(\"%c\",&amp;mp[i][j][k]); if(mp[i][j][k]=='S')sx=j,sy=k,sz=i; if(mp[i][j][k]=='E')ex=j,ey=k,ez=i; &#125; getchar(); &#125; getchar(); //吃换行 &#125; int ans=bfs(); if(ans==-1)printf(\"Trapped!\\n\"); else printf(\"Escaped in %d minute(s).\\n\",ans-1); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"POJ - 1426 - Find The Multiple(双入口DFS)","slug":"POJ-1426-Find-The-Multiple","date":"2019-02-25T09:09:40.000Z","updated":"2019-02-25T09:14:03.440Z","comments":true,"path":"article/POJ-1426-Find-The-Multiple.html","link":"","permalink":"https://anoyer.cn/article/POJ-1426-Find-The-Multiple.html","excerpt":"","text":"题目链接题意：给一个数n，让你找出一个只有1，0，组成的十进制数，要求是找到的数可以被n整除题解：用DFS是搜索 当前位数字 （除最高位固定为1），因为每一位都只有0或1两种选择AC代码：123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ll;const int maxn=230;int n;bool found;void dfs(ll ans,int k)&#123; if(found)return; if(ans%n==0)&#123; printf(\"%llu\\n\",ans); found=1; return; &#125; if(k==19)return; dfs(ans*10,k+1); dfs(ans*10+1,k+1);&#125;int main()&#123; while(scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; found=0; dfs(1,0); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"POJ - 1321 - 棋盘问题(裸DFS)","slug":"POJ-1321","date":"2019-02-25T09:05:17.000Z","updated":"2019-02-25T09:09:16.835Z","comments":true,"path":"article/POJ-1321.html","link":"","permalink":"https://anoyer.cn/article/POJ-1321.html","excerpt":"","text":"题目链接题意：给你一个棋盘，问在这个棋盘上放K个棋子，有多少种放法（每行每列只能有一个棋子）题解：对棋盘DFS搜索，每满足一种就ans++，基本是裸的AC代码：123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef long long ll;const int maxn=17;char mp[maxn][maxn];bool vis[maxn];ll ans=0;int k,n;void dfs(int x,int y)&#123; if(y&gt;=k)&#123; ans++; return ; &#125; for(int i=x;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(vis[j]==0&amp;&amp;mp[i][j]=='#')&#123; vis[j]=1; dfs(i+1,y+1); vis[j]=0; &#125; &#125; &#125; return;&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;k))&#123; if(n==-1&amp;&amp;k==-1)break; memset(mp,0,sizeof(mp)); memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++)scanf(\"%s\",mp[i]); ans=0; dfs(0,0); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://anoyer.cn/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"HDU - 2612 - Find a way(BFS+打表)","slug":"HDU-2612-Find-a-way","date":"2019-02-25T09:00:10.000Z","updated":"2019-02-25T09:04:58.080Z","comments":true,"path":"article/HDU-2612-Find-a-way.html","link":"","permalink":"https://anoyer.cn/article/HDU-2612-Find-a-way.html","excerpt":"","text":"题目链接题意：求2个点到KFC的距离之和，使其最小题解：可用2次BFS，分别求出2个点到各个KFC的最短距离，然后找出和最小的即可AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#define inf 0xffffffusing namespace std;const int N=210;int m,n,mark[N][N],dis[N][N][2],dir[4][2]=&#123;1,0, 0,1, -1,0, 0,-1&#125;,flag;char s[N][N];struct node&#123; int x,y,step;&#125;;bool judge(int x,int y)&#123; if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; s[x][y]!=&apos;#&apos; &amp;&amp; mark[x][y]==0) return 1; return 0;&#125;void bfs(int x,int y)&#123; int k; queue&lt;node&gt;q; node cur,next; cur.x=x;cur.y=y;cur.step=0; mark[x][y]=1; q.push(cur); while(!q.empty())&#123; cur=q.front(); q.pop(); next.step=cur.step+1; for(k=0;k&lt;4;k++)&#123; next.x=x=cur.x+dir[k][0]; next.y=y=cur.y+dir[k][1]; if(judge(x,y))&#123; mark[x][y]=1; if(s[x][y]==&apos;@&apos;)dis[x][y][flag]=next.step; q.push(next); &#125; &#125; &#125;&#125;int main()&#123; int i,j,min; while(scanf(&quot;%d %d&quot;,&amp;m,&amp;n)!=-1)&#123; min=inf; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) dis[i][j][0]=dis[i][j][1]=inf; for(i=0;i&lt;m;i++)scanf(&quot;%s&quot;,s[i]); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++)&#123; if(s[i][j]==&apos;Y&apos;)&#123; flag=0; memset(mark,0,sizeof(mark)); bfs(i,j); &#125; else if(s[i][j]==&apos;M&apos;)&#123; flag=1; memset(mark,0,sizeof(mark)); bfs(i,j); &#125; &#125; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) if(s[i][j]==&apos;@&apos; &amp;&amp; min&gt;dis[i][j][0]+dis[i][j][1]) min=dis[i][j][0]+dis[i][j][1]; printf(&quot;%d\\n&quot;,min*11); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"}]},{"title":"HDU - 1241 - Oil Deposits(DFS联通块)","slug":"HDU-1241-Oil-Deposits","date":"2019-02-25T08:53:51.000Z","updated":"2019-02-25T08:59:30.539Z","comments":true,"path":"article/HDU-1241-Oil-Deposits.html","link":"","permalink":"https://anoyer.cn/article/HDU-1241-Oil-Deposits.html","excerpt":"","text":"题目链接题意：就是给你一个地图，找出所有不相连（八个方向）的@组合有多少个题解：经典的DFS求联通块的题，和紫书上求油田一样，枚举每一个点进行DFS搜联通的@AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;char mat[maxn][maxn];int dir[8][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,1&#125;,&#123;1,-1&#125;,&#123;-1,-1&#125;&#125;;int m,n;int sum;void Dfs(int x,int y)&#123; int tx; int ty; for(int i=0;i&lt;8;i++)&#123; tx=x+dir[i][0]; ty=y+dir[i][1]; if(1&lt;=tx&amp;&amp;tx&lt;=m&amp;&amp;1&lt;=ty&amp;&amp;ty&lt;=n)&#123;//注意！对于二维数组来说，x行y列，意味着x是纵向坐标，y是横向坐标 if(mat[tx][ty]=='@')&#123; mat[tx][ty]='*'; Dfs(tx,ty); &#125; &#125; &#125;&#125;int main()&#123; while(scanf(\"%d%d\",&amp;m,&amp;n))&#123; if(m==0&amp;&amp;n==0)&#123; break; &#125; //memset(mat,0,sizeof(mat)); sum=0; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; //scanf(\"%s\",mat[i]+1); cin&gt;&gt;mat[i][j]; //scanf(\"%c\",&amp;mat[i][j]); &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(mat[i][j]=='@')&#123; sum++; mat[i][j]='*'; Dfs(i,j); //深搜，消除同一连通块的所有油田标记 &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"DFS","slug":"DFS","permalink":"https://anoyer.cn/tags/DFS/"}]},{"title":"FZU - 2150 - Fire Game(双端BFS)","slug":"FZU-2150-Fire-Game","date":"2019-02-25T08:45:53.000Z","updated":"2019-02-25T09:49:22.535Z","comments":true,"path":"article/FZU-2150-Fire-Game.html","link":"","permalink":"https://anoyer.cn/article/FZU-2150-Fire-Game.html","excerpt":"","text":"题目链接题意：给你块地，有空地，也有草堆，让你选两个草堆进行点火，燃烧的草堆会引燃上下左右的相邻草堆，每一次引燃花费1s时间，问你最少花多长时间把草堆都点着，如果做不到输出-1.题解：枚举图中所有草地，找到任意两块不一样的草地，然后bfs求出烧掉所有草的最短时间，可以将两个初始状态都push进队列，这样就可以模拟两堆草同时燃烧的情况，在bfs的过程中要判断是否烧完（即所有的草堆的点都要被访问过），如果烧完，就立即返回这点的距离，就是以该状态枚举时，的最远距离，让后输出最远距离中最小的就是最终结果。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;const int maxn = 20;struct node&#123; int x, y; node(int i = 0, int j = 0)&#123; x = i, y = j; &#125;;&#125;;char mp[maxn][maxn];int vis[maxn][maxn];int n, m;int _size;int dis[4][2] = &#123; 1, 0, -1, 0, 0, 1, 0, -1 &#125;;vector&lt;node&gt;cp;int bfs(node a, node b)&#123; memset(vis, 0, sizeof(vis)); queue&lt;node&gt;dq; dq.push(a); dq.push(b); vis[a.x][a.y] = vis[b.x][b.y] = 1; int ans = 1; //能达到的最大时间 node na, nb; while (!dq.empty())&#123; a = dq.front(), dq.pop(); for (int i = 0; i&lt;4; i++)&#123; na.x = a.x + dis[i][0]; na.y = a.y + dis[i][1]; if (na.x &gt;= 0 &amp;&amp; na.x&lt;n&amp;&amp;na.y &gt;= 0 &amp;&amp; na.y&lt;m&amp;&amp;mp[na.x][na.y] == '#'&amp;&amp;vis[na.x][na.y] == 0) dq.push(na), vis[na.x][na.y] = vis[a.x][a.y] + 1, ans = max(ans, vis[na.x][na.y]); &#125; &#125; for (int i = 0; i&lt;_size; i++)&#123; //遍历所有草堆看看是否全部都已经被火覆盖 if (vis[cp[i].x][cp[i].y] == 0)return -1; &#125; return ans;&#125;int main()&#123; int t, tt = 1; scanf(\"%d\", &amp;t); node xx; while (tt &lt;= t)&#123; cp.clear(); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i&lt;n; i++)&#123; getchar(); for (int j = 0; j&lt;m; j++)&#123; scanf(\"%c\", &amp;mp[i][j]); xx.x=i,xx.y=j; if (mp[i][j] == '#')cp.push_back(xx); //存入#节点坐标，便于枚举火堆 &#125; &#125; int ans = 99999999; _size = cp.size(); if(_size==1)ans=1; //for(int i=0;i&lt;_size;i++)cout&lt;&lt;cp[i].x&lt;&lt;\" \"&lt;&lt;cp[i].y&lt;&lt;endl; for (int i = 0; i&lt;_size; i++)&#123; for (int j = i + 1; j&lt;_size; j++)&#123; int tmp = bfs(cp[i], cp[j]); //枚举火堆跑bfs if(tmp==-1)continue; ans=min(tmp,ans); &#125; &#125; if(ans==99999999)printf(\"Case %d: -1\\n\", tt++); else printf(\"Case %d: %d\\n\", tt++, ans-1); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://anoyer.cn/tags/BFS/"},{"name":"FZU","slug":"FZU","permalink":"https://anoyer.cn/tags/FZU/"}]},{"title":"2019 Wannafly Camp day8","slug":"2019-Wannafly-Camp-day8","date":"2019-01-27T11:04:56.000Z","updated":"2019-01-27T14:16:05.389Z","comments":true,"path":"article/2019-Wannafly-Camp-day8.html","link":"","permalink":"https://anoyer.cn/article/2019-Wannafly-Camp-day8.html","excerpt":"","text":"自闭感受Camp最后一天了，上午 hls 给我们讲了计数和概率，太无奈自己太菜只听懂了一点点，有点可惜了。ε=(´ο｀*)))唉。下午训练果然和我预想的一样，最后一场应该是自闭场 （虽然天天自闭），一套题目下来，J题T了，A题队友被自己hack了，G题死怼一下午，从开始毫无思绪，到后面展开各种毛病。心态简直爆炸了不知不觉就过去了8天，突然对这段时光有点不舍，虽然自闭但却快乐着。晚上和队友回去，看着路上6人的影子 （包括另外一队），突然感觉ACM是多么一件快乐并有意义的事情！还有9个月时间，加油Anoyer！上题解G - 穗乃果的考试先对方块求一个二维前缀和，这样就相当于枚举前缀和中每一个小块的和了。123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=998244353;char s[2200][2200];ll a[2200][2200],sum[2200][2200];int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)scanf(\"%s\",s[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)a[i][j]=s[i-1][j-1]-'0'; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]; ll ans=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)ans=(ans+sum[i][j]*(i*j))%mod; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=m;j++)ans=(ans+sum[i][j]*(n-i)*(m-j))%mod; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++)ans=(ans-sum[i][j]*i*(m-j))%mod; for(int i=0;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)ans=(ans-sum[i][j]*((n-i)*j))%mod; while(ans&lt;0)ans+=mod; printf(\"%lld\\n\",ans%mod); return 0;&#125;","categories":[{"name":"2019 Wannafly Winter Camp","slug":"2019-Wannafly-Winter-Camp","permalink":"https://anoyer.cn/categories/2019-Wannafly-Winter-Camp/"}],"tags":[{"name":"Camp","slug":"Camp","permalink":"https://anoyer.cn/tags/Camp/"}]},{"title":"2019 Wannafly Camp day7","slug":"2019-Wannafly-Camp-day7","date":"2019-01-26T14:05:58.000Z","updated":"2019-01-27T02:51:25.045Z","comments":true,"path":"article/2019-Wannafly-Camp-day7.html","link":"","permalink":"https://anoyer.cn/article/2019-Wannafly-Camp-day7.html","excerpt":"","text":"自闭感受Camp第七天，上午xls给我们来了一波意识流图论讲解，我没有包图论所以听了些前面简单的，就去补day3，div1的数论了。经过群里一群大佬的点醒，发现自己傻逼了，明明可以直接用我div2的欧拉函数写法套上两个杜教加分块就能过，还整半天直接用莫比乌斯跑TT。下午训练赛，感觉题目有点坑，数据范围好大，就写了两道签到题EG，队友没有怼出A题，晚上听解题发现自己D题推的离答案就差一两步了，结果放弃了。难受！！！快被自己菜哭了。以后还是要多刷题啊，题量太少了，大佬们看啥都是原题，加油。上题解E - 线性探查法按照哈希的操作进行逆操作，求出每一位最小数值，利用set维护压入的最小值。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=3e3+20;struct Node&#123; ll a; int id; bool operator &lt; (const Node &amp;oth) const&#123; return a &lt; oth.a; &#125;&#125;;ll b[maxn];int main()&#123; int n; set&lt;Node&gt;st; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%lld\",&amp;b[i]); if(b[i]%n==i)st.insert(&#123; b[i] , i &#125;); &#125; for(int i=1;i&lt;n;i++)&#123; //逆操作求解 Node f=*st.begin(); st.erase(st.begin()); b[f.id]=0; //已经插入 printf(\"%lld \",f.a); int j=f.id; while(!b[j])j=(j+1)%n; //找出应该放入的位置 int k=b[j]%n,flag=1; //实际位置 while(k!=j)&#123; if(b[k])&#123; flag=0; &#125; k=(k+1)%n; &#125; if(flag)st.insert(&#123;b[j],j&#125;); &#125; cout&lt;&lt;st.begin()-&gt;a&lt;&lt;endl;&#125;G - 抢红包机器人枚举每个红包的第一个抢的人为机器人，去暴力正反扫两遍红包序列，找出机器人，最后取枚举得到的数的min，最后看看是否有人未参与抢红包，有的话就直接输出1。（可以更优，直接枚举人）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int a[120][120];bool b[120],mp[120];int nn[120];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; int aa; scanf(\"%d\",&amp;nn[i]); for(int j=0;j&lt;nn[i];j++)&#123; scanf(\"%d\",&amp;a[i][j]); b[a[i][j]]=1; //标记此人参与了抢红包 &#125; &#125; int cnt1=0; for(int i=1;i&lt;=n;i++)&#123; if(b[i]==0)cnt1++; &#125; if(cnt1)printf(\"1\\n\"); else &#123; int res=0,ans=999999; for(int i=0;i&lt;m;i++)&#123; memset(mp,0,sizeof(mp)); mp[a[i][0]]=1; res=0; for(int j=0;j&lt;m;j++)&#123; //正扫 for(int k=nn[j]-1;k&gt;=0;k--)&#123; if(mp[a[j][k]])&#123; for(k--;k&gt;=0;k--)&#123; mp[a[j][k]]=1; &#125; &#125; &#125; &#125; for(int j=m-1;j&gt;=0;j--)&#123; //反扫 for(int k=nn[j]-1;k&gt;=0;k--)&#123; if(mp[a[j][k]])&#123; for(k--;k&gt;=0;k--)&#123; mp[a[j][k]]=1; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)if(mp[i])res++; ans=min(ans,res); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"2019 Wannafly Winter Camp","slug":"2019-Wannafly-Winter-Camp","permalink":"https://anoyer.cn/categories/2019-Wannafly-Winter-Camp/"}],"tags":[{"name":"Camp","slug":"Camp","permalink":"https://anoyer.cn/tags/Camp/"}]},{"title":"2019 Wannafly Camp day5","slug":"2019-Wannafly-Camp-day5","date":"2019-01-24T13:24:37.000Z","updated":"2019-01-26T03:07:52.680Z","comments":true,"path":"article/2019-Wannafly-Camp-day5.html","link":"","permalink":"https://anoyer.cn/article/2019-Wannafly-Camp-day5.html","excerpt":"","text":"自闭感受参加Camp第五天，今天是dls的计算几何专场，可是说是几何板子讲解，也是这几天听得最明白，学得最多的一天。dls从基础的点积叉积到线到圆等，感觉非常Nice，相对dls说。下午依旧是训练赛，比昨天感觉好不少，真的是越来越亲民了，还以为今天要爆零自闭呢。同时经过今天的计算几何，感觉自己整理一套计算几何板子真的非常有必要，结束后也该操手了。上题解A - Cactus Draw把节点的深度做x坐标，儿子序做y坐标，进行DFS遍历，因为是棵树所以肯定不会交边123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+10;struct edge&#123; int v,next;&#125;e[maxn];int head[maxn],hcnt=0;int u[maxn],v[maxn];void add(int u,int v)&#123; e[hcnt]=edge&#123;v,head[u]&#125;; head[u]=hcnt++;&#125;pair&lt;int,int&gt; point[maxn];bool vi[maxn];int vis[maxn];void dfs(int u,int x)&#123; if(vi[u])return; vi[u]=1; if(!vis[x]) vis[x]=1; point[u]=make_pair(x,vis[x]++); for(int i=head[u];i&gt;=0;i=e[i].next)&#123; int v=e[i].v; if(vi[v])continue; dfs(v,x+1); &#125;&#125;int main()&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(head,-1,sizeof(head)); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;u[i],&amp;v[i]),add(u[i],v[i]),add(v[i],u[i]); dfs(1,1); for(int i=1;i&lt;=n;i++) cout&lt;&lt;point[i].first&lt;&lt;&apos; &apos;&lt;&lt;point[i].second&lt;&lt;endl; return 0;&#125;C - Division把每个数先压到优先队列中，每次操作取队顶元素除2再压进去，同时判断下队顶是否为0，如果为0就没必要继续操作了。因为数大小1e9所以每个数最多就操作30次。123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+7;priority_queue&lt;int&gt;a;int main()&#123; int n,k,aa; scanf(\"%d%d\",&amp;n,&amp;k); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;aa); a.push(aa); &#125; ll ans=0; for(int i=0;i&lt;k;i++)&#123; aa=a.top(); a.pop(); if(aa==0)&#123; break; &#125; a.push(aa/2); &#125; while(!a.empty())&#123; if(a.top()==0)break; ans+=a.top(); a.pop(); &#125; printf(\"%lld\\n\",ans); return 0;&#125;I - Sorting将小于等于X的数当做0，大于x的数当做1，因为交换后相对顺序不会变，就可以预处理出各自的前缀和，根据处于的位置计算值。用线段树来维护区间内01的个数，Ok啦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;#define ls rt&lt;&lt;1#define rs rt&lt;&lt;1|1int a[maxn],b[maxn];long long int r0[maxn],r1[maxn];int cnt1=1,cnt0=1;struct tree&#123; int l,r; int x; int sum; int lazy;&#125;t[maxn*4];void pushdown(int rt)&#123; if(t[rt].lazy==1)&#123; t[ls].sum=t[ls].r-t[ls].l+1; t[rs].sum=t[rs].r-t[rs].l+1; t[ls].lazy=1; t[rs].lazy=1; &#125; else if(t[rt].lazy==-1)&#123; t[ls].sum=0; t[rs].sum=0; t[ls].lazy=-1; t[rs].lazy=-1; &#125; t[rt].lazy=0;&#125;void build(int rt,int l,int r)&#123; t[rt].l=l; t[rt].r=r; t[rt].x=0; t[rt].sum=0; t[rt].lazy=0; if(t[rt].l==t[rt].r)&#123; return ; &#125; int mid=l+r&gt;&gt;1; build(ls,l,mid); build(rs,mid+1,r);&#125;void dadd(int rt,int x)&#123; if(t[rt].l==x &amp;&amp; t[rt].r==x)&#123; t[rt].x=1; t[rt].sum++; return; &#125; int mid=t[rt].l+t[rt].r&gt;&gt;1; if(mid&lt;x) dadd(rs,x); else dadd(ls,x); t[rt].sum=t[ls].sum+t[rs].sum;&#125;void change(int rt,int ql,int qr,int l,int r,int x,int type)&#123; if(ql&gt;=l &amp;&amp; qr&lt;=r)&#123; if(x==0)&#123; t[rt].sum=0; t[rt].lazy=-1; &#125; else&#123; t[rt].sum=qr-ql+1; t[rt].lazy=1; &#125; return ; &#125; pushdown(rt); int mid=ql+qr&gt;&gt;1; if(l&lt;=mid) change(ls,ql,mid,l,r,x,type); if(r&gt;mid) change(rs,mid+1,qr,l,r,x,type); t[rt].sum=t[ls].sum+t[rs].sum;&#125;int query(int rt,int ql,int qr,int l,int r)&#123; if(l&gt;r)return 0; if(ql&gt;=l &amp;&amp; qr&lt;=r)&#123; return t[rt].sum; &#125; pushdown(rt); int mid=ql+qr&gt;&gt;1; int sum=0; if(l&lt;=mid) sum+= query(ls,ql,mid,l,r); if(r&gt;mid) sum+=query(rs,mid+1,qr,l,r); return sum;&#125;int main()&#123; int n,q,x; cin&gt;&gt;n&gt;&gt;q&gt;&gt;x; build(1,1,n); for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i]&lt;=x)r0[cnt0]=r0[cnt0++-1]+a[i]; else dadd(1,i),r1[cnt1]=r1[cnt1++-1]+a[i]; &#125; int o,L,R; for(int i=1;i&lt;=q;i++)&#123; cin&gt;&gt;o&gt;&gt;L&gt;&gt;R; if(o==1)&#123; int k=query(1,1,n,L,R);//区间内有k个1 int k1=query(1,1,n,1,L-1);//前面有k1个1 int S=R-L+1; int k0=S-k; int k00=L-1-k1; long long int sum1=r1[k1+k]-r1[k1]; long long int sum0=r0[ S-k + L-1-k1 ]-r0[L-1-k1]; cout&lt;&lt;sum1 + sum0&lt;&lt;endl; &#125; else if(o==2)&#123; int k=query(1,1,n,L,R);//区间内有k个1 int k1=R-L+1-k;//k1个0 change(1,1,n,L,L+k1-1,0,0); change(1,1,n,L+k1,R,1,1); &#125; else if(o==3)&#123; int k=query(1,1,n,L,R);//区间内有k个1 int k1=R-L+1-k;//k1个0 change(1,1,n,L,L+k-1,1,1); change(1,1,n,L+k,R,0,0); &#125; &#125; return 0;&#125;J - Special Judge对任意两条边都进行判断是否相交，如果相交则在判断是否是相交于端点，不过不是则ans++。是的话在判断下是不是重合边，如果不是重合边就不符合，是就ans++.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node&#123; double x; double y;&#125;;bool judge(node a,node b,node c,node d)&#123; if(min(a.x,b.x) &lt;= max(c.x,d.x) &amp;&amp; min(c.x,d.x) &lt;= max(a.x,b.x) &amp;&amp; min(a.y,b.y) &lt;= max(c.y,d.y) &amp;&amp;min(c.y,d.y)&lt;=max(a.y,b.y)) &#123; double u,v,w,z;//保存叉乘 u=(c.x-a.x)*(b.y-a.y)-(b.x-a.x)*(c.y-a.y); v=(d.x-a.x)*(b.y-a.y)-(b.x-a.x)*(d.y-a.y); w=(a.x-c.x)*(d.y-c.y)-(d.x-c.x)*(a.y-c.y); z=(b.x-c.x)*(d.y-c.y)-(d.x-c.x)*(b.y-c.y); return (u*v&lt;=0.00000001 &amp;&amp; w*z&lt;=0.00000001); //浮点数判断大小 &#125; return false;&#125;bool onsegment(node pi,node pj,node Q)&#123; if((Q.x-pi.x)*(pj.y-pi.y)==(pj.x-pi.x)*(Q.y-pi.y)&amp;&amp;min(pi.x,pj.x)&lt;=Q.x&amp;&amp;Q.x&lt;=max(pi.x,pj.x)&amp;&amp;min(pi.y,pj.y)&lt;=Q.y&amp;&amp;Q.y&lt;=max(pi.y,pj.y))&#123; return true; &#125;else&#123; return false; &#125;&#125;bool check(node a,node b,node c,node d)&#123; double len=(a.x-b.x)*(c.y-d.y)-(c.x-d.x)*(a.y-b.y); if(len==0)return 1; else return 0;&#125;const int maxn=1020;struct Node&#123; int a,b;&#125;mp[2*maxn];node p[maxn];int main()&#123; int n,m; int ans=0; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;mp[i].a,&amp;mp[i].b); &#125; for(int i=1;i&lt;=n;i++)scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y); for(int i=1;i&lt;=m;i++)&#123; for(int j=i+1;j&lt;=m;j++)&#123; if(judge(p[mp[i].a],p[mp[i].b],p[mp[j].a],p[mp[j].b]))&#123; if(mp[i].a==mp[j].a||mp[i].a==mp[j].b||mp[i].b==mp[j].a||mp[i].b==mp[j].b)&#123; //判断是否是交于端点 if(check(p[mp[i].a],p[mp[i].b],p[mp[j].a],p[mp[j].b]))&#123; //看两边是否平行 //如果平行，通过判断一边的两端点是否在另外一边上 if((onsegment(p[mp[j].a],p[mp[j].b],p[mp[i].a])&amp;&amp;onsegment(p[mp[j].a],p[mp[j].b],p[mp[i].b]))||(onsegment(p[mp[i].a],p[mp[i].b],p[mp[j].a])&amp;&amp;onsegment(p[mp[i].a],p[mp[i].b],p[mp[j].b]))) ans++; &#125; &#125; else ans++; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"2019 Wannafly Winter Camp","slug":"2019-Wannafly-Winter-Camp","permalink":"https://anoyer.cn/categories/2019-Wannafly-Winter-Camp/"}],"tags":[{"name":"Camp","slug":"Camp","permalink":"https://anoyer.cn/tags/Camp/"}]},{"title":"2019 Wannafly Camp day4","slug":"2019-Wannafly-Camp-day4","date":"2019-01-23T14:12:24.000Z","updated":"2019-01-27T14:30:44.530Z","comments":true,"path":"article/2019-Wannafly-Camp-day4.html","link":"","permalink":"https://anoyer.cn/article/2019-Wannafly-Camp-day4.html","excerpt":"","text":"自闭感受Camp第四天，非常傻逼并快乐的一天​ 。上午Claris给我们讲DP，而且从基础开始讲，虽然没有包DP，但是还是学到了不少，非常棒。中午所有人在科技楼下面来了一张大合影 (寒风中瑟瑟发抖) ，最最最最happy的是找各位巨巨们要到了签名，(可惜没要到唐老师的​ ​​ )下午训练是目前几场最签到的场了，但是不知为啥周围加我队3队人都傻逼了，明明非常简单片面的东西看的非常复杂，真的是…不想说了，最后吸取教训不管题目怎么样，都有保持一颗平常心态和清醒的头脑。上题解A - 夺宝奇兵很简单的一道题，相邻两组宝藏走法只有两种交叉走，或者平行走（就是一号第一个宝藏走到二号第二个或者一号第一个走到二号第一个），所以for扫一遍去min就可以了12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+7;int a[maxn],b[maxn];ll dis(int i,int j)&#123; return abs(a[i]-a[j])+abs(b[i]-b[j]);&#125;int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;2*n;i++)scanf(\"%d%d\",&amp;a[i],&amp;b[i]); ll ans=dis(2*n-1,2*n-2); for(int i=2;i&lt;2*n;i+=2)&#123; ans+=min(dis(i,i-2)+dis(i+1,i-1),dis(i,i-1)+dis(i+1,i-2)); &#125; printf(\"%lld\\n\",ans);&#125;C - 最小边覆盖最小边覆盖，不能有多余的边重复覆盖点。所以如果发现一个点被多余的覆盖了就不是最小点覆盖12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int in[maxn],u[maxn],v[maxn];int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;u[i],&amp;v[i]); in[u[i]]++; in[v[i]]++; &#125; for(int i=1;i&lt;=m;i++)&#123; if(in[u[i]]&gt;1 &amp;&amp; in[v[i]]&gt;1)&#123; printf(\"No\\n\"); exit(0); &#125; &#125; printf(\"Yes\\n\"); return 0;&#125;F - 小小马因为走法比较特殊，如果当前xy奇偶性相同，下一步则必定不同，所以黑白格子是轮流出现的，这样就可以根据起点和终点的奇偶性判断是否黑格数等于白格数了。同时可以发现只有棋盘大于3 4可以从一个点到达棋盘任何点， 3 3的棋盘除去中心点其余点都能相互走到，其他棋盘情况就看看从起点和终点xy的关系，如果a%2==0&amp;&amp;(a/2)%2==1&amp;&amp;b==1则可以走。12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m,sx,sy,ex,ey; cin&gt;&gt;n&gt;&gt;m&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey; if(n&gt;=3&amp;&amp;m&gt;=3)&#123; if((n==3&amp;&amp;m==3)&amp;&amp;(sx==2&amp;&amp;sy==2)||(ex==2&amp;&amp;sy==2))&#123; printf(\"No\\n\"); return 0; &#125; if((sx%2+sy%2)%2==(ex%2+ey%2)%2)printf(\"No\\n\"); else printf(\"Yes\\n\"); &#125; else&#123; int a=max(abs(sy-ey),abs(sx-ex)),b=min(abs(sy-ey),abs(sx-ex)); if(a%2==0&amp;&amp;(a/2)%2==1&amp;&amp;b==1) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125;&#125;G - 置置置换定义dp[i][j]为 i个数的排列中，最后一个数字为j当i为偶数的时候，位于山谷，需要前面大于他dp[i][j]+=dp[i-1][k], j&lt;=k&lt;=i-1之所以可以这么写是因为，前面并没有出现i这个数字，所以也没有计算dp[i-1][i]，但是有个巧妙的做法假设把前面所有大于等于j的数+1，就刚好解决这个问题了。当i为奇数的时候，位于山峰，需要前面小于他dp[i][j]+=dp[i-1][k], 1&lt;=k&lt;=j-1;这个很显然直接写是n^3，可以使用前缀和优化1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;const int MOD=1e9+7;typedef long long ll;ll dp[1010][1010];int sum[maxn];int main()&#123; int n; scanf(\"%d\",&amp;n); dp[1][1]=1; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; if(i&amp;1)//奇数，升序 从1-&gt;(j-1)转移 dp[i][j]=(dp[i][j-1]+dp[i-1][j-1]+MOD)%MOD;//前缀和优化 else&#123;//偶数，降序 从j -&gt; i转移 dp[i][j]=(dp[i][j-1]+dp[i-1][i-1]-dp[i-1][j-1]+MOD)%MOD; &#125; &#125; &#125; printf(\"%lld\\n\",dp[n][n]); return 0;&#125;I - 咆咆咆哮基本思路就是贪心枚举选a的数量num，去选择num个对ans贡献最大a，然后ans取min。123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e3+7;struct Node&#123; int a,b;&#125;a[maxn];int num;bool cmp(Node a,Node b)&#123; return a.a-num*a.b&gt;b.a-num*b.b;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d%d\",&amp;a[i].a,&amp;a[i].b); &#125; ll ans=0,anss=0; for(num=1;num&lt;=n;num++)&#123; sort(a,a+n,cmp); anss=0; for(int i=0;i&lt;num;i++)anss+=a[i].a; for(int i=num;i&lt;n;i++)anss+=num*a[i].b; ans=max(ans,anss); &#125; printf(\"%lld\\n\",ans); return 0;&#125;","categories":[{"name":"2019 Wannafly Winter Camp","slug":"2019-Wannafly-Winter-Camp","permalink":"https://anoyer.cn/categories/2019-Wannafly-Winter-Camp/"}],"tags":[{"name":"Camp","slug":"Camp","permalink":"https://anoyer.cn/tags/Camp/"}]},{"title":"2019 Wannafly Camp day3","slug":"2019-Wannafly-Camp-day3","date":"2019-01-22T08:46:05.000Z","updated":"2019-01-26T03:08:03.583Z","comments":true,"path":"article/2019-Wannafly-Camp-day3.html","link":"","permalink":"https://anoyer.cn/article/2019-Wannafly-Camp-day3.html","excerpt":"","text":"自闭感受参加Camp的第三天，上午是数据结构专题分享，dls 不打CF，分数可能比我们都低的2300分只打过三场的巨巨队友 wls来给我们讲的​ ​​ 。比起昨天的数论专场，今天感觉好多了，懵逼少很多还能跟上节奏。wls是带着题目来给我们讲常见的数据结构运用，比如堆，并查集，线段树，平衡树等等。下午原本以为是数据结构专题训练，便戏耍的和lyy说下午你专场我回去了哈 ​ 。结果下午题目比day1,day2还难，而且不是想象中的数据结构专题。一开始我便瞄到了F题，好眼熟！！！这不是莫比乌斯反演吗？就开始怼了。lyy开了D，结果这​ SB不会写，我先放了下F题，看了下G题发现G题是个签到题 (上面写的) 。我就叫他看G，然后我切回了我的F。一波推式子，发现思路可行就巴拉巴拉敲了起来，中间因为炸int问题wa了几发，SB了！队友G题比我先过了，确实是个签到题​ ​​。最后有个乌龙，4点多的样子，队友和旁队的一起随机猜吧A题(因为只有2组数据，一共就1024种情况)，竟然A了，然后大喊了一声答案，果断一波A的AC流。不知道出题人看到会心咋想感受：非常难得场上A出一道正儿八经的数论反演题，开森，同时发现队伍配合实在差，必须好好抓抓，不然要GG，尤其新人。上题解（后期补题会更新其他能力范围内的题解）F - 小清新数论做法一：欧拉函数12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int maxn = 1e7+9;const LL mod = 998244353;LL phi[maxn],miu[maxn],fac[maxn];//phi--欧拉函数表 miu--莫比乌斯函数表 fac--i最大的素因子辅助打phi表void init()&#123; for (int i = 1; i &lt; maxn; ++i) fac[i] = i; phi[1] = miu[1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; if (fac[i] == i) for (int j = i &lt;&lt; 1; j &lt; maxn; j += i) fac[j] = i; if (i / fac[i] % fac[i]) phi[i] = (fac[i] - 1)*phi[i / fac[i]], miu[i] = -miu[i / fac[i]]; //如果b质数 a%b！=0 phi(a*b) = phi(a)*b - phi(a) else phi[i] = fac[i] * phi[i / fac[i]], miu[i] = 0; //当b是质数，a%b==0，phi(a*b)=phi(a)*b &#125; for(int i=1;i&lt;maxn;i++)phi[i]=phi[i]+phi[i-1];&#125;int main()&#123; init(); LL n; cin&gt;&gt;n; LL NN=n; LL ans=0; for(LL i=1;i&lt;=NN;i++)&#123; LL res=(phi[NN/i]*(LL)2-1)%mod; ans=(ans+miu[i]*res%mod)%mod; while(ans&lt;0)ans+=mod; &#125; printf(\"%lld\\n\",ans);&#125;做法二：莫比乌斯反演12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=998244353;const int maxn=1e7+1;ll phi[maxn],miu[maxn],vis[maxn];void init()&#123; for(int i=1;i&lt;maxn;++i)vis[i]=i; phi[1]=miu[1]=1; for(int i=2;i&lt;maxn;i++)&#123; if(vis[i]==i)&#123; for(int j=i&lt;&lt;1;j&lt;maxn;j+=i)vis[j]=i; &#125; if(i/vis[i]%vis[i])miu[i]= -miu[i/vis[i]]; else miu[i]=0; &#125; for(int i=1;i&lt;maxn;i++)miu[i]=miu[i]+miu[i-1];&#125;ll solve(int n,int m)&#123; ll ans=0; int N=min(n,m),r; for(int l =1;l&lt;=N;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); //取分块小的数 ll res=(miu[r]-miu[l-1]+mod)%mod*(n/l)%mod*(n/l)%mod; //miu[r]-miu[l-1]表示l~r区间miu和， ans=(ans+res+mod)%mod; &#125; return ans;&#125;int main()&#123; init(); int n,r; scanf(\"%d\",&amp;n); ll ans=0,res; for(int l=1;l&lt;=n;l=r+1)&#123; r=n/(n/l); res=(miu[r]-miu[l-1]+mod)%mod*solve(n/l,n/l)%mod; ans=(ans+res+mod)%mod; &#125; printf(\"%lld\\n\",ans); return 0;&#125;做法三：杜教筛能过div1，跑了1423ms，对做法一中欧拉函数前n项和，欧拉函数前n项和进行杜教筛，然后套一个分块求解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define INV2 499122177using namespace std;typedef long long ll;const int N=1e7+20;const int mod=998244353;bool vis[N];int mu[N],sum1[N];long long phi[N],sum2[N];int cnt,prim[N];int e,e1;tr1::unordered_map&lt;long long,long long&gt;w,w1; //哈希 w用来求phi前缀和 w1用来求miu前缀和void get(int maxn)&#123; phi[1]=mu[1]=1; for(int i=2;i&lt;=maxn;i++) &#123; if(!vis[i]) &#123; prim[++cnt]=i; mu[i]=-1;phi[i]=i-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=maxn;j++) &#123; vis[i*prim[j]]=1; if(i%prim[j]==0) &#123; phi[i*prim[j]]=phi[i]*prim[j]; break; &#125; else mu[i*prim[j]]=-mu[i],phi[i*prim[j]]=phi[i]*(prim[j]-1); &#125; &#125; for(int i=1;i&lt;=maxn;i++)sum1[i]=sum1[i-1]+mu[i],sum2[i]=(sum2[i-1]+phi[i])%mod; //打一个maxn的phi前缀和表 和miu前缀和表&#125;int djsmu(long long x) // 求miu前缀和&#123; if(x&lt;=10000000)return sum1[x]; if(w[x])return w[x]; int ans=1; for(long long l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); ans-=(r-l+1ll)*djsmu(x/l); &#125; return w[x]=ans;&#125;long long djsphi(long long x) //求phi 前缀和&#123; if(x&lt;=10000000)return sum2[x]; if(w1[x])return w1[x]; long long ans=x%mod*(x+1)%mod*INV2%mod; for(long long l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); ans=(ans-(r-l+1)%mod*djsphi(x/l)+mod)%mod; &#125; while(ans&lt;0)ans+=mod; return w1[x]=ans%mod;&#125;int main()&#123; get(10000000); ll n,r; scanf(&quot;%lld&quot;,&amp;n); ll ans=0,res; for(ll l=1;l&lt;=n;l=r+1)&#123; r=n/(n/l); res=(ll)(djsmu(r)-djsmu(l-1)+mod)%mod*((djsphi(n/l)%mod*(ll)2%mod-1+mod)%mod)%mod; ans=(ans+res+mod)%mod; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;G - 排列**搞清楚每个数组都是干什么的。P 原数组Ap 前缀数组q Ap中第i大的位置（相同的先取左边，例如 AP={2，1， 1}，第1小的位置是2而不是3.）现在题目给了q，可以根据q倒推出Ap，然后倒推出P12345678910111213141516171819202122232425262728293031include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn =1e5+10;int a[maxn];int q[maxn];int main()&#123; int n; scanf(\"%d\",&amp;n); int cnt=0; int pre=maxn+10; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); if(a[i]&gt;pre) q[a[i]]=cnt; else q[a[i]]=++cnt; pre=a[i]; &#125; cnt=q[1]; printf(\"%d \",cnt); for(int i=2;i&lt;=n;i++)&#123; if(q[i]&lt;q[i-1]) printf(\"%d \",q[i]); else&#123; printf(\"%d \",++cnt); &#125; &#125; return 0;&#125;","categories":[{"name":"2019 Wannafly Winter Camp","slug":"2019-Wannafly-Winter-Camp","permalink":"https://anoyer.cn/categories/2019-Wannafly-Winter-Camp/"}],"tags":[{"name":"Camp","slug":"Camp","permalink":"https://anoyer.cn/tags/Camp/"}]},{"title":"2019 Wannafly Camp day2","slug":"2019-Wannafly-Camp-day2","date":"2019-01-21T14:23:52.000Z","updated":"2019-01-26T03:07:40.209Z","comments":true,"path":"article/2019-Wannafly-Camp-day2.html","link":"","permalink":"https://anoyer.cn/article/2019-Wannafly-Camp-day2.html","excerpt":"","text":"自闭感受今天上午吉老师吉老师给我们讲了一通数论知识，可以说是醍醐灌顶吧，半懂半懵（简单的懂了，难的n^n脸懵逼），真的是菜的教不来啊 不过吉老师不亏是WF金牌爷，属实强大啊。下午数论自闭专场（好像大部分数论题都没几个做出来的 ），自闭场了就写出2道题AH，有点难受，K题队友T了,B吃饭时候想出了正确的贪心策略。开始我先开的A题，队友lyy和hxx开了K题，同时写崩，A题写半天发现怼的是div1的B题，K题lyy先T。后来A题瞎几把想了个假的贪心，贪最大值，果断wa了3发，发现是个假策略并算了算复杂度发现直接n方暴力。然后hxx的k也T了，对拍了波两人代码，发现没错误，那就凉了假算法。此时lyy便切到了B题，我开了H题，发现是个求球交体积的题目，取横截面积进行微积分（我有板子自己裸板子过的），在这题还闹了个乌龙，样例完全正确后，我交了H并和队友说了句过了，队友说小心WA，秒回了“样例过了就是过了”,结果CE​ ​ ，有个结构体函数忘了函数类型，改改就A了。H过后便和lyy开始怼B题，因为K题实在不会了，目测是状压DP不会写。B题HACK了好几个YY出来的的假贪心策略之后，就直接去吃饭了，吃饭时候想到了贪长度，可惜已经GG了。今天虽然是数论专场，但是感觉打脸最多的就是自己的假贪心策略，以后想出的策略觉得要证明正确性再写，一定不要莽上题解（后期补题会更新其他能力范围内的题解）A-Erase Numbers II123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define ull unsigned long longusing namespace std;const int maxn = 6e3 + 10;ull a[maxn];void slove(ull &amp;a, ull b)&#123; while(b)&#123; a *= 10; b /= 10; &#125;&#125;int main()&#123; int t, t1 = 1; scanf(\"%d\", &amp;t); while(t--)&#123; int n; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; ull ans = 0, temp; for(int i = 0; i &lt; n - 1; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; temp = a[i]; slove(temp, a[j]); ans = max(ans, temp + a[j]); &#125; &#125; cout &lt;&lt; \"Case #\" &lt;&lt; t1++ &lt;&lt; \": \" &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;H-Cosmic Cleaner123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const double PI = acos(-1.0);typedef long long ll;const int maxn=120;struct point &#123; double x,y,z; point() &#123;&#125; void Init(double a, double b,double c)&#123; x = a; y = b; z = c; &#125; point(double a, double b,double c)&#123; x = a; y = b; z = c; &#125; point operator -(const point &amp;b)const &#123; //返回减去后的新点 return point(x - b.x, y - b.y,z-b.z); &#125; point operator +(const point &amp;b)const &#123; //返回加上后的新点 return point(x + b.x, y + b.y,z+b.z); &#125; //数乘计算 point operator *(const double &amp;k)const &#123; //返回相乘后的新点 return point(x * k, y * k,z*k); &#125; point operator /(const double &amp;k)const &#123; //返回相除后的新点 return point(x / k, y / k,z/k); &#125; double operator *(const point &amp;b)const &#123; //点乘 return x*b.x + y*b.y+z*b.z; &#125;&#125;;double dist(point p1, point p2) &#123; //返回平面上两点距离 return sqrt((p1 - p2)*(p1 - p2));&#125;struct sphere &#123;//球 double r; point centre;&#125;;void SphereInterVS(sphere a, sphere b,double &amp;v) &#123; double d = dist(a.centre, b.centre);//球心距 if(d&gt;=a.r+b.r)return; if(a.r-d&gt;=b.r)&#123; v+=PI*4.0/3.0*b.r*b.r*b.r; return; &#125; if(a.r&lt;=b.r-d)&#123; v+=PI*4.0/3.0*a.r*a.r*a.r; return; &#125; double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);// double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高 double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d)); //余弦公式计算r1对应圆心角，弧度 double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d)); //余弦公式计算r2对应圆心角，弧度 double l1 = ((a.r*a.r - b.r*b.r) / d + d) / 2; double l2 = d - l1; double x1 = a.r - l1, x2 = b.r - l2;//分别为两个球缺的高度 double v1 = PI*x1*x1*(a.r - x1 / 3);//相交部分r1圆所对应的球缺部分体积 double v2 = PI*x2*x2*(b.r - x2 / 3);//相交部分r2圆所对应的球缺部分体积 v += v1 + v2;//相交部分体积&#125;struct Node&#123; double x,y,z,r;&#125;a[maxn];double x,y,z,r;int n;double Solve()&#123; double v=0; sphere A,B; A.r=r; A.centre.Init(x,y,z); for(int i=0;i&lt;n;i++)&#123; B.r=a[i].r; B.centre.Init(a[i].x,a[i].y,a[i].z); SphereInterVS(A,B,v); &#125; return v;&#125;int main()&#123; int t,tt=1; /*sphere A,B; A.r=1; A.centre.Init(0,0,0); B.r=1; B.centre.Init(0,0,0); double v=0; SphereInterVS(A,B,v); printf(\"%lf\",v);*/ scanf(\"%d\",&amp;t); while(tt&lt;=t)&#123; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%lf%lf%lf%lf\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].z,&amp;a[i].r); &#125; scanf(\"%lf%lf%lf%lf\",&amp;x,&amp;y,&amp;z,&amp;r); printf(\"Case #%d: %.10lf\\n\",tt++,Solve()); &#125; return 0;&#125;","categories":[{"name":"2019 Wannafly Winter Camp","slug":"2019-Wannafly-Winter-Camp","permalink":"https://anoyer.cn/categories/2019-Wannafly-Winter-Camp/"}],"tags":[{"name":"Camp","slug":"Camp","permalink":"https://anoyer.cn/tags/Camp/"}]},{"title":"2019 Wannafly Camp Day1","slug":"2019-Wannafly-Camp-day1","date":"2019-01-20T14:19:23.000Z","updated":"2019-01-27T11:03:59.008Z","comments":true,"path":"article/2019-Wannafly-Camp-day1.html","link":"","permalink":"https://anoyer.cn/article/2019-Wannafly-Camp-day1.html","excerpt":"","text":"自闭感受第一次参加这种线下的算法Camp，不得不说和队友都是内心非常的小鸡动。上午开幕式wls讲了一堆话，差不多就是一起呲逼加鸡汤吧（哈哈希望wls不要打死我）。下午就是day训练赛了，因为一个主力队友生病没来，带着一个新队友2排，直接跳过了图论和DP题，差点就死怼C构造和E暴零自闭了，最后发现J题原题一发A，最后C题放弃了构造去写了100*100的暴力过了（抹汗）。自己还是太菜了，还有好多成长空间，细节，第一解题反应，耐心等等。不多说上题解（后期补题会更新其他能力范围内的题解）B-吃豆豆思路：3维DP维护一个3维数组，表示(i,j)位置第K秒有多少糖果，通过k-1秒5个位置转移得到(i,j,k)123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=10010;int dp[20][20][maxn];int mp[20][20];int main()&#123; int n,m,c,xs,ys,xt,yt; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)scanf(\"%d\",&amp;mp[i][j]); scanf(\"%d%d%d%d\",&amp;xs,&amp;ys,&amp;xt,&amp;yt); memset(dp,-0x3f,sizeof(dp)); dp[xs][ys][0]=0; for(int k=1;k&lt;maxn;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; dp[i][j][k]=max(&#123;dp[i-1][j][k-1],dp[i][j+1][k-1],dp[i+1][j][k-1],dp[i][j-1][k-1],dp[i][j][k-1]&#125;)+(k%mp[i][j]==0?1:0); &#125; int _max=-1; for(int i=0;i&lt;maxn;i++)if(dp[xt][yt][i]&gt;=c)&#123;_max=i;break;&#125; printf(\"%d\\n\",_max);&#125;C-拆拆拆数思路：题目只有1和2的情况，如果ab互质则为1，如果不互质n为2，且一定存在答案（第一感觉是这样）。开始我对n=2的情况去构造，发现一直wa（菜哭了），后来A了J题后重新换了100*100暴力枚举两组ai,bi。1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e9+7;const int mod=1e5+7;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; ll a,b; scanf(\"%lld%lld\",&amp;a,&amp;b); if(__gcd(a,b)==1)&#123; printf(\"1\\n%lld %lld\\n\",a,b); &#125; else&#123; int flag=0; for(ll i=2;i&lt;=100;i++)&#123; for(ll j=2;j&lt;=100;j++)&#123; if(__gcd(a-i,b-j)==1&amp;&amp;__gcd(i,j)==1)&#123; printf(\"2\\n%lld %lld\\n\",i,j); printf(\"%lld %lld\\n\",a-i,b-j); flag=1; break; &#125; &#125; if(flag)break; &#125; &#125; &#125; return 0;&#125;E - 流流流动直接连边树形dp计算。需要注意的是图并非联通，可以使用并查集，判断这个集合是否已经处理过。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=110;vector&lt;int&gt; e[maxn];void add(int u,int v)&#123;e[u].push_back(v),e[v].push_back(u);&#125;int pre[maxn];int fin(int x)&#123;return pre[x]==x?x:pre[x]=fin(pre[x]);&#125;void unio(int a,int b)&#123;pre[fin(a)]=fin(b);&#125;int f[maxn],d[maxn];long long int dp[maxn][2];bool vis[maxn];void dfs(int u,int pre)&#123; dp[u][1]=f[u]; for(int i=0;i&lt;e[u].size();i++)&#123; int v=e[u][i]; if(v==pre)continue; dfs(v,u); dp[u][0]+=max(dp[v][0],dp[v][1]); dp[u][1]+=max(dp[v][0],dp[v][1]-d[min(u,v)]); &#125;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123;scanf(\"%d\",&amp;f[i]);pre[i]=i;&#125; for(int i=1;i&lt;=n;i++)&#123;scanf(\"%d\",&amp;d[i]);&#125; for(int i=2;i&lt;=n;i++)&#123; if((i&amp;1) &amp;&amp; (3*i+1&lt;=n))&#123; add(i,3*i+1); unio(i,3*i+1); &#125; else if (i%2==0)&#123; add(i,i/2); unio(i,i/2); &#125; &#125; long long ans=0; for(int i=1;i&lt;=n;i++)&#123; int p=fin(i); if(!vis[fin(i)])&#123; vis[fin(i)]=1; dfs(fin(i),fin(i)); ans+=max(dp[fin(i)][0],dp[fin(i)][1]); &#125; &#125; printf(\"%lld\\n\",ans); return 0;&#125;F-爬爬爬山第一座山的高度确定了，R[1]。当前体力为k，山与山之间的边权为w。那么当后面山的高度大于R[1]+k的时候就需要将山的高度降低。上山消耗体力，下山增加体力，其实就相同高度低于R[1]的时候这个山不存在。因为如果碰到了一个在高的山，增加的体力就被抵消了，相同于没有。那就将边权加上多出来的那部分，（R[x]-（R[1]+k）)^2，然后跑最短路就行了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;const long long inf=0x3f3f3f3f3f3f3f3f;long long dis[maxn];bool vis[maxn];struct node&#123; int u; long long dis; bool operator &lt; (const node &amp;r)const&#123; return dis&gt;r.dis; &#125;&#125;;struct edge&#123; int v; long long w; int next;&#125;e[maxn*10];int head[maxn*10],hcnt=0;int n,m,k;void add(int u,int v,long long int w)&#123; e[hcnt]=edge&#123;v,w,head[u]&#125;; head[u]=hcnt++;&#125;void dij(int start)&#123; priority_queue&lt;node&gt; que; for(int i=1;i&lt;=n;i++) vis[i]=false,dis[i]=inf; que.push(&#123;start,0&#125;); dis[start]=0; while(!que.empty())&#123; int u=que.top().u; que.pop(); if(vis[u])continue; vis[u]=1; for(int i=head[u];i&gt;=0;i=e[i].next)&#123; int v=e[i].v; if(dis[v]&gt;dis[u]+e[i].w) dis[v]=dis[u]+e[i].w,que.push(&#123;v,dis[v]&#125;); &#125; &#125;&#125;long long int r[maxn];int main()&#123; memset(head,-1,sizeof(head)); scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++)scanf(\"%lld\",&amp;r[i]); for(int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); add(u,v,w+max(0LL,r[v]-(r[1]+k))*max(0LL,r[v]-(r[1]+k))); add(v,u,w+max(0LL,r[u]-(r[1]+k))*max(0LL,r[u]-(r[1]+k))); &#125; dij(1); printf(\"%lld\\n\",dis[n]); return 0;&#125;J-夺宝奇兵思路：看着题比较晚了，一看woc这不就是CF原题嘛，考虑枚举最终票数。枚举完票数就开始处理，把每个党超过这个票数且收钱最少的人收买过来，如果这些人都收买完了可是还没有达到预定的票数，就一直收买之前还没有收买过的学生直到人数达标,就这样巴拉巴拉A了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;bits\\stdc++.h&gt;using namespace std;typedef long long ll;int n,m,ns,cnt[3005],Sum[3005];struct peo&#123; int p,c,rk;&#125;a[3005];struct val&#123; int rk,v;&#125;b[3005];bool vis[3005];ll min_ans=-1,ans;bool cmpa (peo a,peo b)&#123; if(a.p==b.p) return a.c&lt;b.c; return a.p&lt;b.p;&#125;bool cmpb (val a,val b)&#123; return a.v&lt;b.v;&#125;int main()&#123; scanf(\"%d%d\",&amp;m,&amp;n); for (int i=1;i&lt;=n;++i)&#123; scanf(\"%d%d\",&amp;a[i].c,&amp;a[i].p); a[i].p++; a[i].rk=i; b[i].rk=i; b[i].v=a[i].c; &#125; sort(a+1,a+1+n,cmpa); sort(b+1,b+1+n,cmpb); for (int i=1;i&lt;=n;++i) Sum[ a[i].p ]++; for (int s=1;s&lt;=n;++s)&#123; ns=0; ans=0; memset(vis,0,sizeof(vis)); memset(cnt,0,sizeof(cnt)); for (int j=1;j&lt;=n;++j)&#123; if(a[j].p==1) ns++,vis[ a[j].rk ]=true; else&#123; if(Sum[ a[j].p ]-cnt[ a[j].p ]&gt;=s)&#123; vis[ a[j].rk ]=true; cnt[ a[j].p ]++; ans+=a[j].c; ns++; &#125; &#125; &#125; for (int i=1;i&lt;=n;++i)&#123; if(ns&gt;=s) break; if(vis[ b[i].rk ]) continue; ns++; ans+=b[i].v; &#125; if(min_ans==-1) min_ans=ans; min_ans=min(ans,min_ans); &#125; cout&lt;&lt;min_ans; return 0;&#125;","categories":[{"name":"2019 Wannafly Winter Camp","slug":"2019-Wannafly-Winter-Camp","permalink":"https://anoyer.cn/categories/2019-Wannafly-Winter-Camp/"}],"tags":[{"name":"Camp","slug":"Camp","permalink":"https://anoyer.cn/tags/Camp/"}]},{"title":"输入外挂总结","slug":"Fread","date":"2019-01-18T09:20:46.000Z","updated":"2019-01-24T04:39:42.010Z","comments":true,"path":"article/Fread.html","link":"","permalink":"https://anoyer.cn/article/Fread.html","excerpt":"","text":"题外话明明在C语言中有scanf()、printf()，C++中有cin、cout，为什么我们还要用输入输出外挂呢？这个问题很明显，一定是因为这些输入输出函数功能过于强大而导致效率低，（很多时候，功能越强大的东西越臃肿），而我们使用的输入输出外挂既然叫外挂，那说明其一定有很大的优势，而这方面优势就体现在术有专攻上。原来的输入输出函数因为要应对不同类型的输入输出，所以内部一定做了很多的判断，而我们在遇见实际问题时，往往都是对特定类型的进行输入输出，所以这些判断就显得无用且浪费资源。这时，我们的输入输出外挂也就有了存在的必要性，也就应运而生。我们都知道，scanf()、printf()、cin、cout其实就是对其他一些基础的获取或输出语句（getchar() putchar()等）进行封装，而这些基础的函数功能弱，效率高，所以我们的输入输出外挂也是仿照着scanf()、printf()、cin、cout来实现的，只不过做了针对性的改造，最终我们改造出来多种功能比scanf()等弱、比getchar()等强，效率比scanf()等高、比gerchar()等低的函数，从而达到针对性的作用，减少了不必要的资源消耗。当然输入输出外挂一般用在大量输入输出的情况下，这样性价比才高一些，否则得不偿失（牺牲了代码长度而换来了微不足道的效率提升）。摘抄原文：https://blog.csdn.net/f_zyj/article/details/51473493普通输入外挂(适用于正整数)12345void read(int &amp;x)&#123; char ch = getchar(); x = 0; for (; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for (; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = x * 10 + ch - '0';&#125;整数输入外挂(适用于整数)123456789101112131415const int BufferSize=1&lt;&lt;16;char buffer[BufferSize],*head,*tail;inline char Getchar() &#123; if(head==tail) &#123; int l=fread(buffer,1,BufferSize,stdin); tail=(head=buffer)+l; &#125; return *head++;&#125;inline int read() &#123; int x=0,f=1;char c=Getchar(); for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1; for(;isdigit(c);c=Getchar()) x=x*10+c-'0'; return x*f;&#125;加强版输入外挂(速度比普通输入外挂快不少)12345678910111213141516171819202122232425262728namespace fastIO &#123;#define BUF_SIZE 100000 //fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE; if (p1 == pend) &#123; p1 = buf; pend = buf + fread(buf, 1, BUF_SIZE, stdin); if (pend == p1) &#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank(char ch) &#123; return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while (blank(ch = nc())); if (IOerror) return; for (x = ch - '0'; (ch = nc()) &gt;= '0' &amp;&amp; ch &lt;= '9'; x = x * 10 + ch - '0'); &#125;#undef BUF_SIZE&#125;;using namespace fastIO;加强版完整型输入外挂包(速度快，适用于整形，浮点型)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121namespace fastIO&#123; #define BUF_SIZE 100000 #define OUT_SIZE 100000 #define ll long long //fread-&gt;read bool IOerror=0; inline char nc()&#123; static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if (p1==pend)&#123; p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if (pend==p1)&#123;IOerror=1;return -1;&#125; //&#123;printf(\"IO error!\\n\");system(\"pause\");for (;;);exit(0);&#125; &#125; return *p1++; &#125; inline bool blank(char ch)&#123;return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';&#125; inline void read(int &amp;x)&#123; bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (sign)x=-x; &#125; inline void read(ll &amp;x)&#123; bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (sign)x=-x; &#125; inline void read(double &amp;x)&#123; bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (ch=='.')&#123; double tmp=1; ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0'); &#125; if (sign)x=-x; &#125; inline void read(char *s)&#123; char ch=nc(); for (;blank(ch);ch=nc()); if (IOerror)return; for (;!blank(ch)&amp;&amp;!IOerror;ch=nc())*s++=ch; *s=0; &#125; inline void read(char &amp;c)&#123; for (c=nc();blank(c);c=nc()); if (IOerror)&#123;c=-1;return;&#125; &#125; //fwrite-&gt;write struct Ostream_fwrite&#123; char *buf,*p1,*pend; Ostream_fwrite()&#123;buf=new char[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;&#125; void out(char ch)&#123; if (p1==pend)&#123; fwrite(buf,1,BUF_SIZE,stdout);p1=buf; &#125; *p1++=ch; &#125; void print(int x)&#123; static char s[15],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); &#125; void println(int x)&#123; static char s[15],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); out('\\n'); &#125; void print(ll x)&#123; static char s[25],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); &#125; void println(ll x)&#123; static char s[25],*s1;s1=s; if (!x)*s1++='0';if (x&lt;0)out('-'),x=-x; while(x)*s1++=x%10+'0',x/=10; while(s1--!=s)out(*s1); out('\\n'); &#125; void print(double x,int y)&#123; static ll mul[]=&#123;1,10,100,1000,10000,100000,1000000,10000000,100000000, 1000000000,10000000000LL,100000000000LL,1000000000000LL,10000000000000LL, 100000000000000LL,1000000000000000LL,10000000000000000LL,100000000000000000LL&#125;; if (x&lt;-1e-12)out('-'),x=-x;x*=mul[y]; ll x1=(ll)floor(x); if (x-floor(x)&gt;=0.5)++x1; ll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2); if (y&gt;0)&#123;out('.'); for (size_t i=1;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];out('0'),++i); print(x3);&#125; &#125; void println(double x,int y)&#123;print(x,y);out('\\n');&#125; void print(char *s)&#123;while (*s)out(*s++);&#125; void println(char *s)&#123;while (*s)out(*s++);out('\\n');&#125; void flush()&#123;if (p1!=buf)&#123;fwrite(buf,1,p1-buf,stdout);p1=buf;&#125;&#125; ~Ostream_fwrite()&#123;flush();&#125; &#125;Ostream; inline void print(int x)&#123;Ostream.print(x);&#125; inline void println(int x)&#123;Ostream.println(x);&#125; inline void print(char x)&#123;Ostream.out(x);&#125; inline void println(char x)&#123;Ostream.out(x);Ostream.out('\\n');&#125; inline void print(ll x)&#123;Ostream.print(x);&#125; inline void println(ll x)&#123;Ostream.println(x);&#125; inline void print(double x,int y)&#123;Ostream.print(x,y);&#125; //y为小数点后几位 inline void println(double x,int y)&#123;Ostream.println(x,y);&#125; inline void print(char *s)&#123;Ostream.print(s);&#125; inline void println(char *s)&#123;Ostream.println(s);&#125; inline void println()&#123;Ostream.out('\\n');&#125; inline void flush()&#123;Ostream.flush();&#125; //清空 #undef ll #undef OUT_SIZE #undef BUF_SIZE&#125;;using namespace fastIO;","categories":[{"name":"C++语法","slug":"C-语法","permalink":"https://anoyer.cn/categories/C-语法/"}],"tags":[{"name":"输入外挂","slug":"输入外挂","permalink":"https://anoyer.cn/tags/输入外挂/"}]},{"title":"C++记录程序运行时间5大方法","slug":"Run-Time","date":"2019-01-18T09:20:23.000Z","updated":"2019-01-24T04:42:29.767Z","comments":true,"path":"article/Run-Time.html","link":"","permalink":"https://anoyer.cn/article/Run-Time.html","excerpt":"","text":"1.用clock()函数用clock()函数，得到系统启动以后的毫秒级时间，然后除以CLOCKS_PER_SEC，就可以换成“秒”，标准c函数。1234clock_t start_time=clock();init();clock_t end_time=clock();cout &lt;&lt; \"The run time is: \" &lt;&lt;(double)(end_time - start_time) / CLOCKS_PER_SEC &lt;&lt; \"s\" &lt;&lt; endl;2.用GetTickCount()函数1234DWORD Start = GetTickCount();//这里运行你的程序代码DWORD End = GetTickCount();//则(End-Start)就是你的程序运行时间, 以毫秒为单位这个函数只精确到55ms，1个tick就是55ms。3.timeGetTime()函数12345DWORD Start = timeGetTime();//这里运行你的程序代码DWORD End = timeGetTime();//则(End-Start)就是你的程序运行时间, 以毫秒为单位//虽然返回的值单位应该是ms,但精度只有10ms。4.使用Boost库中的timertimer类可以测量时间的流逝，是小型计时器，提供毫秒级别的计时精度。头文件：#include&lt;boost/timer.hpp&gt;123timer t;//声明计时器对象并开始计时 //...测试代码cout&lt;&lt;\"运行时间：\"&lt;&lt;t.elapsed() &lt;&lt;\"s\"&lt;&lt;endl;//输出已流失的时间5.高精度时控函数QueryPerformanceFrequency()，QueryPerformanceCounter()QueryPerformanceCounter()这个函数返回高精确度性能计数器的值,它可以以微妙为单位计时.但是QueryPerformanceCounter()确切的精确计时的最小单位是与系统有关的,所以,必须要查询系统以得到QueryPerformanceCounter()返回的嘀哒声的频率.QueryPerformanceFrequency()提供了这个频率值,返回每秒嘀哒声的个数.计算确切的时间是从第一次调用QueryPerformanceCounter()开始的假设得到的LARGE_INTEGER为nStartCounter,过一段时间后再次调用该函数结束的,设得到nStopCounter.两者之差除以QueryPerformanceFrequency()的频率就是开始到结束之间的秒数.由于计时函数本身要耗费很少的时间,要减去一个很少的时间开销.但一般都把这个开销忽略。头文件：#include&lt;windows.h&gt;1234567891011double time=0; double counts=0; LARGE_INTEGER nFreq; LARGE_INTEGER nBeginTime; LARGE_INTEGER nEndTime; QueryPerformanceFrequency(&amp;nFreq); QueryPerformanceCounter(&amp;nBeginTime);//开始计时 //...测试代码QueryPerformanceCounter(&amp;nEndTime);//停止计时 time=(double)(nEndTime.QuadPart-nBeginTime.QuadPart)/(double)nFreq.QuadPart;//计算程序执行时间单位为s cout&lt;&lt;\"运行时间：\"&lt;&lt;time*1000&lt;&lt;\"ms\"&lt;&lt;endl;","categories":[{"name":"C++语法","slug":"C-语法","permalink":"https://anoyer.cn/categories/C-语法/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://anoyer.cn/tags/语法/"}]},{"title":"Henau-2018训练题1","slug":"henau-test1","date":"2018-12-22T10:48:03.000Z","updated":"2019-01-24T04:41:16.389Z","comments":true,"path":"article/henau-test1.html","link":"","permalink":"https://anoyer.cn/article/henau-test1.html","excerpt":"","text":"小刘爱复读12345678910111213141516#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 10;const int mod = 1e9 + 7;//把诗歌存入字符串char s[maxn] = \"I am the bone of my language repeater plastic is my body and wire is my blood I have created over a thousand copies Unknown to Death Nor known to Life Have withstood pain to create copies Yet,those hands will never hold anything So as I pray,unlimited repeat works\";int main()&#123; int len = strlen(s), cnt = 0; //cnt表示字母个数 for (int i = 0; i &lt; len; i++)&#123;//遍历一遍字符串 if ((s[i] &gt;= 'a'&amp;&amp;s[i] &lt;= 'z') || (s[i] &gt;= 'A'&amp;&amp;s[i] &lt;= 'Z'))cnt++; //如果当前字符是个字母，则cnt++; &#125; printf(\"%d\\n\", cnt); return 0;&#125;洋洋爱模仿12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 7;char s[maxn], t[maxn];int main()&#123; int T; scanf(\"%d\", &amp;T); while (T--)&#123; int ans = 0; //ans表示s,t串相同位相同字符个数 scanf(\"%s\", s); scanf(\"%s\", t); int len = strlen(s); //获取串长度 for (int i = 0; i &lt; len; i++) //for遍历字符串 if (s[i] == t[i])ans++; //如果发现一个s[i]和t[i]相同,ans++; printf(\"%.2f\\n\", (double)ans / (double)len); //ans/总字符数=相似度 &#125; return 0;&#125;小温爱蔬菜123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;const int mod = 1e9 + 7;int sum[maxn]; //前缀和int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n, a, m; scanf(\"%d%d\", &amp;n, &amp;m); sum[0] = 0; for (int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;sum[i]); sum[i] += sum[i - 1]; //获取a数组的前缀和表 &#125; while (m--)&#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); //前缀和性质：sum[r]-sum[l-1]=a[l]+....+a[r] printf(\"%d\\n\", sum[r] - sum[l - 1]); &#125; &#125; return 0;&#125;洋洋爱密码12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;const int mod = 1e9 + 7;int a[maxn];bool cmp(int a, int b)&#123; return a &gt; b;&#125;int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n, cnt = 0, ans = 0; //ans用来记录当前所花费金额 scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf(\"%d\", &amp;a[i]); &#125; sort(a, a + n, cmp); //先对物品价格从大到小排序 for (int i = 0; i &lt; n; i++)&#123; ans += a[i]; if (ans &gt;= 30)cnt++; //如果sum&gt;=30，则cnt++,输入密码次数cnt++ &#125; printf(\"%d\\n\", cnt); &#125; return 0;&#125;","categories":[{"name":"农大训练赛题解","slug":"农大训练赛题解","permalink":"https://anoyer.cn/categories/农大训练赛题解/"}],"tags":[{"name":"河南农业大学训练赛题解","slug":"河南农业大学训练赛题解","permalink":"https://anoyer.cn/tags/河南农业大学训练赛题解/"}]},{"title":"SPOJ - REPEATS - Repeats（RMQ+后缀数组）","slug":"SPOJ-REPEATS-Repeats","date":"2018-12-07T14:20:38.000Z","updated":"2019-01-24T04:42:33.502Z","comments":true,"path":"article/SPOJ-REPEATS-Repeats.html","link":"","permalink":"https://anoyer.cn/article/SPOJ-REPEATS-Repeats.html","excerpt":"","text":"博主链接题目链接题意：对于给出的字符串(长度&lt;= 50000,只包含字符’a’或’b’)找到最大的k使得存在某个字符串t重复k次是给出的字符串的子串题解：如果每一个循环节的长度为len, 那么在原字符串S中, S[ilen]与S[(i + 1)len]一定会被包含在答案的子串当中那么枚举可能的答案的循环节的长度, 然后枚举可能的位置, 对于每一组可能被包含的位置S[ilen], S[(i + 1)len]求出其对应后缀的最长公共前缀长度L, 则该循环节至少循环了L/len + 1次, 但是当L%len != 0时, 后面多余出来的部分(长度L%len的部分)可能和前面的拼凑成循环节, 于是对于位置ilen - (len - L % len)和(i + 1)len - (len - L % len)求其后缀的最长公共前缀长度, 如果大于之前的结果,自然就说明从这个位置开始可以比之前多一个循环节, 于是这样枚举得到最多循环次数代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;#define REP(i,n) for(i=0;i&lt;(n);++i)#define UPTO(i,l,h) for(i=(l);i&lt;=(h);++i)#define DOWN(i,h,l) for(i=(h);i&gt;=(l);--i)const int maxn=1e6+10;const int mod=1e9+7;typedef long long ll;template &lt;typename T, int LEN&gt;struct suffixarray&#123; //rank[i] 第i个后缀的排名; SA[i] 排名为i的后缀位置; Height[i] 排名为i的后缀与排名为(i-1)的后缀的LCP int str[LEN*3],sa[LEN*3]; int rank[LEN],height[LEN]; int id[LEN]; int best[LEN][20]; int len; bool equal(int *str, int a, int b)&#123; return str[a]==str[b]&amp;&amp;str[a+1]==str[b+1]&amp;&amp;str[a+2]==str[b+2]; &#125; bool cmp3(int *str, int *nstr, int a, int b)&#123; if(str[a]!=str[b])return str[a]&lt;str[b]; if(str[a+1]!=str[b+1])return str[a+1]&lt;str[b+1]; return nstr[a+b%3]&lt;nstr[b+b%3]; &#125; void radixsort(int *str, int *sa, int *res, int n, int m)&#123; int i; REP(i,m)id[i]=0; REP(i,n)++id[str[sa[i]]]; REP(i,m)id[i+1]+=id[i]; DOWN(i,n-1,0)res[--id[str[sa[i]]]]=sa[i]; &#125; void dc3(int *str, int *sa, int n, int m)&#123; #define F(x) ((x)/3+((x)%3==1?0:one)) #define G(x) ((x)&lt;one?(x)*3+1:((x)-one)*3+2) int *nstr=str+n, *nsa=sa+n, *tmpa=rank, *tmpb=height; int i,j,k,len=0,num=0,zero=0,one=(n+1)/3; REP(i,n)if(i%3)tmpa[len++]=i; str[n]=str[n+1]=0; radixsort(str+2, tmpa, tmpb, len, m); radixsort(str+1, tmpb, tmpa, len, m); radixsort(str+0, tmpa, tmpb, len, m); nstr[F(tmpb[0])]=num++; UPTO(i,1,len-1) nstr[F(tmpb[i])]=equal(str,tmpb[i-1],tmpb[i])?num-1:num++; if(num&lt;len)dc3(nstr,nsa,len,num); else REP(i,len)nsa[nstr[i]]=i; if(n%3==1)tmpa[zero++]=n-1; REP(i,len)if(nsa[i]&lt;one)tmpa[zero++]=nsa[i]*3; radixsort(str, tmpa, tmpb, zero, m); REP(i,len)tmpa[nsa[i]=G(nsa[i])]=i; i=j=0; REP(k,n) if(j&gt;=len||(i&lt;zero&amp;&amp;cmp3(str,tmpa,tmpb[i],nsa[j])))sa[k]=tmpb[i++]; else sa[k]=nsa[j++]; &#125; void initSA(T *s, int n,int m)&#123; int i,j,k=0; str[len=n]=0;//末尾增加一个0，这样就省去一些特殊情况的讨论，也就是最后一个mod 3刚好等于0 REP(i,n)str[i]=s[i]; dc3(str,sa,n+1,m); //可以切换成dc3 REP(i,n)sa[i]=sa[i+1];//第0小的默认为最后一个字符0，所以答案向前移动一位，da算法不用 //da(str,sa,n,m); REP(i,n)rank[sa[i]]=i; REP(i,n)//计算height数组 &#123; if(k)--k; if(rank[i])for(j=sa[rank[i]-1];str[i+k]==str[j+k];++k); else k=0; height[rank[i]]=k; &#125; &#125; void initRMQ()&#123; int i,j; int m=(int)(log(len*1.0)/log(2.0)); REP(i,len)best[i][0]=height[i]; for(j=1;j&lt;=m;++j) for(i=0;i+(1&lt;&lt;j)-1&lt;len;++i) best[i][j]=min(best[i][j-1],best[i+(1&lt;&lt;(j-1))][j-1]); &#125; int RMQ(int l, int r)&#123; int k=int(log(r-l+1.0)/log(2.0)); return min(best[l][k],best[r-(1&lt;&lt;k)+1][k]); &#125; int LCPSA(int a, int b)&#123;//查询区间RMQ(i,j) a=rank[a],b=rank[b]; if(a&gt;b)swap(a,b); return RMQ(a+1,b); &#125;&#125;;suffixarray&lt;int,maxn&gt; msa;map&lt;int ,int &gt; mymap; //计算m,m表示不同字符个数，如果是字母直接用256char s[maxn];int ss[maxn];int main()&#123; int t,Max=0,ans,k; scanf(\"%d\",&amp;t); while(t--)&#123; int len; Max=1; scanf(\"%d\",&amp;len); for(int i=0;i&lt;len;i++)&#123; scanf(\"%s\",s); ss[i]=s[0]-'a'+1; &#125; msa.initSA(ss,len,4); msa.initRMQ(); for(int i=1;i&lt;=len;i++)&#123; //枚举长度 for(int j=0;j+i&lt;len;j+=i)&#123; //+i极大的降低了复杂度 //但也产生了需要向前比较的问题 ans=msa.LCPSA(j,j+i); //公共后缀的长度 k=j-(i-ans%i); //前推到k位置 ans=ans/i+1; //出现次数 if(k&gt;=0&amp;&amp;msa.LCPSA(k,k+i)&gt;=i)ans++; //printf(\"L=%d,R=%d\\n\",i,ans); Max=max(Max,ans); &#125; &#125; printf(\"%d\\n\",Max); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://anoyer.cn/tags/后缀数组/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://anoyer.cn/tags/SPOJ/"}]},{"title":"后缀自动机DC3模板","slug":"Suffix-Array-DC3","date":"2018-12-06T15:11:27.000Z","updated":"2019-01-24T04:42:41.063Z","comments":true,"path":"article/Suffix-Array-DC3.html","link":"","permalink":"https://anoyer.cn/article/Suffix-Array-DC3.html","excerpt":"","text":"后缀数组一些性质suffix（j）和suffix（k）的最长公共前缀为height【rank【j】+1】到height【rank【k】】中的最小值；待更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/*POJ-2406*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;#define REP(i,n) for(i=0;i&lt;(n);++i)#define UPTO(i,l,h) for(i=(l);i&lt;=(h);++i)#define DOWN(i,h,l) for(i=(h);i&gt;=(l);--i)const int maxn=1e6+10;const int mod=1e9+7;typedef long long ll;template &lt;typename T, int LEN&gt;struct suffixarray&#123; //rank[i] 第i个后缀的排名; SA[i] 排名为i的后缀位置; Height[i] 排名为i的后缀与排名为(i-1)的后缀的LCP int str[LEN*3],sa[LEN*3]; int rank[LEN],height[LEN]; int id[LEN]; int best[LEN][20]; int len; bool equal(int *str, int a, int b)&#123; return str[a]==str[b]&amp;&amp;str[a+1]==str[b+1]&amp;&amp;str[a+2]==str[b+2]; &#125; bool cmp3(int *str, int *nstr, int a, int b)&#123; if(str[a]!=str[b])return str[a]&lt;str[b]; if(str[a+1]!=str[b+1])return str[a+1]&lt;str[b+1]; return nstr[a+b%3]&lt;nstr[b+b%3]; &#125; void radixsort(int *str, int *sa, int *res, int n, int m)&#123; int i; REP(i,m)id[i]=0; REP(i,n)++id[str[sa[i]]]; REP(i,m)id[i+1]+=id[i]; DOWN(i,n-1,0)res[--id[str[sa[i]]]]=sa[i]; &#125; void dc3(int *str, int *sa, int n, int m)&#123; #define F(x) ((x)/3+((x)%3==1?0:one)) #define G(x) ((x)&lt;one?(x)*3+1:((x)-one)*3+2) int *nstr=str+n, *nsa=sa+n, *tmpa=rank, *tmpb=height; int i,j,k,len=0,num=0,zero=0,one=(n+1)/3; REP(i,n)if(i%3)tmpa[len++]=i; str[n]=str[n+1]=0; radixsort(str+2, tmpa, tmpb, len, m); radixsort(str+1, tmpb, tmpa, len, m); radixsort(str+0, tmpa, tmpb, len, m); nstr[F(tmpb[0])]=num++; UPTO(i,1,len-1) nstr[F(tmpb[i])]=equal(str,tmpb[i-1],tmpb[i])?num-1:num++; if(num&lt;len)dc3(nstr,nsa,len,num); else REP(i,len)nsa[nstr[i]]=i; if(n%3==1)tmpa[zero++]=n-1; REP(i,len)if(nsa[i]&lt;one)tmpa[zero++]=nsa[i]*3; radixsort(str, tmpa, tmpb, zero, m); REP(i,len)tmpa[nsa[i]=G(nsa[i])]=i; i=j=0; REP(k,n) if(j&gt;=len||(i&lt;zero&amp;&amp;cmp3(str,tmpa,tmpb[i],nsa[j])))sa[k]=tmpb[i++]; else sa[k]=nsa[j++]; &#125; void initSA(T *s, int n,int m)&#123; int i,j,k=0; str[len=n]=0;//末尾增加一个0，这样就省去一些特殊情况的讨论，也就是最后一个mod 3刚好等于0 REP(i,n)str[i]=s[i]; dc3(str,sa,n+1,m); //可以切换成dc3 REP(i,n)sa[i]=sa[i+1];//第0小的默认为最后一个字符0，所以答案向前移动一位，da算法不用 //da(str,sa,n,m); REP(i,n)rank[sa[i]]=i; REP(i,n)//计算height数组 &#123; if(k)--k; if(rank[i])for(j=sa[rank[i]-1];str[i+k]==str[j+k];++k); else k=0; height[rank[i]]=k; &#125; &#125; void initRMQ()&#123; int i,j; int m=(int)(log(len*1.0)/log(2.0)); REP(i,len)best[i][0]=height[i]; for(j=1;j&lt;=m;++j) for(i=0;i+(1&lt;&lt;j)-1&lt;len;++i) best[i][j]=min(best[i][j-1],best[i+(1&lt;&lt;(j-1))][j-1]); &#125; int RMQ(int l, int r)&#123; int k=int(log(r-l+1.0)/log(2.0)); return min(best[l][k],best[r-(1&lt;&lt;k)+1][k]); &#125; int LCPSA(int a, int b)&#123;//查询区间RMQ(i,j) a=rank[a],b=rank[b]; if(a&gt;b)swap(a,b); return RMQ(a+1,b); &#125;&#125;;suffixarray&lt;char,maxn&gt; msa;map&lt;int ,int &gt; mymap; //计算m,m表示不同字符个数，如果是字母直接用256char s[maxn];int main()&#123; while(scanf(\"%s\",s))&#123; if(s[0]=='.')break; int len= strlen(s); msa.initSA(s,len,256); int flag = 0; for (int i = 1; i &lt;= len; i++) &#123; if (len % i == 0 &amp;&amp; msa.rank[0] == msa.rank[i] + 1 &amp;&amp; msa.height[msa.rank[0]] == len - i) &#123; printf(\"%d\\n\", len / i); flag = 1; break; &#125; &#125; if (!flag)printf(\"1\\n\"); &#125; return 0;&#125;一些模板利用求重复次数最多的连续重复子串例题：SPOJ - REPEATS-Repeats12345678910111213msa.initRMQ();for(int i=1;i&lt;=len;i++)&#123; //枚举长度 for(int j=0;j+i&lt;len;j+=i)&#123; //+i极大的降低了复杂度 //但也产生了需要向前比较的问题 ans=msa.LCPSA(j,j+i); //公共后缀的长度 k=j-(i-ans%i); //前推到k位置 ans=ans/i+1; //出现次数 if(k&gt;=0&amp;&amp;msa.LCPSA(k,k+i)&gt;=i)ans++; //printf(\"L=%d,R=%d\\n\",i,ans); Max=max(Max,ans); &#125;&#125;printf(\"%d\\n\",Max);求最小循环节例题：POJ-2406 - Power Strings123456789int flag = 0;for (int i = 1; i &lt;= len; i++) &#123; if (len % i == 0 &amp;&amp; msa.rank[0] == msa.rank[i] + 1 &amp;&amp; msa.height[msa.rank[0]] == len - i) &#123; printf(\"%d\\n\", len / i); flag = 1; break; &#125;&#125;if (!flag)printf(\"1\\n\");求两串中长度大于k的公共子串有多少个。例题：POJ - 3415 - Common Substrings1234567891011121314151617181920212223242526272829303132333435363738394041ll solve(int k)&#123; int top=0; ll ans=0,tot=0; for(int i=1;i&lt;n;i++)&#123; if(msa.height[i]&lt;k)tot=0,top=0; else&#123; int cnt=0; if(msa.sa[i-1]&lt;lena)&#123; //说明不在同一串中 cnt++; tot+=msa.height[i]-k+1; &#125; while(top&amp;&amp;msa.height[i]&lt;=sta[top-1][0])&#123; top--; tot+=(msa.height[i]-sta[top][0])*sta[top][1]; cnt+=sta[top][1]; &#125; sta[top][0]=msa.height[i],sta[top++][1]=cnt; if(msa.sa[i]&gt;lena)ans+=tot; &#125; &#125; tot=top=0; for(int i=1;i&lt;n;i++)&#123; if(msa.height[i]&lt;k)tot=0,top=0; else&#123; int cnt=0; if(msa.sa[i-1]&gt;lena)&#123; //说明不在同一串中 cnt++; tot+=msa.height[i]-k+1; &#125; while(top&amp;&amp;msa.height[i]&lt;=sta[top-1][0])&#123; top--; tot+=(msa.height[i]-sta[top][0])*sta[top][1]; cnt+=sta[top][1]; &#125; sta[top][0]=msa.height[i],sta[top++][1]=cnt; if(msa.sa[i]&lt;lena)ans+=tot; &#125; &#125; return ans;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"HDU-3336-Count the string（KMP-Next数组性质）","slug":"HDU-3336-Count-the-string（KMP-Next数组性质）","date":"2018-12-05T12:56:24.000Z","updated":"2019-01-24T04:40:39.234Z","comments":true,"path":"article/HDU-3336-Count-the-string（KMP-Next数组性质）.html","link":"","permalink":"https://anoyer.cn/article/HDU-3336-Count-the-string（KMP-Next数组性质）.html","excerpt":"","text":"博主链接题目链接题意：求一个串中所有前缀子串出现次数之和题解：对于每个串他前缀串出现次数和一定大于或等于n,因为有n个前缀；所以此时只需要去计算一下每一个前缀在后面出现了几次，也就是next数组的值。结合next数组的性质可以很容易得知，next数组中存在一个非0位，就出现了一种前缀，ans就++。所以只需对字符串求一遍next数组，统计都是个非零元素就可以了。代码：12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 2*1e6 + 10;const int mod = 1e9 + 7;typedef long long ll;char s[maxn];int nex[maxn];void Get_nex() &#123; int j = 0; for (int i = 1; s[i]; i++) &#123; while (s[i] != s[j + 1] &amp;&amp; j != 0)j = nex[j]; if (s[i] == s[j + 1] &amp;&amp; i != 1)j++; nex[i] = j; &#125;&#125;int main() &#123; int t,n; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d\", &amp;n); scanf(\"%s\", s+1); int ans = 0; Get_nex(); for (int i = 1; i &lt;=n; i++) &#123; if (nex[i] != 0)ans++; &#125; printf(\"%d\\n\", (n + ans) % 10007); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"POJ-2406-Power Strings(循环节)","slug":"POJ-2406-Power-Strings","date":"2018-12-05T12:54:16.000Z","updated":"2019-01-24T04:42:01.898Z","comments":true,"path":"article/POJ-2406-Power-Strings.html","link":"","permalink":"https://anoyer.cn/article/POJ-2406-Power-Strings.html","excerpt":"","text":"博主链接题目链接题意：给我们一个字符串，我们要求出它最多由几个相同的连续子串连接而成。也就是求最小循环节题解：先注意到如果他是循环子串那么n-next[n]一定是最小循环节。于是可以先求出nxt然后暴力匹配一遍看看。但是事实上只要满足n%(n-next[n])==0就可以保证答案正确了。代码：123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e6+10;char s[maxn];int Next[maxn];void Get_Nex()&#123; int j=-1; for(int i=0;s[i];i++)&#123; while(s[i]!=s[j+1]&amp;&amp;j!=-1)j=Next[j]; if(s[i]==s[j+1]&amp;i!=0)j++; Next[i]=j; &#125;&#125;int main()&#123; while(scanf(\"%s\",s))&#123; if(s[0]=='.')break; Get_Nex(); int ans=1; int len=strlen(s); int L=Next[len-1]; if(len%(len-L-1)==0)ans=len/(len-L-1); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"POJ - 3974 - Palindrome(裸马拉车)","slug":"POJ-3974-Palindrome-裸马拉车","date":"2018-12-05T12:51:13.000Z","updated":"2019-01-24T04:42:19.448Z","comments":true,"path":"article/POJ-3974-Palindrome-裸马拉车.html","link":"","permalink":"https://anoyer.cn/article/POJ-3974-Palindrome-裸马拉车.html","excerpt":"","text":"博主链接题目链接题意：给一个字符串，求连续最长的回文子串的长度。题解：利用Manacher算法，裸的模板题，不多说了。不懂Manacher算法—-见Manacher最长回文串算法代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define met(a) memset(a,0,sizeof(a));using namespace std;typedef long long ll;const int maxn = 1000050;char s[maxn];char s_new[maxn * 2];int p[maxn * 2];int Init()&#123; int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++)&#123; s_new[j++] = s[i]; s_new[j++] = '#'; &#125; s_new[j] = '\\0'; //printf(\"%s\\n\",s_new); return j; //返回s_new的长度 &#125;int Manacher()&#123; int len = Init(); //取得新字符串长度并完成向s_new的转换 int maxLen = -1; //最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++)&#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); //需搞清楚上面那张图含义, mx和2*id-i的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) //不需边界判断，因为左有'$',右有'\\0' p[i]++; //我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) &#123; id = i; mx = i + p[i]; &#125; maxLen = max(maxLen, p[i] - 1); // printf(\"%d %d %d\\n\",mx,id,maxLen); &#125; /*for(int i=1;i&lt;=len;i++)printf(\"%d \",p[i]); printf(\"\\n\");*/ return maxLen;&#125;int main()&#123; int t = 0; while (scanf(\"%s\", s))&#123; t++; memset(p, 0, sizeof(p)); if (s[0] == 'E'&amp;&amp;s[1] == 'N'&amp;&amp;s[2] == 'D')break; printf(\"Case %d: %d\\n\", t, Manacher()); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"Manacher","slug":"Manacher","permalink":"https://anoyer.cn/tags/Manacher/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"HDU-3746-Cyclic Nacklace （KMP求循环节）","slug":"HDU-3746-Cyclic-Nacklace-（KMP求循环节）","date":"2018-12-05T12:49:32.000Z","updated":"2019-01-24T04:40:47.319Z","comments":true,"path":"article/HDU-3746-Cyclic-Nacklace-（KMP求循环节）.html","link":"","permalink":"https://anoyer.cn/article/HDU-3746-Cyclic-Nacklace-（KMP求循环节）.html","excerpt":"","text":"博主链接题目链接Sample Input12345&gt;3&gt;aaa&gt;abca&gt;abcde&gt;Sample Output1234&gt; 0&gt; 2&gt; 5&gt;题意：给你一些串，问如果想让这个串里面的循环节至少循环两次，需要添加几个字符（只能在最前面或者最后面添加）。比如ababc 需要添加5个就是添加ababc。题解：利用Next数组的性质：符合 i % ( i - next[i] ) == 0 &amp;&amp; next[i] != 0 , 则**说明字符串循环，而且**循环节长度为: i - next[i]循环次数为: i / ( i - next[i] )代码：123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;const int N = 1e5+5;int n, next[N];char str[N];void getNext () &#123; n = strlen (str+1); int p = 0; for (int i = 2; i &lt;= n; i++) &#123; while (p &gt; 0 &amp;&amp; str[p+1] != str[i]) p = next[p]; if (str[p+1] == str[i]) p++; next[i] = p; &#125;&#125;int main () &#123; int cas; scanf(\"%d\", &amp;cas); while (cas--) &#123; scanf(\"%s\", str+1); getNext(); int n= strlen (str+1); if (next[n] == 0) printf(\"%d\\n\", n); else &#123; int k = n - next[n]; if (n%k == 0) printf(\"0\\n\"); else printf(\"%d\\n\", k - (n - (n/k) * k)); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"Codeforces Round #525 (Div. 2) -C. Ehab and a 2-operation task","slug":"Codeforces-Round-525-Div-2-C-Ehab-and-a-2-operation-task","date":"2018-12-04T16:25:42.000Z","updated":"2019-01-24T04:39:36.761Z","comments":true,"path":"article/Codeforces-Round-525-Div-2-C-Ehab-and-a-2-operation-task.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-525-Div-2-C-Ehab-and-a-2-operation-task.html","excerpt":"","text":"博主链接题目链接**Note** In the first sample, the array is already increasing so we don&apos;t need any operations. In the second sample: In the first step: the array becomes [8,6,3]. In the second step: the array becomes [0,2,3]. 题意：给你一个n，然后n个数a[1~n],现在你可以对数组进行两种操作：对a[1~i]所有的数+x对a[1~i]所有的数对x取模要求你在n+1次操作内将数组a变成一个递增序列，并输出每次的操作（答案不唯一）题解：答案说了可以n+1次，那么就先对每个位置都进行一次操作1，让所有数在着n次1操作结束后对n取模值等于下表i，因为每次操作影响范围为1~i，所以可以选择倒着扫，保证处理过的数不会再变化。最后进行一次操作2，对1~n进行对n取模123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e4+7;const int mod=1e9+7;int a[maxn];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; cout&lt;&lt;n+1&lt;&lt;endl; ll sum=0; int ans=0; for(int i=n;i&gt;=1;i--)&#123; ans=(i-(a[i]+sum)%(n+1)+n+1)%(n+1); printf(\"1 %d %d\\n\",i,ans); sum+=ans; &#125; printf(\"2 %d %d\\n\",n,n+1); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"思维题","slug":"思维题","permalink":"https://anoyer.cn/tags/思维题/"}]},{"title":"Codeforces Round #525 (Div. 2)-B. Ehab and subtraction","slug":"Codeforces-Round-525-Div-2-B-Ehab-and-subtraction","date":"2018-12-04T16:22:50.000Z","updated":"2019-01-24T04:39:35.110Z","comments":true,"path":"article/Codeforces-Round-525-Div-2-B-Ehab-and-subtraction.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-525-Div-2-B-Ehab-and-subtraction.html","excerpt":"","text":"博主链接题目链接NoteIn the first sample:In the first step: the array is [1,2,3][1,2,3], so the minimum non-zero element is 1.In the second step: the array is [0,1,2][0,1,2], so the minimum non-zero element is 1.In the third step: the array is [0,0,1][0,0,1], so the minimum non-zero element is 1.In the fourth and fifth step: the array is [0,0,0][0,0,0], so we printed 0.In the second sample:In the first step: the array is [10,3,5,3][10,3,5,3], so the minimum non-zero element is 3.In the second step: the array is [7,0,2,0][7,0,2,0], so the minimum non-zero element is 2.题意：给你两个整数n,k,然后n个整数a[1~n]。然后进行k次操作，每次操作打印出最小非零元素，并把所有非零元素减去这个数；如果没有没有非零数了就打印零题解：先用sort对a排序，然后从最小位置开始消，同时定义一个变量sum，记录每一次操作前面减去数字的和，也就是当前位置需要减的数字。同时特判下当前位置数-sum==0，如果为真直接跳过看下一位，同时因为跳过了所以一定要k++;代码：1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+7;const int mod=1e9+7;int a[maxn];int main()&#123; int n,k; scanf(\"%d%d\",&amp;n,&amp;k); for(int i=0;i&lt;n;i++)scanf(\"%d\",&amp;a[i]); sort(a,a+n); ll sum=0; for(int i=0;i&lt;k;i++)&#123; if(i&gt;=n)printf(\"0\\n\"); else&#123; if(a[i]-sum==0)&#123; k++; continue; &#125; printf(\"%d\\n\",a[i]-sum); sum=a[i]; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"思维题","slug":"思维题","permalink":"https://anoyer.cn/tags/思维题/"}]},{"title":"Codeforces Round #525 (Div. 2) (2)-A. Ehab and another construction problem","slug":"Codeforces-Round-525-Div-2-2-A-Ehab-and-another-construction-problem","date":"2018-12-04T16:19:49.000Z","updated":"2019-01-24T04:39:35.621Z","comments":true,"path":"article/Codeforces-Round-525-Div-2-2-A-Ehab-and-another-construction-problem.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-525-Div-2-2-A-Ehab-and-another-construction-problem.html","excerpt":"","text":"博主链接题目链接题意：给你一个x,让你求出两个整数a,b，满足他给的那些条件题解：数据范围很小就100，直接O(n*n)暴力枚举就可以了代码：1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+7;const int mod=1e9+7;int main()&#123; int x; scanf(\"%d\",&amp;x); for(int i=1;i&lt;=x;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; if(i%j==0&amp;&amp;j*i&gt;x)&#123; printf(\"%d %d\\n\",i,j); return 0; &#125; &#125; &#125; printf(\"-1\\n\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"暴力题","slug":"暴力题","permalink":"https://anoyer.cn/tags/暴力题/"}]},{"title":"HDU-2328-Corporate Identity(利用string函数)","slug":"HDU-2328-Corporate-Identity-利用string函数","date":"2018-12-04T13:27:43.000Z","updated":"2019-01-24T04:40:17.815Z","comments":true,"path":"article/HDU-2328-Corporate-Identity-利用string函数.html","link":"","permalink":"https://anoyer.cn/article/HDU-2328-Corporate-Identity-利用string函数.html","excerpt":"","text":"博主链接题目链接题意：给你n个字符串，问你这n个串的最长公共子串题解：题目和HDU-1238感觉差不多，暴力枚举任意一个字符串的所有子串，然后暴力匹配，这里用string解决的；代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=4050;const int mod=1e9+7;string s[maxn];int main()&#123; int n; ios::sync_with_stdio(0); while((cin&gt;&gt;n)&amp;&amp;n!=0)&#123; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s[i]; &#125; string t; int cot=0; int maxx=0; int len=s[1].size(); for(int i=0;i&lt;len;i++)&#123; for(int j=1;j&lt;=len-i;j++)&#123; //枚举子串长度 if(j&lt;maxx)continue; cot=0; for(int k=2;k&lt;=n;k++)&#123; if(s[k].find(s[1].substr(i,j))==string::npos)break; //string函数查找 else cot++; &#125; if(cot==n-1)&#123; //如果这个子串出现了n-1次，选取的那个串本身就有一次，则维护maxx if(maxx&lt;j)&#123; maxx=j; t=s[1].substr(i,j); &#125; else if(maxx==j)&#123; if(t&gt;s[1].substr(i,j))t=s[1].substr(i,j); &#125; &#125; &#125; &#125; if(maxx==0)cout&lt;&lt;\"IDENTITY LOST\"&lt;&lt;endl; else cout&lt;&lt;t&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"暴力题","slug":"暴力题","permalink":"https://anoyer.cn/tags/暴力题/"},{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"STL","slug":"STL","permalink":"https://anoyer.cn/tags/STL/"}]},{"title":"HDU-1238-Substrings(求公共子串)","slug":"HDU-1238-Substrings-求公共子串","date":"2018-12-04T13:26:00.000Z","updated":"2019-01-24T04:39:51.281Z","comments":true,"path":"article/HDU-1238-Substrings-求公共子串.html","link":"","permalink":"https://anoyer.cn/article/HDU-1238-Substrings-求公共子串.html","excerpt":"","text":"博主链接题目链接题意：找出所有字符串中共同拥有的一个子串，该子串（正、逆字符）是任何一个母串的子串，求该子串的最长长度。题解：利用string库里的find函数+STL中的reverse反转函数。先找出最短的母串，即该符合要求的子串肯定在这个母串中，即在从长到短，从最短母串中取子串，在子串正反去查看是否符合要求。代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int mod = 1e9 + 7;typedef long long ll;string s[120];int main() &#123; int t; scanf(\"%d\", &amp;t); while ( t--) &#123; int n,sub; scanf(\"%d\", &amp;n); int len = 1000; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i]; if (s[i].size() &lt; len)len = s[i].size(), sub = i; &#125; int maxn = 0; for (int i = s[sub].size(); i &gt; 0; i--) &#123; for (int j = 0; j &lt;= s[sub].size(); j++) &#123; string s1, s2; s1 = s[sub].substr(j, i); s2 = s1; reverse(s2.begin(), s2.end()); //反转 int k; for (k = 0; k &lt; n; k++) &#123; if (s[k].find(s1, 0) == -1 &amp;&amp; s[k].find(s2, 0) == -1)break; &#125; if (k == n &amp;&amp; maxn &lt; s1.size())maxn = s1.size(); &#125; &#125; printf(\"%d\\n\", maxn); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"暴力题","slug":"暴力题","permalink":"https://anoyer.cn/tags/暴力题/"},{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"STL","slug":"STL","permalink":"https://anoyer.cn/tags/STL/"}]},{"title":"HDU - 4847 - Wow! Such Doge!(暴力)","slug":"HDU-4847-Wow-Such-Doge-暴力","date":"2018-12-04T13:23:59.000Z","updated":"2019-01-24T04:41:06.354Z","comments":true,"path":"article/HDU-4847-Wow-Such-Doge-暴力.html","link":"","permalink":"https://anoyer.cn/article/HDU-4847-Wow-Such-Doge-暴力.html","excerpt":"","text":"博主链接题目链接题面太长了，就不上题目截图了QAQ题意：在给出的段落里面找出“doge”出现的次数，大小写都可以。（超级大水题，就考你输入恶心恶心人）题解：直接暴力求每一句话出现的doge次数（大小写不限），在一块就可以了输入格式处理—-把类似于“Wow! Such Dooooooooooooooge!!!“这种一行输入看出多个字符串输入，这里看成三个字符串，所以直接用%s存，存一个处理一个代码：1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+21;const int mod=1e9+7;char s[maxn];int ans=0;int main()&#123; while(scanf(\"%s\",s)!=EOF)&#123; int len=strlen(s); if(len&lt;3)continue; for(int i=0;i&lt;len-3;i++)&#123; if((s[i]=='d'||s[i]=='D')&amp;&amp;(s[i+1]=='o'||s[i+1]=='O')&amp;&amp;(s[i+2]=='g'||s[i+2]=='G')&amp;&amp;(s[i+3]=='e'||s[i+3]=='E'))&#123; ans++; i+=3; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"暴力题","slug":"暴力题","permalink":"https://anoyer.cn/tags/暴力题/"},{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"HDU - 4513 - 吉哥系列故事――完美队形II (马拉车加判断条件)","slug":"HDU-4513-吉哥系列故事――完美队形II-马拉车加判断条件","date":"2018-12-04T13:20:21.000Z","updated":"2019-01-24T04:40:57.023Z","comments":true,"path":"article/HDU-4513-吉哥系列故事――完美队形II-马拉车加判断条件.html","link":"","permalink":"https://anoyer.cn/article/HDU-4513-吉哥系列故事――完美队形II-马拉车加判断条件.html","excerpt":"","text":"博主链接题目链接题意：在一个长度为n的数组里面找回文串，要求回文串从中间向两边一次递减题解：在manacher过程中添加限制语句保证题目要求即可1234if(s_new[i+p[i]]!=-1111)&#123; //如果前面位置大于当前位置，则不符合跳出 if(s_new[i+p[i]]&lt;=s_new[i+p[i]-2])p[i]++; else break;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int s[100050];int s_new[100050*2];int p[100050*2];int Init(int len)&#123; s_new[0] = -111; s_new[1] = -1111; int j = 2; for (int i = 0; i &lt; len; i++)&#123; s_new[j++] = s[i]; s_new[j++] = -1111; &#125; s_new[j] = -11; //别忘了哦 return j; //返回s_new的长度&#125;int Manacher(int len)&#123; //取得新字符串长度并完成向s_new的转换 int maxLen = -1; //最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++)&#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); //需搞清楚上面那张图含义, mx和2*id-i的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) //不需边界判断，因为左有'$',右有'\\0' &#123; if(s_new[i+p[i]]!=-1111)&#123; //如果前面位置大于当前位置，则不符合跳出 if(s_new[i+p[i]]&lt;=s_new[i+p[i]-2])p[i]++; else break; &#125; p[i]++; &#125; //我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) &#123; id = i; mx = i + p[i]; &#125; maxLen = max(maxLen, p[i] - 1); &#125; return maxLen;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while (t--)&#123; int n; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)scanf(\"%d\",&amp;s[i]); int len=Init(n); printf(\"%d\\n\", Manacher(len)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"Manacher","slug":"Manacher","permalink":"https://anoyer.cn/tags/Manacher/"}]},{"title":"HDU - 4763 -Theme Section(迭代求公共前后缀跑KMP)","slug":"HDU-4763-Theme-Section-迭代求公共前后缀跑KMP","date":"2018-12-04T13:17:14.000Z","updated":"2019-01-24T04:41:02.139Z","comments":true,"path":"article/HDU-4763-Theme-Section-迭代求公共前后缀跑KMP.html","link":"","permalink":"https://anoyer.cn/article/HDU-4763-Theme-Section-迭代求公共前后缀跑KMP.html","excerpt":"","text":"博主链接题目链接题意：给一个字符串，求出字符串的最大的相同前缀后缀，并且满足前缀后缀在字符串中间出现了。题解：可以先对字符串跑KMP求一下Next数组，由next数组定义可以知道，里面存的是当前字符最长前缀和后缀，所以我们只需要从最后一个字符出发，递归寻找每个长度为的Next值的前缀后缀，对于长度为len的前缀，只需要用该前缀起和字符串的除了前缀和后缀的部分匹配就可以了，如果匹配成功，就看是否需要更新答案。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+21;const int mod=1e9+7;char s[maxn];int nex[maxn];int len;void GetNex()&#123; int j=-1; for(int i=0;s[i];i++)&#123; while(s[i]!=s[j+1]&amp;&amp;j!=-1)j=nex[j]; if(s[i]==s[j+1]&amp;&amp;i!=0)j++; nex[i]=j; &#125;&#125;bool kmp(int l)&#123; int j=-1; for(int i=l;i&lt;len-l;i++)&#123; while(j!=-1&amp;&amp;s[j+1]!=s[i])j=nex[j]; if(s[i]==s[j+1])j++; if(j+1==l)return true; &#125; return false;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%s\",s); len=strlen(s); if(len&lt;3)&#123; puts(\"0\"); continue; &#125; GetNex(); int ans=nex[len-1]; int mx=0; while(ans!=-1)&#123; if(kmp(ans+1))&#123; mx=max(mx,ans+1); //查找中间是否有这个串 &#125; ans=nex[ans]; &#125; printf(\"%d\\n\",mx); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"HDU - 3613 - Best Reward（马拉车加暴力）","slug":"HDU-3613-Best-Reward（马拉车加暴力）","date":"2018-12-04T13:14:11.000Z","updated":"2019-01-24T04:40:42.834Z","comments":true,"path":"article/HDU-3613-Best-Reward（马拉车加暴力）.html","link":"","permalink":"https://anoyer.cn/article/HDU-3613-Best-Reward（马拉车加暴力）.html","excerpt":"","text":"博主链接题目链接题意：字母表的26个字母都有一个价值，给你一个字符串，将该字符串切成两份，对于每一份，如果是回文串，就获得该子串的字母价值之和，否则该子串的价值为0。求出将字符串切成两份后能够获得的最大价值。题解：先用Manacher算法求出以每个字母为中心的回文串的长度，并计算该字符串的前缀价值和。然后枚举切割点，得到两份子串。这样就可以知道每个子串的中心点，然后检查以该子串的中心点作为中心点的回文串的长度，如果长度等于该子串的长度，那么就加上该子串的价值。然后和最优价值比较就行了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a));using namespace std;typedef long long ll;const int maxn = 500050;char s[maxn];char s_new[maxn * 2];int p[maxn * 2];int sum[maxn];int Init()&#123; int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++)&#123; s_new[j++] = s[i]; s_new[j++] = '#'; &#125; s_new[j] = '\\0'; //printf(\"%s\\n\",s_new); return j; //返回s_new的长度 &#125;void Manacher()&#123; int len = Init(); //取得新字符串长度并完成向s_new的转换 //int maxLen = -1; //最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++)&#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); //需搞清楚上面那张图含义, mx和2*id-i的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) //不需边界判断，因为左有'$',右有'\\0' p[i]++; //我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) &#123; id = i; mx = i + p[i]; &#125; //maxLen = max(maxLen, p[i] - 1); // printf(\"%d %d %d\\n\",mx,id,maxLen); &#125; /*for(int i=1;i&lt;=len;i++)printf(\"%d \",p[i]); printf(\"\\n\");*/ return ;&#125;int v[30];int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; memset(p, 0, sizeof(p)); for (int i = 0; i &lt; 26; i++)scanf(\"%d\", &amp;v[i]); scanf(\"%s\", s); sum[0] = v[s[0] - 'a']; for (int i = 1; s[i]; i++)&#123; sum[i] = sum[i - 1] + v[s[i] - 'a']; &#125; Manacher(); int Mx = 0; int len = strlen(s); for (int i = 0; i &lt; len - 1; i++)&#123; int tmp = 0; int num = p[i + 2] - 1; if (num == i + 1)tmp += sum[i]; num = p[i + len + 2] - 1; if (num == len - i - 1)tmp += sum[len - 1] - sum[i]; if (tmp&gt;Mx)Mx = tmp; &#125; printf(\"%d\\n\", Mx); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"暴力题","slug":"暴力题","permalink":"https://anoyer.cn/tags/暴力题/"},{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"Manacher","slug":"Manacher","permalink":"https://anoyer.cn/tags/Manacher/"}]},{"title":"HDU - 3294 - Girls research(裸马拉车)","slug":"HDU-3294-Girls-research-裸马拉车","date":"2018-12-03T14:13:55.000Z","updated":"2019-01-24T04:40:35.215Z","comments":true,"path":"article/HDU-3294-Girls-research-裸马拉车.html","link":"","permalink":"https://anoyer.cn/article/HDU-3294-Girls-research-裸马拉车.html","excerpt":"","text":"博主CSDN题目链接题意：通过第一个字符与a的关系翻译字符串，输出最长回文串和首尾下标，不存在则输出No solution!题解：用manachar求出最长回文串中心和半径，因为变换后的串各字符下标改变了，所以输出原首尾下标要公式倒推输出字符时要跳过插入的符号。如果你没有马拉车板子，或者说你不会马拉车，请见Manacher最长回文串算法代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define met(a) memset(a,0,sizeof(a));using namespace std;typedef long long ll;const int maxn = 200050;char s[maxn];char s_new[maxn * 2];int p[maxn * 2];int iid = 0;int Init()&#123; int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++)&#123; s_new[j++] = s[i]; s_new[j++] = '#'; &#125; s_new[j] = '\\0'; //printf(\"%s\\n\",s_new); return j; //返回s_new的长度 &#125;int Manacher()&#123; int len = Init(); //取得新字符串长度并完成向s_new的转换 int maxLen = -1; //最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++)&#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); //需搞清楚上面那张图含义, mx和2*id-i的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) //不需边界判断，因为左有'$',右有'\\0' p[i]++; //我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) &#123; id = i; mx = i + p[i]; &#125; if (p[i] - 1&gt;maxLen)&#123; maxLen = p[i] - 1; iid = i; &#125; // printf(\"%d %d %d\\n\",mx,id,maxLen); &#125; /*for(int i=1;i&lt;=len;i++)printf(\"%d \",p[i]); printf(\"\\n\");*/ return maxLen;&#125;int main()&#123; char ch ; while (scanf(\"%c%s\",&amp;ch,s)!=EOF)&#123; getchar(); //memset(p, 0, sizeof(p)); int k = ch - 'a'; for (int i = 0; s[i]; i++)&#123; s[i] -= k; if (s[i] &lt; 'a')s[i] += 'z' - 'a' + 1; &#125; int mx = Manacher(); if (mx == 1)printf(\"No solution!\\n\"); else&#123; printf(\"%d %d\\n\", (iid - mx + 1)/2-1 , (iid + mx - 1)/2-1 ); for (int i = (iid - mx + 1)/2-1; i &lt;= (iid + mx - 1)/2-1; i++)printf(\"%c\", s[i]); puts(\"\"); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"Manacher","slug":"Manacher","permalink":"https://anoyer.cn/tags/Manacher/"}]},{"title":"HDU - 3068 - 最长回文(裸马拉车)","slug":"HDU-3068-最长回文-裸马拉车","date":"2018-12-03T14:08:07.000Z","updated":"2019-01-24T04:40:31.255Z","comments":true,"path":"article/HDU-3068-最长回文-裸马拉车.html","link":"","permalink":"https://anoyer.cn/article/HDU-3068-最长回文-裸马拉车.html","excerpt":"","text":"博主CSDN题目链接题意：给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.回文就是正反读都是一样的字符串,如aba, abba等题解：裸的马拉车（Manacher）算法，直接上板子就够了。如果你没有马拉车板子，或者说你不会马拉车，请见Manacher最长回文串算法代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define met(a) memset(a,0,sizeof(a));using namespace std;typedef long long ll;const int maxn = 110050;char s[maxn];char s_new[maxn * 2];int p[maxn * 2];int Init()&#123; int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++)&#123; s_new[j++] = s[i]; s_new[j++] = '#'; &#125; s_new[j] = '\\0'; //printf(\"%s\\n\",s_new); return j; //返回s_new的长度 &#125;int Manacher()&#123; int len = Init(); //取得新字符串长度并完成向s_new的转换 int maxLen = -1; //最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++)&#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); //需搞清楚上面那张图含义, mx和2*id-i的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) //不需边界判断，因为左有'$',右有'\\0' p[i]++; //我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) &#123; id = i; mx = i + p[i]; &#125; maxLen = max(maxLen, p[i] - 1); // printf(\"%d %d %d\\n\",mx,id,maxLen); &#125; /*for(int i=1;i&lt;=len;i++)printf(\"%d \",p[i]); printf(\"\\n\");*/ return maxLen;&#125;int main()&#123; while (scanf(\"%s\", s)!=EOF)&#123; getchar(); getchar(); memset(p, 0, sizeof(p)); if (s[0] == 'E'&amp;&amp;s[1] == 'N'&amp;&amp;s[2] == 'D')break; printf(\"%d\\n\",Manacher()); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"Manacher","slug":"Manacher","permalink":"https://anoyer.cn/tags/Manacher/"}]},{"title":"HDU - 2609 - How many （最小表示法+set除重）","slug":"HDU-2609-How-many-（最小表示法-set除重）","date":"2018-12-03T14:02:12.000Z","updated":"2019-01-24T04:40:26.635Z","comments":true,"path":"article/HDU-2609-How-many-（最小表示法-set除重）.html","link":"","permalink":"https://anoyer.cn/article/HDU-2609-How-many-（最小表示法-set除重）.html","excerpt":"","text":"博主CSDN题目链接题意：有n个环形字符串，一个环形字符串移动会形成不能的字符串，我们把它们看作同一串字符串，求有多少个不同的字符串题解：用最小表示法把每个串的最小字典序找出来, ==(如果两个循环串相等则他们的最小字典序也一定相等)==,set带有除重功能，因为set具有除重功能所以用set来存每个串求出的最小字典序代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e4+20;const int mod=1e9+7;string s;int len;int GetMin()&#123; int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int t=s[(i+k)%len]-s[(j+k)%len]; if(t==0)k++; else&#123; if(t&gt;0)i=i+k+1; else j=j+k+1; if(i==j)j++; k=0; &#125; &#125; return min(i,j);&#125;int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF)&#123; set&lt;string&gt;sub; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s; len=s.size(); s+=s; int l=GetMin(); sub.insert(s.substr(l,len)); &#125; printf(\"%d\\n\",sub.size()); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"最大最小表示法","slug":"最大最小表示法","permalink":"https://anoyer.cn/tags/最大最小表示法/"}]},{"title":"HDU - 2087-减花布条(裸KMP模板)","slug":"HDU-2087-减花布条-裸KMP模板","date":"2018-12-03T13:59:03.000Z","updated":"2019-01-24T04:40:13.360Z","comments":true,"path":"article/HDU-2087-减花布条-裸KMP模板.html","link":"","permalink":"https://anoyer.cn/article/HDU-2087-减花布条-裸KMP模板.html","excerpt":"","text":"博主CSDN题目链接题意：中文题面，题意也说得非常清楚了，给一个文本串，求文本串中有多少个不重复的模式串题解：kmp标准做法，甚至基本没有变动。 判断的时候，每当完整的匹配一次之后令j=0，ans++，即模式串的下标从0开始，匹配数量加1代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;using namespace std;const int maxn=1000030;int next1[10030];char s[maxn];char p[10030];int cnt=0;void prefix_next()&#123; next1[0]=0; next1[1]=0; int j; for(int i=1;p[i]!='\\0';i++)&#123; j = next1[i]; while(j &amp;&amp; p[j] != p[i]) j = next1[j]; next1[i+1] = p[j] == p[i] ? j + 1: 0; &#125; return;&#125;void kmp()&#123; int j=0,m=strlen(p),n=strlen(s); for(int i=0;s[i]!='\\0';i++)&#123; while(j &amp;&amp; p[j] != s[i]) j = next1[j]; if(p[j] == s[i]) j ++; if(j == m) &#123; cnt++; if(i+m&lt;n) j=0; else return; &#125; &#125; return;&#125;int main()&#123;/* #ifdef LOCAL freopen(\"C:/Users/Administrator/Desktop/input.txt\",\"r\",stdin); #endif*/ while(~scanf(\"%s\",s),strcmp(s,\"#\"))&#123; cnt=0; cin&gt;&gt;p; prefix_next(); kmp(); cout&lt;&lt;cnt&lt;&lt;endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"HDU-1711-Number Sequence(数组跑KMP)","slug":"HDU-1711-Number-Sequence-数组跑KMP","date":"2018-12-03T13:55:24.000Z","updated":"2019-01-24T04:40:01.435Z","comments":true,"path":"article/HDU-1711-Number-Sequence-数组跑KMP.html","link":"","permalink":"https://anoyer.cn/article/HDU-1711-Number-Sequence-数组跑KMP.html","excerpt":"","text":"博主CSDN题目链接题意：给你两个数组的所有元素，让你对它们进行匹配，当位置为多少时候它们能完全匹配。题解：直接跑KMP就可以了，唯一注意的…..emmm….应该不用注意吧，也就原先是字符串，现在把字符串换成数组超级大水题代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt; using namespace std;int s[1000100],t[11000];int nex[1000100];//nex数组大小和短串一致int ans,n,m;inline void get_nex()&#123; int j=-1;//影响next[0] for (int i=0;i&lt;m;i++)&#123; while(t[i]!=t[j+1] &amp;&amp; j!=-1) j=nex[j]; if (t[i]==t[j+1] &amp;&amp; i!=0) j++; nex[i]=j; &#125;&#125;inline void kmp()&#123; int j=-1; for (int i=0;i&lt;n;i++)&#123; while(s[i]!=t[j+1] &amp;&amp; j!=-1) j=nex[j]; if (s[i]==t[j+1]) j++; if (j==m-1)&#123; ans++; printf(\"%d\\n\",i-j+1); break; &#125; &#125;&#125;int main()&#123; int tt; scanf(\"%d\",&amp;tt); while(tt--)&#123; ans=0; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;n;i++)scanf(\"%d\",&amp;s[i]); for(int i=0;i&lt;m;i++)scanf(\"%d\",&amp;t[i]); get_nex(); kmp(); if(ans==0)printf(\"-1\\n\"); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"HDU-1841-Find the Shortest Common Superstring（kmp）","slug":"HDU-1841-Find-the-Shortest-Common-Superstring（kmp）","date":"2018-12-03T13:52:21.000Z","updated":"2019-01-24T04:40:06.986Z","comments":true,"path":"article/HDU-1841-Find-the-Shortest-Common-Superstring（kmp）.html","link":"","permalink":"https://anoyer.cn/article/HDU-1841-Find-the-Shortest-Common-Superstring（kmp）.html","excerpt":"","text":"博主CSDN题目链接题意：给出两个串，用这两个串组成一个新串，使新串包含这两个串，问这个新串的长度最小是多少；题解：显然，对于两个串A，B；A如果是B的子串或者B如果是A的子串的话，直接输出那个母串的长度即可，如果没有这种关系，那么看一个串的后缀是否是另一个串的前缀，如果某个串的后缀与另一个串的前缀的公共部分最长，则答案=A.length+B.length-公共长度，所以可以直接用kmp去做。(kmp匹配最后j值为模式串前缀和主串后缀最长公共长度)代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std; const int N = 1000100;char a[3][2*N];int fail[2*N];inline int max(int a, int b)&#123; return (a &gt; b) ? a : b;&#125;int kmp(int &amp;i, int &amp;j, char* str, char* pat)&#123; int k; memset(fail, -1, sizeof(fail)); for (i = 1; pat[i]; ++i)&#123; for (k = fail[i - 1]; k &gt;= 0 &amp;&amp; pat[i] != pat[k + 1]; k = fail[k]); if (pat[k + 1] == pat[i])&#123; fail[i] = k + 1; &#125; &#125; i = j = 0; while (str[i] &amp;&amp; pat[j])&#123; if (pat[j] == str[i])&#123; i++; j++; &#125; else if (j == 0)&#123; i++; &#125; else&#123; j = fail[j - 1] + 1; &#125; &#125; //printf(\"%d %d\\n\",i,j); if (pat[j])&#123; return -1; &#125; else&#123; return i - j; &#125;&#125;int main(int argc, const char * argv[])&#123; int T; scanf(\"%d\", &amp;T); while (T--)&#123; int i, j, l1 = 0, l2 = 0; cin &gt;&gt; a[0] &gt;&gt; a[1]; int len1 = (int)strlen(a[0]), len2 = (int)strlen(a[1]), val; val = kmp(i, j, a[1], a[0]); if (val != -1)&#123; l1 = len1; &#125; else&#123; if (i == len2 &amp;&amp; j - 1 &gt;= 0 &amp;&amp; a[1][len2 - 1] == a[0][j - 1])&#123; l1 = j; &#125; &#125; val = kmp(i, j, a[0], a[1]); if (val != -1)&#123; l2 = len2; &#125; else&#123; if (i == len1 &amp;&amp; j - 1 &gt;= 0 &amp;&amp; a[0][len1 - 1] == a[1][j - 1])&#123; l2 = j; &#125; &#125; printf(\"%d\\n\", len1 + len2 - max(l1, l2)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"Python入门教程","slug":"Python入门教程","date":"2018-12-02T14:40:55.000Z","updated":"2019-01-24T04:42:25.074Z","comments":true,"path":"article/Python入门教程.html","link":"","permalink":"https://anoyer.cn/article/Python入门教程.html","excerpt":"","text":"基本语法1.注释———# 标注文本2.数字整数，不区分long和int进制0xa (16进制的10),0o10（8进制的10）,0b10（2进制的10）bool，2个值True，False浮点数1.2，3.1415.-0.12，1.46e9等价于1.46*10^9复数，1+2j3.字符串使用‘ “单双引号引用字符的序列‘ ’ ‘ ” “ ” 单双三引号，可以跨行，可以在其中自由的使用单双引号1234567print(''' welcome 'to' python''') #输出 welcome 'to' pythonprint(''' welcome 'to' 1\\ #输出 welcome 'to' 2\\ # 1233\\ # 'python''python' ''')在字符串前面加上r或者R前缀，表示该字符串不做特殊处理(比如字符串中含有\\)python为强类型语言，所以不允许’a‘+1字符串可以直接连接1print('abc'+'efg') #打印出abcefg4.转义序列\\\\ \\t \\r \\n \\‘ \\“前缀r,把里面的所有的字符当普通字符对待5.缩进未使用C等语言的花括号，而是采用缩进的方式表示层次关系约定使用4个空格缩进6.续行在行尾使用 \\如果使用各种括号，认为括号内的是一个整体，内部跨行不用 \\7.标识符一个名字，用来指代一个值只能字母，下划线和数字只能以字母或下划线开头不能是python的关键字，例如def，class就不能作为标识符python是大小写敏感的约定：不允许使用中文不允许使用歧义单词，例如class_在python中不要随便使用下划线开头的标识符8.常量一旦赋值就不能改变值的标识符python中无法定义常量9.字面常量一个单独的量，例如12，“abc”,’2341356514.03e-9’10.变量赋值后，可以改变值的标识符运算符Operator1.算数运算符+ - * / % ****表示次方12print(2**3) #输出 8print(4**0.5) #输出 2.0自然除/结果是浮点数，整除//。注：2.x中对于整数都是/和//都是整除2.位运算符&amp; | ~ ^ &lt;&lt; &gt;&gt;&amp; 按位与| 按位或~ 按反码补码取反（反出来会比真实相反数小一）原码5=&gt; 0b101, 1=&gt;0b1 ,-1=&gt; -0b1, bin(-1) #可以获取数字原码1bin(-1) #获得-0b1;反码正数将原码按位取反；负数符号位不变其余按位取反补码正数的补码是其本身；负数符合位不变其余按位取反后-1^ 按位异或&lt;&lt; 向左的位移1print(1&lt;&lt;2) #输出4>&gt; 向右的位移1print(4&gt;&gt;1) #输出 2常用方式：乘除2的倍数，32//4相当于32&gt;&gt;212,0xc,0o14,0b1100~12等于-133.比较运算符== != &gt; &lt; &gt;= &lt;=返回一个bool值1&lt;’1’ 1==’1’4.逻辑运算符与或非 and or not短路运算符and 如果第一个表达式位False，后面的就没有必要计算了，这个逻辑表达式一定Falseor 如果第一个表达式True，后面没有必要计算了，这个逻辑表达式一定是True5.赋值运算符a=min(3,5)+= -= == /= %=x=y=z=106.成员运算符in ,not in7.身份运算符is,not is8.运算优先级（由高到底）算数运算符 &gt; 位运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符表达式 Expression1.由数字，符号，括号，变量等的组合算数表达式逻辑表达式赋值表达式Python，赋值及定义，如果一个变量了已经定义，赋值相当于重新定义程序控制顺序按照先后顺序一条一条执行例如，先洗手，再吃饭，再洗碗分支根据不同的情况判断，条件满足执行某条件下的语句例如，先洗手，如果饭没做好，玩游戏，如果饭做好了，就吃饭，如果饭都没做，叫外卖循环条件满足就反复执行，不满足就不执行或者不再执行例如：先洗手，看饭好了没有，没有好，一会来看一次是否好了，一会儿来看一次，直到饭好了，才可以吃饭。这里循环的条件就是饭好了没，饭没好，就循环的来看饭好了没有。单分支结构1.if语句​ if 表达式：代码块(必须由4个空格，不允许使用缩进) ​ 表达式必须是一个bool类型，这个地方有一个隐式转换bool(表达式)12if 1&lt;2: print('1 less than 2')2.代码块类似于if语句的冒号后面的就是一个代码块if, for , def ,class 等真值表 bool(表达式)对应的隐式转换对象/常量值“”假“string”真0假&gt;=1真&lt;=-1真()空原组假[]空列表假{}空字典假None假多分支结构if…elif…else语句123456789if 表达式1: 代码块1elif 表达式2: 代码块2elif 表达式3: 代码块3……else: 代码块1234567891011 a=4 if a&lt;1: print('S') elif a&lt;3: print('AS') elif a&lt;4: print('B') else: print('sss')#输出：sss2.分支嵌套举例1234567891011score=80if score&lt;0: print(\"wrong\")else: if score==0: print('egg') elif score&lt;=100: print('right') else: print('too big')#输出：right循环——while语句语句123while 表达式: 代码块#当条件满足表达式为true，进入循环题，执行代码块举例123456789101112131415flag=10while flag: print(flag) flag-=1#输出：10987654321循环——for语句*语法123for element in iteratable: block#当可迭代对象中有对象可以迭代，进入循环体，执行代码块range函数举例：打印1~1012345678910111213for i in range(10): //从0开始迭代到9，每次i++; print(i+1)#输出:1234567891012345678#打印0~9的偶数for i in range(2,10,2): //从2开始迭代到9，每次i+=2; print(i)#输出：2468循环continue语句中断当前循环的当次执行，继续下一次循环举例：计算10以内的偶数（for循环）12345678910for i in range(10): if i%2: continue print(i)#输出02468循环break语句终止当前循环举例：计算1000以内的被7整除的前20个数（for循环）123456789101112131415161718192021222324252627count=0;for i in range(0,1000,7): print(i) count+=1 if(count&gt;=20): break#输出：0714212835424956637077849198105112119126133循环else子句语法12345678while condition: blockelse: blockfor element in iteratable: blockelse: block如果循环正常的执行结束，就执行else子句；如果使用break终止，else子句不会执行Python输入输出1.输入input()1234567num=intput('请输入一个数') #输入一个数回车结束print(num) #输入1234 输出1234#在有的版本python中存在一下问题num=input() #输入的是一个字符串print num #如果输入1234 打印的是一个字符串’1234‘num=int(input()) #输入的是一个整数print num #打印这个整数print1234print a #打印变量aprint(a) #打印aprint(a,b) #打印(a,b)print a,b #打印a,b未完待续","categories":[{"name":"Pyhton","slug":"Pyhton","permalink":"https://anoyer.cn/categories/Pyhton/"}],"tags":[{"name":"Python入门","slug":"Python入门","permalink":"https://anoyer.cn/tags/Python入门/"}]},{"title":"Material Plus主题安装和使用文档","slug":"Material-Plus主题安装和使用文档","date":"2018-12-02T07:56:14.000Z","updated":"2018-12-05T05:37:11.935Z","comments":true,"path":"article/Material-Plus主题安装和使用文档.html","link":"","permalink":"https://anoyer.cn/article/Material-Plus主题安装和使用文档.html","excerpt":"这是一篇加密文档，请输入密码去阅读。","text":"这是一篇加密文档，请输入密码去阅读。 Incorrect Password! No content to display! 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","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://anoyer.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://anoyer.cn/tags/Hexo/"},{"name":"Material Plus","slug":"Material-Plus","permalink":"https://anoyer.cn/tags/Material-Plus/"}]},{"title":"记一次Hexo博客更新","slug":"记一次Hexo博客更新","date":"2018-12-02T07:22:22.000Z","updated":"2019-01-24T04:47:00.138Z","comments":true,"path":"article/记一次Hexo博客更新.html","link":"","permalink":"https://anoyer.cn/article/记一次Hexo博客更新.html","excerpt":"","text":"这次更新成功将博客从Next主题换到了Material Plus…….前言：先上一个更新前及更新后预览图对比更新前：更新后：是不是灰常好看捏^_^开工：第一步：删库备份首先，把E盘Blog仓库复制一份到D盘（方便以后两主题来回切换），然后删库你没听错，直接把E盘Blog删了，然后init一个新Blog仓库。第二步：下载主题及覆盖下载主题后把Blog里的themes和source，scaffolds覆盖了第三步：进行主题配置：因为版权问题，详细步骤请看—Material Plus主题安装和使用文档（还是别看了，加密的，哈哈哈）完工：本蒟蒻不懂前端，以上代码大部分都是去 Inspect Element 然后复制粘贴再改一下的成果。。。还请各位大佬指正！好了，本文结束，下篇文章再见~ ✿✿ヽ(°▽°)ノ✿","categories":[{"name":"闲记","slug":"闲记","permalink":"https://anoyer.cn/categories/闲记/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://anoyer.cn/tags/Hexo/"}]},{"title":"POJ-3261-Milk Patterns(后缀数组)","slug":"POJ-3261-Milk-Patterns-后缀数组","date":"2018-11-30T00:35:06.000Z","updated":"2019-01-24T04:42:14.948Z","comments":true,"path":"article/POJ-3261-Milk-Patterns-后缀数组.html","link":"","permalink":"https://anoyer.cn/article/POJ-3261-Milk-Patterns-后缀数组.html","excerpt":"","text":"博主CSDN题目链接题意：给定一个字符串S，求至少出现k次的最长重复子串，这k个子串可以重叠。题解：后缀数组。先二分答案，然后将后缀分成若干组。这里要判断的是有没有一个组的后缀个数不小于k。如果有，那么存在k个相同的子串满足条件，否则不存在。。代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 /* 题意：找出出现k次的可重叠的最长子串的长度 这都是套路题了，二分长度L,按照height值分组，在同一组内的组数如果大于K,则成立。 */#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int MAXN = 100005;char ch[MAXN], All[MAXN];int SA[MAXN], rank[MAXN], Height[MAXN], tax[MAXN], tp[MAXN], a[MAXN], n, m;char str[MAXN];int k,cnt;//rank[i] 第i个后缀的排名; SA[i] 排名为i的后缀位置; Height[i] 排名为i的后缀与排名为(i-1)的后缀的LCP//tax[i] 计数排序辅助数组; tp[i] rank的辅助数组(计数排序中的第二关键字),与SA意义一样。//a为原串void RSort() &#123; //rank第一关键字,tp第二关键字。 for (int i = 0; i &lt;= m; i ++) tax[i] = 0; for (int i = 1; i &lt;= n; i ++) tax[rank[tp[i]]] ++; for (int i = 1; i &lt;= m; i ++) tax[i] += tax[i-1]; for (int i = n; i &gt;= 1; i --) SA[tax[rank[tp[i]]] --] = tp[i]; //确保满足第一关键字的同时，再满足第二关键字的要求&#125; //计数排序,把新的二元组排序。int cmp(int *f, int x, int y, int w) &#123; return f[x] == f[y] &amp;&amp; f[x + w] == f[y + w]; &#125;//通过二元组两个下标的比较，确定两个子串是否相同void Suffix() &#123; //SA for (int i = 1; i &lt;= n; i ++) rank[i] = a[i], tp[i] = i; m = 127 ,RSort(); //一开始是以单个字符为单位，所以(m = 127) for (int w = 1, p = 1, i; p &lt; n; w += w, m = p) &#123; //把子串长度翻倍,更新rank //w 当前一个子串的长度; m 当前离散后的排名种类数 //当前的tp(第二关键字)可直接由上一次的SA的得到 for (p = 0, i = n - w + 1; i &lt;= n; i ++) tp[++ p] = i; //长度越界,第二关键字为0 for (i = 1; i &lt;= n; i ++) if (SA[i] &gt; w) tp[++ p] = SA[i] - w; //更新SA值,并用tp暂时存下上一轮的rank(用于cmp比较) RSort(), swap(rank, tp), rank[SA[1]] = p = 1; //用已经完成的SA来更新与它互逆的rank,并离散rank for (i = 2; i &lt;= n; i ++) rank[SA[i]] = cmp(tp, SA[i], SA[i - 1], w) ? p : ++ p; &#125; //离散：把相等的字符串的rank设为相同。 //LCP int j, k = 0; for(int i = 1; i &lt;= n; Height[rank[i ++]] = k) for( k = k ? k - 1 : k, j = SA[rank[i] - 1]; a[i + k] == a[j + k]; ++ k); //这个知道原理后就比较好理解程序&#125;bool check(int mid)&#123; cnt=1; for(int i=1;i&lt;=n;i++)&#123; if(Height[i]&lt;mid)cnt=1; else cnt++; if(cnt&gt;=k)return 1; &#125; return 0;&#125;void Init() &#123; for (int i=1; i &lt;=n; i ++) scanf(\"%d\",&amp;a[i]);&#125;int main() &#123; #ifdef LOCAL freopen(\"C:/Users/Administrator/Desktop/input.txt\", \"r\", stdin); #endif scanf(\"%d%d\",&amp;n,&amp;k); Init(); Suffix(); //for(int i=1;i&lt;=n;i++)cout&lt;&lt;SA[i]&lt;&lt;endl; for(int i=1;i&lt;=n;i++)cout&lt;&lt;Height[i]&lt;&lt;\" \"; cout&lt;&lt;endl; int res=0; int l=1,r=n; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))&#123; l=mid+1; res=max(res,mid); &#125; else r=mid-1; &#125; printf(\"%d\\n\",res);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://anoyer.cn/tags/后缀数组/"}]},{"title":"HDU-4333-Revolving Digits(扩展KMP)","slug":"HDU-4333-Revolving-Digits-扩展KMP","date":"2018-11-30T00:34:52.000Z","updated":"2019-01-24T04:40:53.589Z","comments":true,"path":"article/HDU-4333-Revolving-Digits-扩展KMP.html","link":"","permalink":"https://anoyer.cn/article/HDU-4333-Revolving-Digits-扩展KMP.html","excerpt":"","text":"CSDN题目链接题意：给你一个字符串，你可以将该字符串的任意长度后缀截取下来然后接到最前面，让你统计所有新串中有多少种字典序小于、等于、大于原串。题解：首先我们将原串扩展成两倍，算一遍扩展KMP（自匹配），时间复杂度O(n)。这样一来，我们就得到了eKMP[i]，eKMP[i]代表s[i…len-1]与s的最长公共子串。为了避免重复子串重复计数，我们先求出s的最小循环节：然后我们只需统计最小循环节以内的字符就可。当eKMP[i]&gt;=len时，显然是原串，E++;否则我们只需比较一位就可判断大小，即：比较s[i+eKMP[i]]和s[eKMP[i]]的大小。为什么只需比较一位?因为s[0…eKMP[i]-1]和s[i…i+eKMP[i]-1]是相同的，只需判断第一个不相同的位置就可代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100010;//字符串长度最大值int next1[maxn*2],ex[maxn];//ex数组即为extend数组char s[maxn*2],s2[maxn];int n;//预处理计算next数组void getnext()&#123; int i=0,j,po,len=strlen(s); next1[0]=len;//初始化next[0] while(s[i]==s[i+1]&amp;&amp;s[i+1])//计算next[1] i++; next1[1]=i; po=1;//初始化po的位置 for(i=2;i&lt;len;i++)&#123; if(next1[i-po]+i&lt;=next1[po]+po-1)//第一种情况，可以直接得到next[i]的值 next1[i]=next1[i-po]; else //第二种情况，要继续匹配才能得到next[i]的值 &#123; j=next1[po]+po-i; if(j&lt;0)j=0;//如果i&gt;po+next[po],则要从头开始匹配 while(i+j&lt;len&amp;&amp;s[j]==s[j+i])//计算next[i] j++; next1[i]=j; po=i;//更新po的位置 &#125; &#125;&#125;void work()&#123; int ret1,ret2,ret3; ret1=ret2=ret3=0; //for(int i=0;i&lt;2*n;i++)printf(\"%d \",next1[i]); //cout&lt;&lt;endl; for(int i=0;i&lt;n;i++)&#123; if(i!=0&amp;&amp;next1[i]&gt;=n)break; if(next1[i]&lt;n)&#123; if(s[i+next1[i]]&lt;s[next1[i]])ret1++; else ret3++; &#125;else ret2++; &#125; printf(\"%d %d %d\\n\",ret1,ret2,ret3);&#125;int main()&#123; int t,cas=0; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%s\",s); n=strlen(s); printf(\"Case %d: \",++cas); for(int i=0;i&lt;n;i++)&#123; s[n+i]=s[i]; &#125;s[2*n]='\\0'; //printf(\"\\n%s\",s); getnext(); work(); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"扩展KMP","slug":"扩展KMP","permalink":"https://anoyer.cn/tags/扩展KMP/"}]},{"title":"Anoyer训练计划","slug":"Anoyer训练计划","date":"2018-11-30T00:34:41.000Z","updated":"2019-01-24T04:39:10.000Z","comments":true,"path":"article/Anoyer训练计划.html","link":"","permalink":"https://anoyer.cn/article/Anoyer训练计划.html","excerpt":"","text":"Anoyer JB训练规划前期：18年12月-19年2月低完成算法专题训练一阶段+一些专题散题：kuangbin-字符串所有专题kuangbin-数论所有专题各OJ专题散题+cf比赛该阶段必须掌握字符串和数论所有考点算法及其各种运用（这也是刷专题的意义所在），除去一些特难算法稀有神兽级别的算法（脑子不够，学意义也不大）中期：19年3月-省赛前完成计算几何 （重心） 和数据结构算法学习及专题训练++一些专题散题：kuangbin-计算几何所有专题kuangbin-数据结构所有专题各OJ专题散题+cf比赛该阶段结束时，必须掌握字符串,数论,计算机几何,数据结构所有考点算法及其各种运用（这也是刷专题的意义所在，粘贴复制上文的QAQ），除去一些特难算法稀有神兽级别的算法（脑子不够，学意义也不大）后期：省赛结束后-暑假前开始补cf以前的题，锻炼思维及出题速度 学习较为单一的一个阶段尽可能多的补cf以前的题，对于补的每一场比赛，尽可能的把这一场的题都补完，这样才是补题意义所在该阶段意义在于训练思维能力，能快速的对于一道题目给出解题思路，这也是我半年训练及两次现场赛的经验CF很重要，解题思维比算法更重要冲刺期：7月-8月准备参加多校训练或者时参加夏令营个人意向时参加夏令营，提升会很大也很快进行高压训练，每场比赛都可以看出本赛季的希望，且对知识巩固利用并实战同时利用空闲时间进行个人模板整理cf补题该阶段也是对知识点磨合对算法巩固脑子实战，也是队伍快速磨合阶段网络赛阶段：9月打6场网络赛，拿取名额。在冲刺期应该会有一场CCPC网络赛。目标打满该赛季的ICPC及一场CCPC（估计得经济倒退一阵子）网络赛cf补题好好打网络赛拿名额网络赛后备赛阶段，日常刷题训练cf补题专题复习平复赛前心态，以最好心态及状态参赛Anoyer训练规划讲完！！！","categories":[{"name":"闲记","slug":"闲记","permalink":"https://anoyer.cn/categories/闲记/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://anoyer.cn/tags/生活/"}]},{"title":"浮点型数据高精度乘法","slug":"浮点型数据高精度乘法","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:46:22.158Z","comments":true,"path":"article/浮点型数据高精度乘法.html","link":"","permalink":"https://anoyer.cn/article/浮点型数据高精度乘法.html","excerpt":"","text":"有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。Input第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 10^18)Output共T行，如果A获胜输出A，如果B获胜输出B。Input示例33 53 41 9Output示例BAA12345678910111213141516171819202122232425262728293031323334353637//注意：sqrt产生精度问题 double最多存小数点后14位，模拟乘法 #include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const int maxn = 1e4+5;//0.618033988749894848204586834... 拆成整数放进数组里，//拆成三部分即可 ll tmp[3] = &#123; 618033988,749894848,204586834 &#125;;ll MOD = 1e9;int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; ll a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); if (a &gt; b)&#123; ll t = a; a = b; b = t; &#125; ll diff = b - a; //把10^18分成两部分10^9 ll ta = diff / MOD; ll tb = diff % MOD; ll tp = tb * tmp[2]; tp = ta * tmp[2] + tb * tmp[1] + tp / MOD; tp = ta * tmp[1] + tb * tmp[0] + tp / MOD; tp = ta * tmp[0] + tp / MOD + diff; if (tp == a) printf(\"B\\n\"); else printf(\"A\\n\"); &#125; return 0;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"逆元模板","slug":"逆元模板","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:47:09.543Z","comments":true,"path":"article/逆元模板.html","link":"","permalink":"https://anoyer.cn/article/逆元模板.html","excerpt":"","text":"费马小定理求逆元12345678910111213141516171819202122ll quick_mod(ll a,ll b,ll c) //快速幂计算(a^b)%c&#123; ll ans = 1; while(b) &#123; if(b&amp;1) //相当于b%2==1 ans = (ans*a)%c; a = (a*a)%c; b&gt;&gt;=1; //相当于b/=2 &#125; return ans;&#125; ll inv(ll b,ll c) //计算b的逆元&#123; return quick_mod(b,c-2,c);&#125; ll div(ll a,ll b,ll c) //计算(a/b)%c&#123; return ((a%c)*(inv(b,c)%c))%c;&#125;扩展GCD求逆元12345678910111213void ex_gcd(ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y)&#123; if (!b) &#123;d = a, x = 1, y = 0;&#125; else&#123; ex_gcd(b, a % b, d, y, x); y -= x * (a / b); &#125;&#125; ll inv(ll a, ll p)&#123;//如果不存在，返回-1 a,p互质 ll d, x, y; ex_gcd(a, p, d, x, y); return d == 1 ? (x % p + p) % p : -1;&#125;递归求逆元当p是个质数的时候有inv(a) = (p - p / a) * inv(p % a) % p,且1的逆元就是112345 ll inv(ll t, ll p) &#123; //求t关于p的逆元，注意:t要小于p，最好传参前先把t%p一下 ,即inv(a%p, p)求a对p的逆元 return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p;&#125;打表求逆元1234567ll inv[maxn];void Prepare_inv(ll n,ll M)&#123; inv[1]=1; for(ll i=2;i&lt;=n;i++)&#123; inv[i]=(ll)(M-M/i)*inv[M%i]%M; &#125;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"莫比乌斯函数打表模板","slug":"莫比乌斯表","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:46:49.954Z","comments":true,"path":"article/莫比乌斯表.html","link":"","permalink":"https://anoyer.cn/article/莫比乌斯表.html","excerpt":"","text":"莫比乌斯打表（phi可以删除）phi–欧拉函数表 miu–莫比乌斯函数表 fac–i最大的素因子辅助打phi表123456789101112131415int phi[maxn],miu[maxn],fac[maxn];ll f[maxn], F[maxn];void init()&#123; for (int i = 1; i &lt; maxn; ++i) fac[i] = i; phi[1] = miu[1] = 1; for (int i = 2; i &lt; maxn; ++i) &#123; if (fac[i] == i) for (int j = i &lt;&lt; 1; j &lt; maxn; j += i) fac[j] = i; if (i / fac[i] % fac[i]) phi[i] = (fac[i] - 1)*phi[i / fac[i]], miu[i] = -miu[i / fac[i]]; //如果b质数 a%b！=0 phi(a*b) = phi(a)*b - phi(a) else phi[i] = fac[i] * phi[i / fac[i]], miu[i] = 0; //当b是质数，a%b==0，phi(a*b)=phi(a)*b &#125;&#125;求一个数的欧拉函数值–复杂度n^1/2123456789101112131415161718int miu(ll n)&#123; int prime = 1; int flag = 0; for (int i = 2; i*i &lt;= n; i++) &#123; if (n%i == 0) &#123; prime++; n /= i; if (n%i == 0) &#123; flag = 1; break; &#125; &#125; &#125; if (flag) return 0; if (prime % 2)return -1; else return 1;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"线段树模板","slug":"组合数","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:46:44.778Z","comments":true,"path":"article/组合数.html","link":"","permalink":"https://anoyer.cn/article/组合数.html","excerpt":"","text":"123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std; int C[1005][1005];int main()&#123; C[0][0] = 1; for (int i = 1; i &lt;= 1000; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= 1000; j++) C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; cout &lt;&lt; C[4][3] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"素数筛+埃筛模板","slug":"素数筛","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:46:33.438Z","comments":true,"path":"article/素数筛.html","link":"","permalink":"https://anoyer.cn/article/素数筛.html","excerpt":"","text":"普通的素数筛1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int MAX=1e7+7;//求MAX范围内的素数long long su[MAX],cnt;bool isprime[MAX];void prime()&#123; cnt=1; memset(isprime,1,sizeof(isprime));//初始化认为所有数都为素数 isprime[0]=isprime[1]=0;//0和1不是素数 for(long long i=2;i&lt;=MAX;i++) &#123; if(isprime[i]) su[cnt++]=i;//保存素数i for(long long j=1;j&lt;cnt&amp;&amp;su[j]*i&lt;MAX;j++) &#123; isprime[su[j]*i]=0;//筛掉小于等于i的素数和i的积构成的合数 &#125; &#125;&#125;int main()&#123; prime(); //for(long long i=1;i&lt;cnt;i++) // printf(\"%d \",su[i]); return 0;&#125;埃筛（线性筛）筛素数123456789101112131415int p[maxn], check[maxn], tot = 0;void prime()&#123; check[1]=1; check[0]=1; for(int i=2;i&lt;=n;i++) &#123; if(!check[i])p[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;=n;j++) &#123; check[i*p[j]]=1; if(!(i%p[j]))break;//*****关键 &#125; &#125;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"Miller-Rabin素性测试模板","slug":"Miller-Rabin素性测试","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:41:57.188Z","comments":true,"path":"article/Miller-Rabin素性测试.html","link":"","permalink":"https://anoyer.cn/article/Miller-Rabin素性测试.html","excerpt":"","text":"/** 随机素数测试（伪素数原理理）* CALL: bool res = miller(n);* 快速测试n是否满⾜足素数的“必要”条件，出错概率极低* 对于任意奇数n &gt; 2和正整数s，算法出错概率≤2^(-s)*/123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define ll long long int#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 2*1e5 + 5;long long quicks(long long a, long long b, long long c)&#123; long long ans = 1; a = a % c; while (b != 0)&#123; if (b &amp; 1) ans = (ans*a) % c; b &gt;&gt;= 1; a = (a*a) % c; &#125; return ans;&#125;bool Miller_Rabin_1(long long n) &#123; //标准代码 long long t = 0; long long b = n - 1; while ((b &amp; 1) == 0)&#123; t++; b &gt;&gt;= 1; &#125; //现在的a^(b*2^t)=1(mod n) long long a = rand() % (n - 1) + 1; //测试 long long x = quicks(a, b, n); //个人认为这里如果加上优先判定是不是1，n-1的话，会更快一点？是不是呢？？？？？ for (long long i = 1; i &lt;= t; i++)&#123; long long y = quicks(x, 2, n); if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return false; //这里的意思是如果a^(d*2^r)是1，但是a^(d*2^(r-1))不是1也不是n-1的情况，这时候我们认为是合数 x = y; &#125; if (x != 1) return false; else return true;&#125;int main() &#123; ll n; cin &gt;&gt; n; if (Miller_Rabin_1(n))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"矩阵快速幂模板","slug":"矩阵快速幂","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:46:29.403Z","comments":true,"path":"article/矩阵快速幂.html","link":"","permalink":"https://anoyer.cn/article/矩阵快速幂.html","excerpt":"","text":"快速幂函数123456789101112ll quick_mod(ll a,ll b,ll c) //快速幂计算(a^b)%c&#123; ll ans = 1; while(b) &#123; if(b&amp;1) //相当于b%2==1 ans = (ans*a)%c; a = (a*a)%c; b&gt;&gt;=1; //相当于b/=2 &#125; return ans;&#125;矩阵快速幂模版12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt; using namespace std;int N=7;void Matrix(int (&amp;a)[2][2],int b[2][2])&#123; int tmp[2][2]=&#123;0&#125;; for(int i=0;i&lt;2;++i) for(int j=0;j&lt;2;++j) for(int k=0;k&lt;2;++k) tmp[i][j]=(tmp[i][j]+a[i][k]*b[k][j])%N; for(int i=0;i&lt;2;++i)&#123; for(int j=0;j&lt;2;++j)&#123; a[i][j]=tmp[i][j]; &#125; &#125;&#125;int main()&#123; int a,b,n; while(scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;n))&#123; if(a==0&amp;&amp;b==0&amp;&amp;n==0)break; if(n==1)&#123; cout&lt;&lt;1&lt;&lt;endl; continue; &#125; int temp[2][2]=&#123;a,b,0,0&#125;,cot[2][2]=&#123;1,0,0,1&#125;, x[2] = &#123;1, 1&#125;; n-=2; while(n)&#123; if(n&amp;1)Matrix(cot,temp); Matrix(temp,temp); n/=2; &#125; int ans=0; for(int i=0;i&lt;2;i++) ans=(ans+x[i]*cot[0][i])%N; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"BM杜教","slug":"BM杜教","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:38:32.292Z","comments":true,"path":"article/BM杜教.html","link":"","permalink":"https://anoyer.cn/article/BM杜教.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;// headint _,n;namespace linear_seq &#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;int&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+...// printf(\"%d\\n\",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n) &#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main() &#123; while (~scanf(\"%d\",&amp;n)) &#123; vector&lt;int&gt;v; v.push_back(2);//前几项 v.push_back(4); v.push_back(6); v.push_back(8); v.push_back(10); v.push_back(12); //输入n ,输出第n项的值 printf(\"%d\\n\",linear_seq::gao(v,n-1)); &#125;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"欧拉函数模板","slug":"欧拉函数","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:43:56.211Z","comments":true,"path":"article/欧拉函数.html","link":"","permalink":"https://anoyer.cn/article/欧拉函数.html","excerpt":"","text":"求一个数的欧拉函数123456789101112ll phi(ll x)&#123; //求1~n与n互质的个数 // phi(1323)=phi(3^3*7^2)=1323*(1-1/3)*(1-1/7) ll i, ans = x; for (i = 2; i*i &lt;= x; i++)&#123; if (x%i == 0) ans = ans - ans / i; while(x%i == 0) x /= i; &#125; if (x &gt; 1) ans = ans - ans / x; return ans;&#125;递推求欧拉函数12345678910111213141516171819ll _phi(ll x) &#123; //递推求欧拉函数 利用了欧拉函数的积性 //如果b质数 a%b！=0 phi(a*b) = phi(a)*b - phi(a)//当b是质数，a%b==0，phi(a*b)=phi(a)*b if (x == 0) return 0; ll res = 1, t = x; for (ll i = 2; i &lt;= (ll)sqrt(1.*x); i++) &#123; if (t%i == 0) &#123; res *= (i - 1); t /= i; while (t%i == 0) &#123; res *= i; t /= i; &#125; &#125; if (t == 1) break; &#125; if (t &gt; 1) &#123; res *= (t - 1); &#125; return res;&#125;递推欧拉函数打表12345678910111213141516171819202122ll phi[maxn]; void init()&#123; for(int i=1;i&lt;=maxn;i++) phi[i] = i; for (int i = 2; i*i &lt; maxn; i++)&#123; //最大素因子表 if (phi[i] == i)&#123; for (int j = i * i; j &lt; maxn; j += i)&#123; phi[j] = i; &#125; &#125; &#125; phi[1] = 1; for (int i = 2; i &lt; maxn; i++)&#123; if ((i / phi[i]) % phi[i] == 0)&#123; phi[i] = phi[i / phi[i]] * phi[i]; //当b是质数，a%b==0，phi(a*b)=phi(a)*b &#125; else &#123; phi[i] = phi[i / phi[i]] * (phi[i] - 1); //如果b质数 a%b！=0 phi(a*b) = phi(a)*b - phi(a) &#125; &#125;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"杜教筛模板","slug":"杜教筛","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:43:50.512Z","comments":true,"path":"article/杜教筛.html","link":"","permalink":"https://anoyer.cn/article/杜教筛.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define ll long long int;#define N 2001000#define ni 500000004 //2的逆元using namespace std;const long long int mod=0x3f3f3f3f3f3f3f;inline void read(long long &amp;x) //输入外挂 &#123; x=0; static int p;p=1; static char c;c=getchar(); while(!isdigit(c))&#123;if(c=='-')p=-1;c=getchar();&#125; while(isdigit(c)) &#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c-48);c=getchar();&#125; x*=p;&#125;bool vis[N];int mu[N],sum1[N];long long phi[N],sum2[N];int cnt,prim[N];int e,e1;map&lt;long long ,int&gt;w,w1; //哈希 w用来求phi前缀和 w1用来求miu前缀和 void get(int maxn)&#123; phi[1]=mu[1]=1; for(int i=2;i&lt;=maxn;i++) &#123; if(!vis[i]) &#123; prim[++cnt]=i; mu[i]=-1;phi[i]=i-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=maxn;j++) &#123; vis[i*prim[j]]=1; if(i%prim[j]==0) &#123; phi[i*prim[j]]=phi[i]*prim[j]; break; &#125; else mu[i*prim[j]]=-mu[i],phi[i*prim[j]]=phi[i]*(prim[j]-1); &#125; &#125; for(int i=1;i&lt;=maxn;i++)sum1[i]=sum1[i-1]+mu[i],sum2[i]=(sum2[i-1]+phi[i])%mod; //打一个maxn的phi前缀和表 和miu前缀和表 &#125;int djsmu(long long x) // 求miu前缀和 &#123; if(x&lt;=2000000)return sum1[x]; if(w.count(x))return w[x]; int ans=1; for(long long l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); ans-=(r-l+1ll)*djsmu(x/l); &#125; return w[x]=ans;&#125;long long djsphi(long long x) //求phi 前缀和 &#123; if(x&lt;=2000000)return sum2[x]; if(w1.count(x))return w1[x]; long long ans=(x %mod* ((x + 1) % mod)) % mod*ni%mod; for(long long l=2,r;l&lt;=x;l=r+1) &#123; r=x/(x/l); //最后一个分块中的数 ans = (ans - ((r - l + 1) % mod*djsphi(x / l)) % mod + mod) % mod; &#125; return w1[x]=ans;&#125;int main()&#123; long long t; read(t); get(2000000); while(t--)&#123; static long long n; read(n); printf(\"%lld %d\\n\",djsphi(n),djsmu(n)); &#125; return 0;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"整除分块模板","slug":"整除分块模板","date":"2018-11-27T05:55:49.000Z","updated":"2018-12-02T06:36:32.531Z","comments":true,"path":"article/整除分块模板.html","link":"","permalink":"https://anoyer.cn/article/整除分块模板.html","excerpt":"","text":"1234for(int i=1,last;i&lt;=n;i=last+1)&#123; last=n/(n/i); //该区间的最后一个数 ans+=(last-i+1)*(n/i);&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"最长循环节模板","slug":"最长循环节","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:43:46.371Z","comments":true,"path":"article/最长循环节.html","link":"","permalink":"https://anoyer.cn/article/最长循环节.html","excerpt":"","text":"正整数k的倒数1/k，写为10进制的小数如果为无限循环小数，则存在一个循环节，求&lt;=n的数中，倒数循环节长度最长的那个数，假如存在多个最优的答案，输出所有答案中最大的那个数。如果1&lt;=b&lt;a,a没有2或5的质因子，并且a与b互质，那么b/a 的循环节位数恰好等于e 满足min(10^e≡1(moda))),e是正整数。如果1&lt;=b&lt;a,a没有2或5的质因子，并且a与b互质，那么b/a 的循环节位数必整除ϕ(a)。123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define ll long long int#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)using namespace std;const int maxn = 1e6 + 7;int main(int argc, char *argv[]) &#123; int n,ans=1,maxx=0; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; int tmp = i, tmp1 = 1, tmp2 = 0; while (tmp % 2 == 0)tmp /= 2; while (tmp % 5 == 0)tmp /= 5; if (tmp == 1)tmp2 = 0; else &#123; do &#123; tmp1 = tmp1 * 10 % tmp; ++tmp2; &#125; while (tmp1 != 1); &#125; if (tmp2 &gt; maxx) &#123; maxx = tmp2; ans = i; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"欧几里得及拓展欧几里得模板","slug":"拓展欧几里得及欧几里得","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:43:34.296Z","comments":true,"path":"article/拓展欧几里得及欧几里得.html","link":"","permalink":"https://anoyer.cn/article/拓展欧几里得及欧几里得.html","excerpt":"","text":"欧几里得12345int gcd(int a,int b)&#123; return (b==0)?a:gcd(b,a%b); //一条语句搞定（三元运算符）装逼，跟上面略有不同，上面做到t=0,这里做到b=0 &#125;拓展欧几里得1234567891011121314151617181920212223int gcd(int a,int b)&#123; return (b==0)?a:gcd(b,a%b); //一条语句搞定（三元运算符）装逼，跟上面略有不同，上面做到t=0,这里做到b=0 &#125; ll lcm(ll a, ll b) &#123; return a / gcd(a,b) * b;&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1; y=0; return a; &#125; int r=exgcd(b,a%b,x,y); int t=x; x=y; y=t-a/b*y; return r;&#125;拓展欧几里得求整数解个数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ll gcd(ll a, ll b) &#123; return b ? gcd(b, a%b) : a;&#125; ll lcm(ll a, ll b) &#123; return a / gcd(a, b) * b;&#125; ll extend_gcd(ll a, ll b, ll&amp;x, ll&amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; ll xt = 0, yt = 0; ll d = extend_gcd(b, a % b, xt, yt); x = yt; y = xt - yt * (a / b); return d;&#125; ll cal(ll a, ll b, ll n) &#123; //计算ax+by == n的非负整数解组数 ll x = 0, y = 0, d; d = extend_gcd(a, b, x, y); if (n % d != 0) &#123; return 0; &#125; x *= n / d, y *= n / d; ll LCM = lcm(a, b); ll t1 = LCM / a, t2 = LCM / b; if (x &lt; 1) &#123; ll num = (1 - x) / t1; x += num * t1; y -= num * t2; if (x &lt; 1) &#123; y -= t2; x += t1; &#125; &#125; if (y &lt; 1) &#123; ll num = (1 - y) / t2; y += num * t2; x -= num * t1; if (y &lt; 1) &#123; y += t2; x -= t1; &#125; &#125; ll ans = x &gt; 0 &amp;&amp; y &gt; 0; if (ans) &#123; ans += min((x - 1) / t1, ((n - 1) / b - y) / t2); ans += min((y - 1) / t2, ((n - 1) / a - x) / t1); &#125; return ans;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"基数排序MSD模板","slug":"基数排序MSD","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:43:09.682Z","comments":true,"path":"article/基数排序MSD.html","link":"","permalink":"https://anoyer.cn/article/基数排序MSD.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;malloc.h&gt;using namespace std;const int maxn=1e6+7;int arr[maxn]=&#123;12,14,54,5,6,3,9,8,47,89&#125;;int getdigit(int x,int d)&#123; int a[]=&#123;1,1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9&#125;; ////因为待排数据最大数据位数 return ((x/a[d])%10);&#125;void msdradix_sort(int begin,int end,int d)&#123; const int radix=10; //进制数 int count[radix],i,j; //count表示每个桶中元素个数 //置零 for(i=0;i&lt;10;++i)count[i]=0; //给桶分配空间 int *bucket=(int *)malloc((end-begin+1)*sizeof(int)); //统计各桶需要装的元素的个数 for(i=begin;i&lt;=end;++i)&#123; count[getdigit(arr[i], d)]++; &#125; //求出桶的边界索引，count[i]值为第i个桶的右边界索引+1 for(i=1;i&lt;radix;++i)&#123; count[i]+=count[i-1]; //每个桶的边界，便于下步将arr重新放入bucket里 &#125; //这里要从右向左扫描，保证排序稳定性 for(i=end;i&gt;=begin;--i)&#123; j=getdigit(arr[i],d); //求出关键码的第d位的数字， 例如：576的第3位是5 bucket[count[j]-1]=arr[i]; //放入对应的桶中，count[j]-1是第j个桶的右边界索引 --count[j]; //第j个桶放下一个元素的位置(右边界索引+1) &#125; //注意：此时count[i]为第i个桶左边界 //从各个桶中收集数据 for(i = begin, j = 0;i &lt;= end; ++i, ++j)&#123; arr[i] = bucket[j]; &#125; //释放存储空间 free(bucket); //对每个桶再次排序 for(i=0;i&lt;radix;i++)&#123; int p1=begin+count[i]; //第I个桶的左边界 int p2=begin+count[i+1]-1 ; //第i个桶的右边界 if(p1&lt;p2&amp;&amp;d&gt;1)&#123; msdradix_sort(p1, p2, d-1); //对第i个桶递归调用，进行基数排序，数位降 1 &#125; &#125;&#125;int main()&#123; int len=10; for(int i=0;i&lt;10;i++)cout&lt;&lt;arr[i]&lt;&lt;\" \"; cout&lt;&lt;endl; msdradix_sort(0,10-1,2); //2表示最高位数 for(int i=0;i&lt;10;i++)cout&lt;&lt;arr[i]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"博弈论模板","slug":"博弈论","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:42:56.063Z","comments":true,"path":"article/博弈论.html","link":"","permalink":"https://anoyer.cn/article/博弈论.html","excerpt":"","text":"Bash–两人从一堆a个石子里面轮流取石子，每次最多去b个，取到最后一个石子获胜123456789101112int main() &#123; int t; scanf(\"%d\", &amp;t); while (t--) &#123; int a, b,flag; scanf(\"%d%d\", &amp;a, &amp;b); if (a % (b + 1) == 0)flag = 2; else flag = 1; if (flag == 1)printf(\"A\\n\"); else printf(\"B\\n\"); &#125;&#125;Nim–两人从n堆石子中任选一堆取石子，不得不取，可以把一堆直接去玩，拿到最后一颗石子得人获胜12345678910111213int main() &#123; int n; int stone, tag=0; scanf(\"%d\", &amp;n); while (n--) &#123; scanf(\"%d\", &amp;stone); tag ^= stone; &#125; // tag为0则为后⼿手赢，否则为先⼿手赢 if (tag == 0)printf(\"B\\n\"); else printf(\"A\\n\");&#125;威佐夫博弈–有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜1234567891011121314int main() &#123; int n; int stone, tag=0; scanf(\"%d\", &amp;n); while (n--) &#123; int a, b; scanf(\"%d%d\", &amp;a,&amp;b); if (a &lt; b)swap(a, b); int flag = (a - b)*(sqrt(5) + 1) / 2; //黄金分割线 // 如果flag == b，则为后⼿手赢，否则先⼿手赢（奇异局） if (flag == b)printf(\"B\\n\"); else printf(\"A\\n\"); &#125;&#125;SG打表1234567891011121314151617181920212223//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N],sg[N],hash[N]; void getSG(int n)&#123; int i,j; memset(sg,0,sizeof(sg)); for(i=1;i&lt;=n;i++) &#123; memset(hash,0,sizeof(hash)); for(j=1;f[j]&lt;=i;j++) hash[sg[i-f[j]]]=1; for(j=0;j&lt;=n;j++) //求mes&#123;&#125;中未出现的最小的非负整数 &#123; if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125;SG-DFS打表12345678910111213141516171819202122232425int s[110],sg[10010],n;int SG_dfs(int x)&#123; int i; if(sg[x]!=-1) return sg[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) &#123; if(x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int e; for(i=0;;i++) if(!vis[i]) &#123; e=i; break; &#125; return sg[x]=e;&#125;一般DFS只在打表解决不了的情况下用，首选打表预处理。","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"log(n)分解一个数的所有素因子模板","slug":"分解素因子","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:42:50.934Z","comments":true,"path":"article/分解素因子.html","link":"","permalink":"https://anoyer.cn/article/分解素因子.html","excerpt":"","text":"123456789101112131415161718192021 //n为要分解的数 //Fac数组存所有质因子 //cnt为质因子个数void primeFactor(int n)&#123; while(n%2==0)&#123; Fac[cnt++]=2; n/=2; &#125; // 经过第二步, 此时 n 一定为奇数 // 并且不存在偶数的素因子 // 所以我们可以跳过所有偶数 (i += 2) for(int i=3;i&lt;=sqrt(n);i+=2)&#123; while(n%i==0)&#123; Fac[cnt++]=i; n/=i; &#125; &#125; //此处为了防止是一个大于 2 的素数 if(n&gt;2)Fac[cnt++]=n;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"求大数的n次方对m取模（欧拉降幂）","slug":"大数次方模板","date":"2018-11-27T05:55:49.000Z","updated":"2019-01-24T04:43:14.274Z","comments":true,"path":"article/大数次方模板.html","link":"","permalink":"https://anoyer.cn/article/大数次方模板.html","excerpt":"","text":"求2^n次方对mod取模，n为一个大数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;char s[MAXN];long long phi(long long x)&#123; long long ret = x; for (int i = 2; i * i &lt;= x; ++i) if (x % i == 0) &#123; ret -= ret / i; while (x % i == 0) x /= i; &#125; if (x &gt; 1) ret -= ret / x; return ret;&#125;ll mpow(ll a, ll n, ll m) //a ^ n % m&#123; ll t = 1; while (n) &#123; if (n &amp; 1) t = (t * a) % m; a = (a * a) % m, n &gt;&gt;= 1; &#125; return t;&#125;int main()&#123;#ifdef LOCAL //freopen(\"C:/input.txt\", \"r\", stdin);#endif int T; cin &gt;&gt; T; while (T--) &#123; ll n = 0, p = phi(MOD); scanf(\"%s\", s); //求2^s次方 s为一个大数 for (int i = 0; s[i]; i++) n = (n * 10 + s[i] - '0') % p; n += p - 1; ll ans = mpow(2, n, MOD); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"置顶文章示例","slug":"article-top","date":"2018-11-22T03:35:22.000Z","updated":"2019-01-24T04:38:32.876Z","comments":true,"path":"article/article-top.html","link":"","permalink":"https://anoyer.cn/article/article-top.html","excerpt":"","text":"【前言】这是置顶文章的示例。在&lt;!-- more --&gt;标签前的内容都会显示在首页的文章列表的摘录中，内容不能太多，建议在一至两段后即可添加more标签。置顶文章的顶部参数设置img: 设置了首页列表左侧显示的图片，使用默认的置顶图片即可。如果需要替换，请进入博客根目录下的source\\img文件夹下进行替换。topimg: 设置是否显示右侧的置顶标志，true为显示，false为不显示。top: 设置置顶顺序，当top的值越大时，文章会显示在首页列表最上方。若无特殊需求，建议不要在其他文章中设置top参数，以免导致文章顺序排列错误。置顶文章的内容建议可将某篇特别的文章进行置顶展示或者专门用来编辑各种公告、通知、留言等内容。","categories":[],"tags":[]},{"title":"Hexo的入门教程及Next主题配置","slug":"Hexo 入门教程","date":"2018-11-22T03:35:22.000Z","updated":"2019-01-24T04:41:22.299Z","comments":true,"path":"article/Hexo 入门教程.html","link":"","permalink":"https://anoyer.cn/article/Hexo 入门教程.html","excerpt":"","text":"博主链接Hexo的入门教程及Next主题配置Node及Hexo安装hexo是什么？简单的说，就是一个静态博客的生成工具也可以说是一个搭建静态博客的框架，我这个博客就是就是基于hexo生成的。9月份把这个博客用hexo折腾出来，前几天ACM区域赛事结束了，所以想记录下来折腾的过程，留着以后备用。这里只说如何在windows下成功安装hexo并运行起来，关于主题以及配置不做记录。安装Node.js因为Hexo是基于Node.js的，所以必须先安装Node，所以请点击这里去下载适合自己windows版本的Node吧。（注意：在安装步骤里Custom Setup这一步记得选Add to PATH）。安装好以后，打开CMD，(那对于小白来说如何打开CMD呢？win+R然后输入cmd，点击确定，这样CMD就打开了.)，输入npm -v,如果出现版本号，那说明安装成功了，并且环境变量也配置好了，如果是未知命令那就要配置下环境变量。安装Hexo还是打开CMD然后输入安装hexo的命令：1npm install -g hexo-cli这一步需要一点时间，请稍等一会，让他安装好。安装完成后在CMD里输入hexo -v出现一系列版本号就是安装成功啦QAQ到这里，就要恭喜你成功完成了Hexo的安装了。生成一个博客初始化个人博客仓库在电脑中建一个文件夹（路径根据自己爱好，我是在E盘里建了一个名为Blog的文件夹），我在这里命名为Blog吧。然后通过CMD的cd到这个文件夹下，运行命令：1hexo init这个时候会将这个文件夹初始化为一个博客专用文件夹，生成过程稍微要点时间，耐心等待。然后输入：1npm install之后npm将会自动安装你需要的组件，只需要等待npm操作即可。开始生成博客继续操作：1hexo g然后输入：1hexo s会出现：在浏览器里打开http://localhost:4000/，你将会看到：到这里你已经有了一个属于你的本地Blog了。Coding部署why不是Github，因为我个人认为搭建一个个人博客用Github会有诸多不便。比如：1.搭建一个博客肯定就要往百度推送，不然别人搜不到你的博客有什么意思。而如果部署Github的话，百度无法抓取blog链接。2.Coding服务器在中国，所以Blog加载速度比GitHub快很多。注册Coding现在我们的博客已经在本地搭建完成，那要怎么才能让别人看到我们的博客呢？我们选择把我们的静态网页的代码发到coding上去，然后由coding负责将我们的代码展现出来。注册步骤比较简单，点击这里去注册。需要声明的是，如果你以后不想绑定独立域名，那么coding给你的域名默认为 仓库名.coding.me而你需要建立的仓库名需要与你的用户名保持一致，不然会出现问题，所以慎重起名字。然后填好个人信息，就会升级为银牌会员（能拥有5个私人仓库）。新建仓库在coding上面新建仓库项目名称写成你的用户名，比如我的仓库名字为Blog,然后描述写不写都行，自己选择公有还是私有，然后直接选择创建项目。配置ssh这个过程的目的是在你的电脑和coding之间建立联系的通道，不然谁都能往上面增加内容，那你的博客岂不乱套了？首先查看目录C:Users\\用户名有没有.ssh目录,如果没有，cmd在本地blog路径下,输入命令:1ssh-keygen -t rsa -C &quot;这里填上你的邮箱地址&quot;然后按3个回车。再检查有没有.ssh目录，打开目录，你会看到出现3个文件：然后用notepad++打开id——rsa.pub(这个是公钥，不带pub的是私钥，这个不要泄露出去），你会开到一堆字母，全选复制下来。下面打来浏览器，进入你刚才创建的仓库，设置-部署公钥-新建部署公钥，公钥名称可以不填，将刚才复制的公钥粘贴在公钥内容里面。把授予权限打上勾！，然后添加就可以了。站点配置下面我们进行博客的站点配置，打开Blog文件夹，你会看到这样的文件这个文件的意思就是对你的博客进行一些设置，比如的你的用户名等等，记住这个文件特别重要！，以后你进行配置都要在这里进行，下面我们用notepad++打开它，这是你的网站信息要是不懂英文就查字典写，注意：名称后面要放空格，不然会出错！！！。然后滑倒最下面，填写你的git地址，这一步特别关键，你可以照我这个写，同样，别忘了空格！（本张图片来自vzhiwen，因为我Blog修改了域名，后面会讲到）然后点击文件保存上传代码在Blog文件路径里，依次输入下列命令：123hexo cleanhexo dhexo g如果提及不上去，就下载一个插件，在命令行里输入：1npm install hexo-deployer-git --save再次提交就可以了clean表示清除缓存，d是deploy的缩写，意思是将代码推送到coding，然后等待一些时间，第一次需要输入coding的用户名和密码或者询问你yes/no，按照说明输入即可，出现下面的字样说明推送完毕打开pages服务打开浏览器，进入coding，代码-pages服务，部署来源选择master，然后可以选择https访问（）这个就是打开你网页的时候地址栏前面显示的绿锁头，后面写着安全，如果不选择，就会出现叹号，不过影响不大。现在，你的博客已经基本配置完成，现在就打开你的浏览器，输入你的网址试试吧！主题配置如果你感觉默认Blog主题可以通过这一块来学习，如果给自己Blog换个主题。主题安装为了使博客不太难看，我们需要安装一个主题，切换至刚刚生成的Hexo 目录，安装主题$ cd Blog$ git clone https://github.com/iissnan/hexo-theme-next themes/next如果没有Git可以去下一个，百度有一堆这里选了一个极简的主题，也是Hexo众多主题中最受欢迎的一个。上面出现的喵神的主题 在这里。Hexo也有更多主题供你选择。启用主题：在你的站点配置文件_config.yml里修改theme: next //刚刚安装主题的，名字主题配置：这是 NexT 默认的 Scheme —— Muse ，现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 4）主题设定 选择 Scheme Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：1234Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 选择 Pisce Scheme123#scheme: Muse#scheme: Mistscheme: Pisces写文章所有基础框架都已经创建完成，接下来可以开始写你的第一篇博客了在Blog/source/_posts下创建你的第一个博客吧，例如，创建一个名为FirstNight.md的文件，用Markdown大肆发挥吧，注意保存。如：1234---title: First Night---&gt; 我有一头**小毛驴**，可是我从来都不骑。然后本体测试看看，输入hexo s测试服务启动，你可以在浏览器中输入https://localhost:4000 访问了如果测试没问题，就可以上传到Coding了依次输入下面命令123hexo cleanhexo dhexo g然后你就可以再浏览器里输入你的Coding项目链接访问了标签 分类 关于 标签图标 侧边栏菜单创建文章在Blog路径下输入：1hexo new &quot;文章名称&quot;生产后会提示你文件路径，一般在Blog/source/_posts下文章基本设置12345678910---title: CentOS7下Tomcat启动慢的原因及解决方案date: 2017-12-02 21:01:24comments: true #是否可评论toc: true #是否显示文章目录categories: &quot;云服务器&quot; #分类tags: #标签 - centOS - tomcat---创建标签1hexo new page tags基本设置123title: tagsdate: 2017-12-02 21:01:24type: &quot;tags&quot;创建分类1hexo new page categories基本设置123title: categoriesdate: 2017-12-02 21:01:24type: &quot;categories&quot;标签图标实现效果图修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;设置菜单：设置 菜单 菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置(在主题配置文件中)1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）：键值设定值显示文本（简体中文）homehome: /主页archivesarchives: /archives归档页categoriescategories: /categories分类页tagstags: /tags标签页aboutabout: /about关于页面commonwealcommonweal: /404.html公益 404设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项：123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 菜单图标配置示例123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 作为图标。 请注意键值（如 home）的大小写要严格匹配 7）侧栏 默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：12left - 靠左放置right - 靠右放置目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。12sidebar: position: left设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：123456post - 默认行为，在文章页面（拥有目录列表）时显示always - 在所有页面中都显示hide - 在所有页面中都隐藏（可以手动展开）remove - 完全移除sidebar: display: post搜索搜索功能真心好用，当文章多起来的时候，标签提供的作用已经很少了，只能简单索引，搜索却能精确查找，这里我用的依旧是最简单的本地站内搜索。安装插件1npm install hexo-generator-searchdb --save修改 站点配置 文件12345search: path: search.xml field: post format: html limit: 10000修改 主题配置文件12local_search: enable: true头像 （头像旋转）实现效果图：设置头像编辑 主题配置文件_config.yml， 修改字段1avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是地址值完整的互联网URI:http://example.com/avatar.png站点内的地址将头像放置主题目录下的source/uploads/（新建 uploads 目录若不存在） 配置为：avatar: /uploads/avatar.png或者 放置在 source/images/ 目录下, 配置为：avatar: /images/avatar.png1avatar: http://example.com/avatar.png实现头像旋转：打开\\themes\\next\\source\\css\\_common\\components\\sidebar\\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;友链编辑主题配置文件添加：12345# titlelinks_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/社交网站侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在主题配置文件中。1、 链接放置在 social字段下，一行一个链接。其键值格式是 显示文本: 链接地址。12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等123456782、 设定链接的图标，对应的字段是 social_icons。其键值格式是 匹配键:Font Awesome图标名称， 匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配），图标名称 是Font Awesome图标的名字（不必带 fa- 前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo浏览量 访客量 阅读数打开文件： themes/next/_config.yml1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; 访问人数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=\"fa fa-file-o\"&gt;&lt;/i&gt; 阅读数 page_pv_footer:相关操作：enable: true添加相关中文说明，不添加也行。修改统计规则及busuanzi失效修复打开\\themes\\next\\layout_partials\\footer.swig文件,在copyright前加上画红线这句话：代码如下：1&lt;script async src=\"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;然后再合适的位置添加显示统计的代码，如图：代码如下：12345&lt;div class=\"powered-by\"&gt;&lt;i class=\"fa fa-user-md\"&gt;&lt;/i&gt;&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数:&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;在这里有两中不同计算方式的统计代码：pv的方式，单个用户连续点击n篇文章，记录n次访问量123&lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt;uv的方式，单个用户连续点击n篇文章，只记录1次访客数123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;次&lt;/span&gt;添加之后再执行hexo d -g，然后再刷新页面就能看到效果字数统计 阅读时长 总字数在站点的根目录下：1$ npm i --save hexo-wordcount打开 themes/next/_config.yml ，搜索关键字 post_wordcount：1234567891011# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true #字数统计 wordcount: true #预览时间 min2read: true #总字数,显示在页面底部 totalcount: true separated_meta: true文章发表 更新时间打开主题配置文件 _config.yml ,搜索关键字 updated_at 设置为 true ：123456# Post meta display settingspost_meta: item_text: true created_at: true updated_at: ture categories: true编辑文章,增加关键字updated（next可以根据文章改变时间自动更改）12345---layout: layouttitle: 关于date: 2017-08-18 15:41:18updated: 2017-09-05 20:18:54 #手动添加更新时间,不加这一行会自动更新背景图片在 themes/next/source/css/_custom/custom.styl 中添加如下代码：1234567body&#123; background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125;动态粒子修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面)123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面)123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\\（￣︶￣）/如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码：123&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125;改为1234&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\"color=\"0,0,255\" opacity='0.7' zIndex=\"-2\" count=\"99\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125;配置项说明color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)opacity: 线条透明度（0~1）, 默认: 0.5count: 线条的总数量, 默认: 150zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1加载动画打开 themes/next/_config.yml ，搜索关键字 pace ,设置为 true ,可以更换加载样式：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash #替换更换样式透明背景内容板块透明博客根目录 themes\\next\\source\\css\\_schemes\\Pisces\\_layout.styl 文件 .content-wrap 标签下 background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度菜单栏背景博客根目录 themes\\next\\source\\css\\_schemes\\Pisces\\_layout.styl 文件 .header-inner 标签下 background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度站点概况背景博客根目录 themes\\next\\source\\css\\_schemes\\Pisces\\_sidebar.styl 文件 .sidebar-inner 标签下 background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度然后修改博客根目录 themes\\next\\source\\css\\_schemes\\Pisces\\_layout.styl 文件 .sidebar 标签下 background: $body-bg-color修改为：1background: rgba(255,255,255,0.7); //0.7是透明度按钮背景博客根目录 themes\\next\\source\\css\\_common\\components\\post\\post-button.styl 同上修改对应位置为 background: transparent;修改底部Hexo和主题信息在图标库中找到你自己喜欢的图标, 修改桃心,打开 themes/next_config.yml ,搜索关键字 authoricon,替换图标名12# icon between year and author @Footerauthoricon: id-card2.隐藏网页底部 Hexo 强力驱动打开主题配置文件,搜索关键字 copyright ，如下:(或者直接删除)12# Footer `powered-by` and `theme-info` copyrightcopyright: false博客运行时间打开next\\layout\\_partials路径中的footer.swig,在文件中合适位置（我加在了最后面）加入下面代码段：1&lt;span id=\"timeDate\" title=\"网站运行时间\"&gt;载入天数...&lt;/span&gt;&lt;span id=\"times\" title=\"网站运行时间\"&gt;载入时分秒...&lt;/span&gt;在next\\layout\\_layout.swig中插入下面代码块：12345678910111213141516&lt;!--此处为建站时间 --&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(\"09/24/2018 23:45:01\"); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = \"0\" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = \"0\" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = \"0\" + snum;&#125; document.getElementById(\"timeDate\").innerHTML =\"(ㆆᴗㆆ)本弱已菜菜的存活了\"+dnum+\"&amp;thinsp;天\"; document.getElementById(\"times\").innerHTML = hnum + \"&amp;thinsp;时\" + mnum + \"&amp;thinsp;分\" + snum + \"&amp;thinsp;秒\"; &#125; setInterval(\"createtime()\",250);然后就可以上传看效果啦版权声明自己使用的Hexo+NexT主题，主题默认的版权声明配置在themes\\next\\_config.yml文件中12345Copy# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/直接把enable 改为true即可开启。文章结尾–加入感谢阅读实现效果图具体实现方法在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=\"text-align:center;color: #ccc;font-size:14px;\"&gt;-------------本文结束&lt;i class=\"fa fa-paw\"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）：代码如下：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;然后打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。Valine评论注册Leancloud评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号Leancloud官网，点我注册注册完以后需要创建一个应用，名字可以：blog ，然后 进入应用-&gt;设置-&gt;应用key获取你的appid 和 appkey 如图所示：博客主题配置文件配置拿到你的appid和appkey之后，打开主题配置文件 搜索 valine，填入appid 和 appkey123456789valine: enable: true appid: your app id appkey: your app key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: just so so guest_info: nick,mail,link pageSize: 10配置域名记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去百度分享ShareSDK开始使用注册一个账号，然后打开后台，找到appkey打开1博客\\themes\\next\\layout\\_partials\\share新建一个文件名为 sharesdk.swig ，并输入以下代码：12345678910111213141516171819202122232425262728&lt;!--MOB SHARE BEGIN--&gt; &lt;div class=\"-mob-share-ui-button -mob-share-open\"&gt;分享&lt;/div&gt; &lt;div class=\"-mob-share-ui\" style=\"display: none\"&gt; &lt;ul class=\"-mob-share-list\"&gt; &lt;li class=\"-mob-share-weibo\"&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-tencentweibo\"&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-qzone\"&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-qq\"&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-weixin\"&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-douban\"&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-renren\"&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-kaixin\"&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-facebook\"&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-twitter\"&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-pocket\"&gt;&lt;p&gt;Pocket&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-google\"&gt;&lt;p&gt;Google+&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-youdao\"&gt;&lt;p&gt;有道云笔记&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-mingdao\"&gt;&lt;p&gt;明道&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-pengyou\"&gt;&lt;p&gt;朋友网&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-tumblr\"&gt;&lt;p&gt;Tumblr&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-instapaper\"&gt;&lt;p&gt;Instapaper&lt;/p&gt;&lt;/li&gt; &lt;li class=\"-mob-share-linkedin\"&gt;&lt;p&gt;LinkedIn&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"-mob-share-close\"&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class=\"-mob-share-ui-bg\"&gt;&lt;/div&gt; &lt;script id=\"-mob-share\" src=\"http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123; theme.shareSDKappkey &#125;&#125;\"&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt;打开：1LX-Blog\\themes\\next\\layout\\post.swig将以下代码：1234567891011&lt;div class=\"post-spread\"&gt; &#123;% if theme.jiathis %&#125; &#123;% include '_partials/share/jiathis.swig' %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include '_partials/share/baidushare.swig' %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include '_partials/share/add-this.swig' %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include '_partials/share/duoshuo_share.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt;改成：12345678910111213&lt;div class=\"post-spread\"&gt; &#123;% if theme.jiathis %&#125; &#123;% include '_partials/share/jiathis.swig' %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include '_partials/share/baidushare.swig' %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include '_partials/share/add-this.swig' %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include '_partials/share/duoshuo_share.swig' %&#125; &#123;% elseif theme.sharesdk %&#125; &#123;% include '_partials/share/sharesdk.swig' %&#125; &#123;% endif %&#125; &lt;/div&gt;打开 主题配置文件，添加以下代码：12sharesdk: trueshareSDKappkey: 你的appkey向百度站长推送当我们一开始建完博客时，搜索引擎是搜索不到的，我们需要做一项工作就是通知搜索引擎收录我们的网站。如何被百度收录这里需要做两个事情，一个是验证网站，一个是链接提交.验证网证我们到百度站长平台里面的站长工具里面去验证网站，大概步骤如下：第一步：输入网站第二步：站点属性第三步：验证网站前两步都很简单，第三步：验证网站有以下三种方法：文件验证HTML标签验证CNAME验证这里我们选择文件验证的方法，然后会得到一个baidu_verify_xxxxx.html文件。我使用的主题是next，所以我把这个验证文件放在theme/next/source/根目录下面，这样当我们编译网站hexo generate的时候，这个文件会被原封不动的拷贝到我们博客的public/根目录下。好，重要编译hexo并部署，完成验证.链接提交接下来我们进入链接提交.链接提交有手动和自动两种方法，手动就是每次你有新的链接生成，你就需要手动提交链接到百度，这种方法太麻烦了，不使用。自动提交有三种方式：主动推送(实时)自动推送sitemap这里我们选择sitemap方式。安装hexo的sitemap网站地图生成插件1npm install hexo-generator-baidu-sitemap --save在你的hexo站点的_config.yml添加下面的代码123# hexo sitemap网站地图baidusitemap: path: baidusitemap.xml配置成功后，hexo编译时会在hexo站点根目录生成baidusitemap.xml，部署网站后，提交到百度：代码复制下载插件clipboard.js 。将下载的clipboard.js文件下的dist文件夹中的文件拖到.\\themes\\next\\source\\js\\src 文件夹下也是在.\\themes\\next\\source\\js\\src目录下，创建clipboard-use.js，文件内容如下：1234567891011121314151617/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class=\"btn-copy\" data-clipboard-snippet=\"\"&gt;'; copyHtml += ' &lt;i class=\"fa fa-globe\"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(\".highlight .code pre\").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode();&#125;(window, document);在.\\themes\\next\\source\\css\\_custom\\custom.styl样式文件中添加下面代码：123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;在.\\themes\\next\\layout\\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（&lt;/body&gt;）之前添加）：123&lt;!-- 代码块复制功能 --&gt; &lt;script type=\"text/javascript\" src=\"/js/src/clipboard.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js/src/clipboard-use.js\"&gt;&lt;/script&gt;博客压缩加速访问在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save在如下图所示，新建 gulpfile.js ，并填入以下内容：123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']);生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。主页文章添加阴影效果实现效果图具体实现方法打开\\themes\\next\\source\\css_custom\\custom.styl,向里面加入：12345678/*主页文章添加阴影效果*/ .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;修改代码块自定义样式打开\\themes\\next\\source\\css\\_custom\\custom.styl,向里面加入：(颜色可以自己定义)123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;博客宝宝效果如图安装依赖包,在站点根目录，打开Git Bash ，安装hexo-helper-live2d1npm install --save hexo-helper-live2d在站点配置文件或者主题配置文件添加以下内容1234567891011121314live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true安装需要的宠物文件1npm install &#123;packagename&#125;如效果图所示的宠物名为haruto， 则为 npm install live2d-widget-model-haruto,其他宠物包点击live2d-widget-models。如果需要修改宠物的位置，可以在display下添加1234# 水平位置hOffset: 0# 垂直位置vOffset: -20详细内容可参考hexo-helper-live2d点击红心特效和爆炸特效红心特效实现效果图：实现方法：在网址输入:http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\\themes\\next\\layout\\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt;爆炸特效实现效果图：实现方法：跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下：1\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;;打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码：12345&#123;% if theme.fireworks %&#125; &lt;canvas class=\"fireworks\" style=\"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;\" &gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/animejs/2.2.0/anime.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js/src/fireworks.js\"&gt;&lt;/script&gt;&#123;% endif %&#125;打开主题配置文件，在里面最后写下:12# Fireworksfireworks: true文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：代码如下：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;然后在文章上写成类似这样：文章置顶打开 Hexo 站点下 node_modules/hexo-generator-index/lib/generator.js 文件。代码全部替换为：(next 5.1以后主题已自带此功能)12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;;打开文章添加top字段,设置数值，数值越大文章越靠前：1234567---layout: layouttitle: 标签1date: 2017-08-18 15:41:18tags: 标签1top: 100---域名更换1.申请域名我在万网购买的域名，地址：https://wanwang.aliyun.com/domain/com?spm=5176.8142029.388261.137.LoKzy7我这里是.cn结尾的域名，一年39大洋anoyer.cn2.解析域名添加如下的解析得到域名之后，到控制台进行解析控制台-&gt;域名与网站(万网)-&gt;域名-&gt;域名列表-&gt;解析在阿里云控制台，设置主机记录www，记录类型为A，记录值是IP103.210.21.11。其中103.210.21.11是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Coding Pages。在阿里云控制台，设置主机记录@，记录类型为CNAME，记录值是anoyer.coding.me。表示将https://anoyer.cn这个主域名映射anoyer.coding.me如何知道知道的 Coding Pages IP在命令提示符中输入ping anoyer.cn成功之后:3.配置在博客的source文件夹下建立一个CNAME的文件内容写入你的域名信息，比如我这里是anoyer.cn发布到Coding即可4.Coding 配置进入Coding 项目的Pages服务，进入设置把刚解析的域名绑定上去。到这里就OK了。插入网易云音乐在知道了页面的结构之后，你就可以将你的播放器添加在页面的任意位置，开始我是放在了首页，然后发现一上来就自动播放太吵了，于是就放在了侧边栏，想要听得朋友可以手动点击播放，我们可以直接在网易云音乐中搜索我们想要插入的音乐，然后点击生成外链播放器然后可以根据你得设置生成相应的html代码，将获得的html代码插入到你想要插入的位置即可我放在了layout/_macro/sidebar.swig 文件下1234&lt;div id=\"music163player\"&gt; &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=280 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66\"&gt; &lt;/iframe&gt;&lt;/div&gt;阅读全文在文章中使用&lt; !--more--&gt; 手动进行截断这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !--more--&gt; 标签，使用灵活，也是Hexo推荐的方法。在线联系​ 之前有访问过一些大佬的个人博客，里面有个在线联系功能，看着不错，所以也试着在自己的站点上接入了此功能。注册首先在DaoVoice注册个账号，点击-&gt;邀请码是2e5d695d。完成后，会得到一个app_id，后面会用到：修改head.swig修改/themes/next/layout/_partials/head.swig文件，添加内容如下：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125;位置贴图：主题配置文件在_config.yml文件中添加内容：123# Online contactdaovoice: truedaovoice_app_id: # 这里填你刚才获得的 app_id聊天窗口配置附上我的聊天窗口的颜色、位置等设置信息：至此，网页的在线联系功能已经完成，重新hexo g，hexo d上传GitHub后，页面上就能看到效果了。就比如说你现在往右下角看看(～￣▽￣)～ ，欢迎撩我（滑稽）。打赏因为next主题自带打赏功能，所以我们只需要在next的主题配置文件中找到如下代码,image文件夹是我在blog/source下面建立的文件夹，然后把你的微信及支付宝收钱码图片拉进去，修改名字为wechatreward.png和alipayreward.png123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /image/wechatreward.pngalipay: /image/alipayreward.png修改文章间分割线打开 themes/next/source/css/_common/components/post/post-eof.styl ,修改：12345678910.posts-expand &#123; .post-eof &#123; display: block; // margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 0%; //分割线长度 height: 0px; // 分割线高度 background: $grey-light; text-align: center; &#125;&#125;参考博客：1.https://www.jianshu.com/p/f054333ac9e62.https://blog.csdn.net/qsdsn/article/details/779466773.https://www.aisun.org/2017/10/hexo-next+dingzhi/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://anoyer.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://anoyer.cn/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"https://anoyer.cn/tags/Next/"}]},{"title":"HDU-3374-String Problem(最大与最小表示法+kmp求循环节)","slug":"HDU - 3374 - String Problem(最大与最小表示法+kmp求循环节)","date":"2018-11-17T09:06:51.000Z","updated":"2019-01-24T04:39:47.216Z","comments":true,"path":"article/HDU - 3374 - String Problem(最大与最小表示法+kmp求循环节).html","link":"","permalink":"https://anoyer.cn/article/HDU - 3374 - String Problem(最大与最小表示法+kmp求循环节).html","excerpt":"","text":"博主链接HDU - 3374 - String Problem题意：给你一个字符串，问这个字符串经过移动后的字典序最小的字符串的首字符位置和字典序最大的字符串的首字符的位置，和能出现多少次最小字典序的字符串和最大字典序的字符串题解：利用最小表示法与最大表示法O(n)复杂度求出最小字典序和最大字典序串出现位置，然后利用kmp求出next，利用next数组性质求出循环节次数，因为最小和最大字典序串出现次数等于循环节次数（这个关系可以脑补下）代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+20;const int mod=1e9+7;char s[maxn];int len;int nex[maxn];void GetNex()&#123; memset(nex,0,sizeof(nex)); int j=-1; for(int i=0;s[i];i++)&#123; while(s[i]!=s[j+1]&amp;&amp;j!=-1)j=nex[j]; if(s[i]==s[j+1]&amp;&amp;i!=0)j++; nex[i]=j; &#125;&#125;int GetMin()&#123; int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int t=s[(i+k)%len]-s[(j+k)%len]; if(t==0)k++; else&#123; if(t&gt;0)i=i+k+1; else j=j+k+1; if(i==j)j++; k=0; &#125; &#125; return min(i,j);&#125;int GetMax()&#123; int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int t=s[(i+k)%len]-s[(j+k)%len]; if(t==0)k++; else&#123; if(t&gt;0)j=j+k+1; else i=i+k+1; if(i==j)j++; k=0; &#125; &#125; return i&lt;j?i:j;&#125;int main()&#123; while(scanf(\"%s\",s)!=EOF)&#123; len=strlen(s); int sum=0; int mi=GetMin();//获取最小表示下标 int mx=GetMax();//获取最大表示下标 GetNex(); if(len%(len-nex[len-1]-1)==0)sum=len/(len-nex[len-1]-1); else sum=1; printf(\"%d %d %d %d\\n\",mi+1,sum,mx+1,sum); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"最小表示法与最大表示法","slug":"最小表示法与最大表示法(O(n))","date":"2018-11-17T09:03:50.000Z","updated":"2019-01-24T04:43:42.576Z","comments":true,"path":"article/最小表示法与最大表示法(O(n)).html","link":"","permalink":"https://anoyer.cn/article/最小表示法与最大表示法(O(n)).html","excerpt":"","text":"博主CSDN最小表示法伪代码：最小表示法的算法思路是维护两个指针i,j。令i=0,j=1如果S[i] &gt; S[j] i=j, j=i+1如果S[i] &lt; S[j] j++如果S[i]==S[j] 设指针k，分别从i和j位置向下比较，直到S[i] != S[j]​ 如果S[i+k] &gt; S[j+k] i=i+k​ 否则j++返回i和j的小者模版：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+7;const int mod=1e9+7;char s[maxn];int GetMin()&#123; int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int t=s[(i+k)%len]-s[(j+k)%len]; if(t==0)k++; else&#123; if(t&gt;0)i=i+k+1; else j=j+k+1; if(i==j)j++; k=0; &#125; &#125; return min(i,j);&#125;int GetMax()&#123; int i=0,j=1,k=0; while(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)&#123; int t=s[(i+k)%len]-s[(j+k)%len]; if(t==0)k++; else&#123; if(t&gt;0)j=j+k+1; else i=i+k+1; if(i==j)j++; k=0; &#125; &#125; return i&lt;j?i:j;&#125;int main()&#123; scanf(\"%s\",s); return 0;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"河南农业大学热身赛标程","slug":"河南农业大学热身赛标程","date":"2018-11-13T05:13:47.000Z","updated":"2019-01-24T04:44:28.940Z","comments":true,"path":"article/河南农业大学热身赛标程.html","link":"","permalink":"https://anoyer.cn/article/河南农业大学热身赛标程.html","excerpt":"","text":"河南农业大学热身赛标程博主CSDNA.宅宅的排位赛1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 10;const int mod = 1e9 + 7;int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int a, suma = 0, sumb = 0; for (int i = 0; i &lt;= 13; i++)&#123; //suma记录A1~N1的和 scanf(\"%d\", &amp;a); suma += a; &#125; for (int i = 0; i &lt;= 13; i++)&#123; //sumb记录A2~N2的和 scanf(\"%d\", &amp;a); sumb += a; &#125; printf(\"%d\\n\", suma - sumb); &#125; return 0;&#125;B.冒泡排序12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int a[120];int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n, min_ = 9999,id=0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++)scanf(\"%d\", &amp;a[i]); //sort(a, a + n);//解法一：调用库函数快排函数 //解法二：手撸冒泡排序 for (int i = 0; i &lt; n; i++)&#123; min_ =a[i]; id = i; for (int j = i; j &lt; n; j++)&#123; if (a[j] &lt;= min_)min_ = a[j], id = j; &#125; swap(a[i], a[id]); //把为排序的最小值换到当前i位 &#125; for (int i = 0; i &lt; n; i++)printf(\"%d\\n\", a[i]); &#125; return 0;&#125;C.小刘数字母123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt; //万能头文件using namespace std;char s[10050];int main()&#123; int t; char ch; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%s\",s); getchar(); //接收空格 scanf(\"%c\",&amp;ch); int cnt=0; //记录出现次数 int len=strlen(s); //求出输入串长度 for(int i=0;i&lt;len;i++)&#123; if(s[i]==ch)cnt++; //如果ch出现就cnt++ &#125; printf(\"%d\\n\",cnt); &#125; return 0;&#125;D.HH的LCM12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; scanf(\"%d\",&amp;t); //GCD解法 while(t--)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",a*b/__gcd(a,b)); //a,b的最小公倍数=a*b/(a,b的最大公因数) &#125; // 暴力解法 /*while(t--)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); for(int i=1;i&lt;=a*b;i++)&#123; //a*b肯定能被整除a,b，所以LCM不大于a*b if(i%a==0&amp;&amp;i%b==0)&#123; //第一个能被整除的a,b的便是他们的最小公倍数 printf(\"%d\\n\",i); break; &#125; &#125; &#125;*/ return 0;&#125;E.斐波那契数123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 10;const int mod = 1e9 + 7;int Fib[maxn];int main()&#123; int cnt = 1; Fib[0] = 0; Fib[1] = 1; for (int i = 2; Fib[i - 1] &lt;= 100000; i++, cnt++)&#123; //暴力打表求出所有小于100000的斐波那契数 Fib[i] = Fib[i - 1] + Fib[i - 2]; &#125; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n, ans = 0; //ans用来记录数量 scanf(\"%d\", &amp;n); for (int i = 26; i &gt;= 1; i--)&#123; //对于n从最大的Fib数列往前扫， if (n &gt;= Fib[i])n -= Fib[i], ans++; //如果发现不大于n的Fib数，就用n-Fib[i],ans++ &#125; /* 贪心证明：因为对于任何n,比n小的且最大的Fib[i]一定满足 Fib[i]&lt;n&lt;2*Fib[i] 因为 Fib[i-1]+Fib[i]=Fib[i+1]&lt;2*Fib[i] */ printf(\"%d\\n\", ans); &#125; return 0;&#125;F.辉辉学长爱喝水123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 10;const int mod = 1e9 + 7;int main()&#123; double n, m; scanf(\"%lf%lf\", &amp;n, &amp;m); int a = ceil(n / (m * 2)); if (n == 0)printf(\"0\\n\"); // 需要多少步 向上取整 else if (m == 0)printf(\"No answer!\\n\"); else if(n-a*m&lt;=0)&#123; printf(\"1\\n\"); &#125; else printf(\"%d\\n\", a + 1); return 0;&#125;G.打麻将123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;bool ok=0; //胡牌标记bool vis[20]; //标记这张牌有没有被使用char a[20];int d[20][5];int ttt[11];void dfs(int cur,char *str,int cnt)&#123; if(cur&gt;12)return; //因为组成刻子和顺子的牌需要12张，如果超过了就return if(cur==12&amp;&amp;cnt==4)&#123; //如果刻子和顺子用了12张牌且刻子和顺子数一共4，则进一步判断另外两张牌是不是对子 int a=0,b=0; for(int i=1;i&lt;=14;i++)if(!vis[i])&#123;vis[i]=true,a=i;break;&#125; //遍历出剩余第一张牌 for(int i=1;i&lt;=14;i++)if(!vis[i])&#123;vis[i]=true,b=i;break;&#125; //遍历出剩余第二张牌 if(str[a]==str[b]&amp;&amp;(str[a]!=' '&amp;&amp;str[b]!=' ')) //如果str[a]等于str[b]能胡牌 ，ok=true ok=true; vis[a]=vis[b]=false; return ; &#125; for(int i=1;i&lt;=12&amp;&amp;!ok;i++) //dfs遍历这14张牌所有组合情况 if(!vis[i]) for(int j=i+1;j&lt;=13&amp;&amp;!ok;j++) if(!vis[j]) for(int k=j+1;k&lt;=14&amp;&amp;!ok;k++)&#123; //挑3个牌str[i],str[j],str[k] if(!vis[k]) if((str[i]==str[j]&amp;&amp;str[j]==str[k])||(str[i]+1==str[j]&amp;&amp;str[j]+1==str[k]))&#123; //看能否成顺子或刻子 vis[i]=vis[j]=vis[k]=true; //把选的牌标记为已用 dfs(cur+3,str,cnt+1);//成了的话，cur+3，cur代表选的牌数，cnt+1，cnt代表现在顺子跟刻子的总和 vis[i]=vis[j]=vis[k]=false; //把牌标记为未用 &#125; &#125;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%s\",&amp;a[1]); //cnt++; int tt_=0; ok=false; memset(ttt,0,sizeof(ttt)); for(int i=1;i&lt;=14;i++)&#123; //判断是否是合法牌 ttt[a[i]-'0']++; if(ttt[a[i]-'0']&gt;4)&#123; printf(\"The data is error!\\n\"); tt_=1; break; &#125; &#125; if(tt_)continue; sort(a+1,a+15); //把牌从小到大排好序 dfs(0,a,0); if(!ok)printf(\"NO\\n\"); else printf(\"YES\\n\"); &#125; return 0;&#125;","categories":[{"name":"农大训练赛题解","slug":"农大训练赛题解","permalink":"https://anoyer.cn/categories/农大训练赛题解/"}],"tags":[{"name":"河南农业大学训练赛题解","slug":"河南农业大学训练赛题解","permalink":"https://anoyer.cn/tags/河南农业大学训练赛题解/"}]},{"title":"河南农业大学训练赛二标程","slug":"河南农业大学测试赛二标程","date":"2018-11-10T14:01:51.000Z","updated":"2019-01-24T04:44:08.649Z","comments":true,"path":"article/河南农业大学测试赛二标程.html","link":"","permalink":"https://anoyer.cn/article/河南农业大学测试赛二标程.html","excerpt":"","text":"河南农业大学测试赛二标程博主CSDNA.判断闰年1234567891011121314#include&lt;cstdio&gt; int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; int n; scanf(\"%d\",&amp;n); if((n%4==0&amp;&amp;n%100!=0)||(n%400==0)) printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125; return 0;&#125;B.复读机1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;int main()&#123;#ifdef LOCAL freopen(\"C:/input.txt\", \"r\", stdin);#endif int T; cin &gt;&gt; T; while (T--) &#123; int N; cin &gt;&gt; N; char c, last = 0; getchar(); for (int i = 0; i &lt; N; i++) &#123; c = getchar(); if (c != last) putchar(c), last = c; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;C.hui姐识数1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 7;char Num[20][100] = &#123; \"Ling\", \"Yi\", \"Er\", \"San\", \"Si\", \"Wu\", \"Liu\", \"Qi\", \"Ba\", \"Jiu\" &#125;;char Unit[10][100] = &#123; \"\", \"Shi\", \"Bai\", \"Qian\",\"Wan\" &#125;;int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n,k=4,flag=0,flag0=0; scanf(\"%d\", &amp;n); if (n == 0)&#123; printf(\"%s\\n\", Num[0]); continue; &#125; for (int i = 10000; k&gt;=0; i /= 10,k--)&#123; if (n / i)&#123; if (flag&amp;&amp;flag0)&#123; printf(\"%s\", Num[0]); flag = 0; &#125; printf(\"%s%s\", Num[n / i], Unit[k]); n %= i; flag =1; flag0 = 0; &#125; else if(flag)flag0 = 1; &#125; puts(\"\"); &#125;&#125;","categories":[{"name":"农大训练赛题解","slug":"农大训练赛题解","permalink":"https://anoyer.cn/categories/农大训练赛题解/"}],"tags":[{"name":"河南农业大学训练赛题解","slug":"河南农业大学训练赛题解","permalink":"https://anoyer.cn/tags/河南农业大学训练赛题解/"}]},{"title":"河南农业大学训练赛标程","slug":"河南农业大学测试赛标程","date":"2018-11-08T14:32:27.000Z","updated":"2019-01-24T04:44:19.520Z","comments":true,"path":"article/河南农业大学测试赛标程.html","link":"","permalink":"https://anoyer.cn/article/河南农业大学测试赛标程.html","excerpt":"","text":"河南农业大学测试赛标程博主CSDNA.最大最小值12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e9 + 10;const int mod = 1e9 + 7;int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n; scanf(\"%d\", &amp;n); ll a, min_ = maxn, max_ = -maxn; for (int i = 0; i &lt; n; i++)&#123; scanf(\"%lld\", &amp;a); if (a&gt;max_)max_ = a; if (a &lt; min_)min_ = a; &#125; printf(\"%lld %lld\\n\", max_, min_); &#125; return 0;&#125;B.找众数12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e9 + 10;const int mod = 1e9 + 7;int num[120];int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n,a; memset(num, 0, sizeof(num)); scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf(\"%d\", &amp;a); num[a]++; &#125; int b = 0; a = 0; for (int i = 0; i &lt;= 100; i++)&#123; if (num[i] &gt;= a)b = i,a=num[i]; &#125; printf(\"%d\\n\", b); &#125; return 0;&#125;C.买！买！买！123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e3 + 10;const int mod = 1e9 + 7;int a[] = &#123; 15, 25&#125;;int dp[maxn];int main()&#123; int t; scanf(\"%d\", &amp;t); while (t--)&#123; int n; scanf(\"%d\", &amp;n); memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 10; i &lt;= n * 10; i+=5)&#123; for (int j = 0; j &lt; 2; j++)&#123; if (i &gt;= a[j])&#123; dp[i] += dp[i - a[j]]; &#125; &#125; &#125; printf(\"%d\\n\", dp[n * 10]); &#125; return 0;&#125;","categories":[{"name":"农大训练赛题解","slug":"农大训练赛题解","permalink":"https://anoyer.cn/categories/农大训练赛题解/"}],"tags":[{"name":"河南农业大学训练赛题解","slug":"河南农业大学训练赛题解","permalink":"https://anoyer.cn/tags/河南农业大学训练赛题解/"}]},{"title":"线性基模板","slug":"线性基模板","date":"2018-10-20T14:52:30.000Z","updated":"2019-01-24T04:46:38.104Z","comments":true,"path":"article/线性基模板.html","link":"","permalink":"https://anoyer.cn/article/线性基模板.html","excerpt":"","text":"博主CSDN12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const int maxn=1e5+7;const int mod=1e9+7;struct Linear_Basis&#123; ll b[63],nb[63],tot; //b为线性基 nb用来求第K小异或值 tot为nb元素个数 bool flag=false; void Init()&#123; //初始化 tot=0; flag=false; memset(b,0,sizeof(b)); memset(nb,0,sizeof(nb)); &#125; void Ins(ll x)&#123; //插入 for(int i=62;i&gt;=0;i--)&#123; if(x&amp;(1ll&lt;&lt;i))&#123; if(!b[i])&#123; b[i]=x; return; &#125; x^=b[i]; &#125; &#125; flag=true; return; &#125; bool Fin(ll x)&#123; //验证存在性 if(x==0&amp;&amp;b[0])return 1; for(int i=62;i&gt;=1;i--)&#123; int j=i-1; if(x&amp;(1&lt;&lt;j))&#123; x^=b[i]; if(!x)return 1; &#125; &#125; return 0; &#125; ll Max(ll x)&#123; //求最大值 ll res=x; for(int i=62;i&gt;=0;i--)&#123; res=max(res,res^b[i]); &#125; return res; &#125; ll Min(ll x)&#123; //求最小值 ll res=x; for(int i=0;i&lt;=62;i++)&#123; if(b[i])res^=b[i]; &#125; return res; &#125; ll Rebuild()&#123; //第K大 for(int i=62;i&gt;=0;i--)&#123; if(b[i]==0)continue; for(int j=i-1;j&gt;=0;j--)&#123; if(b[j]==0)continue; if(b[i]&amp;(1ll&lt;&lt;j))b[i]^=b[j]; &#125; &#125; for(int i=0;i&lt;=62;i++)&#123; if(b[i])nb[tot++]=b[i]; &#125; &#125; ll Kth_Max(ll k)&#123; if(flag)k--; //??? ll res=0; if(k==0)return 0; if(k&gt;=(1ll&lt;&lt;tot))return -1; for(int i=62;i&gt;=0;i--)&#123; if(k&amp;(1ll&lt;&lt;i))res^=nb[i]; &#125; return res; &#125;&#125;LB;void merge(Linear_Basis &amp;a,Linear_Basis &amp;b)&#123;//a和b都变成a+b for(int i=31;i&gt;=1;i--)&#123; if(b.b[i]==0)continue; a.Ins(b.b[i]); &#125; b=a;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); return 0;&#125;","categories":[{"name":"数论模板","slug":"数论模板","permalink":"https://anoyer.cn/categories/数论模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"Codeforces-Round-515-(Div.3)--C.BooksQueries","slug":"Codeforces-Round-515-Div-3-C-Books-Queries","date":"2018-10-12T17:10:33.000Z","updated":"2019-01-24T04:39:36.131Z","comments":true,"path":"article/Codeforces-Round-515-Div-3-C-Books-Queries.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-515-Div-3-C-Books-Queries.html","excerpt":"","text":"博主链接题目题意：给Q次操作，可以往书架右边边缘加书或者左边边缘加书或者查询一本书里边缘的最短距离题解：用两个数组记录一本书是第几本放右边或左边的书，这样就可以保证如果这本书是当时通过放左边进入书架则距离为 ==min(L + b[id]-1,R - b[id])== ，如果通过右边则是 ==min(R + a[id]-1, L - a[id])== ，可以自己脑补下代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define ll long long intconst ll LINF=0x3f3f3f3f3f3f3f;#define MOD(x) (x)%modusing namespace std;const int maxn = 1e6 + 10;const int mod = 1e9 + 7;int a[maxn],b[maxn];int main(int argc, char *argv[]) &#123; int q,d; char ch[10]; int id,L=0, R=0; int cnt = 0; scanf(\"%d\", &amp;q); while (q--) &#123; cin &gt;&gt; ch &gt;&gt; id; if (ch[0] == 'L') &#123; ++cnt; a[id] = ++L; &#125; else if (ch[0] == 'R') &#123; ++cnt; b[id] = ++R; &#125; else &#123; if (a[id] == 0) &#123; printf(\"%d\\n\", min(L + b[id]-1,R - b[id])); &#125; else &#123; printf(\"%d\\n\", min(R + a[id]-1, L - a[id])); &#125; &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"思维题","slug":"思维题","permalink":"https://anoyer.cn/tags/思维题/"}]},{"title":"Codeforces-Round-513-D-Social-Circles","slug":"Codeforces-Round-513-C-Social-Circles","date":"2018-10-04T11:12:27.000Z","updated":"2019-01-24T04:47:20.242Z","comments":true,"path":"article/Codeforces-Round-513-C-Social-Circles.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-513-C-Social-Circles.html","excerpt":"","text":"博主博客题目链接题意：有n个人，及每个人坐位置时左右需要有多少空椅子，求所有人入座至少需要多少椅子题解：利用贪心，将所有人的右边需要空的椅子数存在a数组里，右边需要空的椅子数存在b数组里，然后排序，将对应下标的max（a[i],b[i]）加起来再加上n，就是答案，因为大的和大的一合一起可以保证省去椅子最大123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 1e5 + 10;const int mod = 1e9 + 7;typedef long long ll;int a[maxn], b[maxn];int main(int argc, char *argv[]) &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++)scanf(\"%d%d\", &amp;a[i], &amp;b[i]); sort(a, a + n); sort(b, b + n); ll ans = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; ans += max(a[i], b[i]); &#125; printf(\"%lld\\n\", ans+n); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"思维题","slug":"思维题","permalink":"https://anoyer.cn/tags/思维题/"}]},{"title":"表达式求值（逆波兰）","slug":"表达式求值","date":"2018-10-03T16:19:05.000Z","updated":"2019-01-24T04:46:53.570Z","comments":true,"path":"article/表达式求值.html","link":"","permalink":"https://anoyer.cn/article/表达式求值.html","excerpt":"","text":"博主CSDN123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 10;typedef long long ll;char s[maxn];int cmp(char ch)&#123; switch (ch)&#123; case '+': case '-':return 1; case '*': case '/':return 2; default:return 0; &#125;&#125;string ss = \"\";void ToSuffix()&#123; stack&lt;char&gt;Se; double ans = 0; Se.push('#'); int len = strlen(s); for (int i = 0; i&lt;len; i++)&#123; if (s[i] &gt;= '0'&amp;&amp;s[i] &lt;= '9')&#123; ss += s[i++]; while (s[i] &gt;= '0'&amp;&amp;s[i] &lt;= '9')&#123; ss += s[i++]; &#125; ss += ' '; &#125; if (s[i] == '(')Se.push(s[i]); else if (s[i] == ')')&#123; while (Se.top() != '(')&#123; ss += Se.top(); ss += ' '; Se.pop(); &#125; Se.pop(); &#125; else if (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/')&#123; while (cmp(Se.top()) &gt;= cmp(s[i]))&#123; ss += Se.top(); ss += ' '; Se.pop(); &#125; Se.push(s[i]); &#125; &#125; while (Se.top() != '#')&#123; ss += Se.top(); ss += ' '; Se.pop(); &#125; Se.pop();&#125;double Solve()&#123; stack&lt;double&gt;num; int i = 0; double x = 0, y = 0,ans=0; for (int i = 0; ss[i]; i++)&#123; if (ss[i] &gt;= '0'&amp;&amp;ss[i] &lt;= '9')&#123; ans = ss[i++] - '0'; while (ss[i] &gt;= '0'&amp;&amp;ss[i] &lt;= '9')&#123; ans =ans*10+ ss[i++]-'0'; &#125; num.push(ans); ans = 0; &#125; else if (ss[i] == ' '); else&#123; x = num.top(); num.pop(); y = num.top(); num.pop(); if (ss[i] == '+')num.push(x + y); else if (ss[i] == '-')num.push(y - x); else if (ss[i] == '*')num.push(x * y); else if (ss[i] == '/')num.push(y / x); &#125; &#125; x = num.top(); num.pop(); return x;&#125;int main()&#123; freopen(\"C:/Users/Administrator/Desktop/input.txt\", \"r\", stdin); int t; scanf(\"%d\", &amp;t); while (t--)&#123; scanf(\"%s\", s); ss = \"\"; ToSuffix(); printf(\"%.2f\\n\",Solve()); &#125; return 0;&#125;","categories":[{"name":"数据结构模板","slug":"数据结构模板","permalink":"https://anoyer.cn/categories/数据结构模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"},{"name":"逆波兰","slug":"逆波兰","permalink":"https://anoyer.cn/tags/逆波兰/"}]},{"title":"线段树模板","slug":"线段树模板","date":"2018-10-03T16:19:05.000Z","updated":"2019-01-24T04:46:41.088Z","comments":true,"path":"article/线段树模板.html","link":"","permalink":"https://anoyer.cn/article/线段树模板.html","excerpt":"","text":"博主CSDN12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int n,p,a,b,m,x,y,ans;struct node&#123; int l,r,w,f;&#125;tree[400001];inline void build(int k,int ll,int rr) &#123;//建树 tree[k].l=ll,tree[k].r=rr; if(tree[k].l==tree[k].r)&#123; scanf(\"%d\",&amp;tree[k].w); return; &#125; int m=(ll+rr)/2; build(k*2,ll,m); build(k*2+1,m+1,rr); tree[k].w=tree[k*2].w+tree[k*2+1].w;&#125;inline void down(int k) &#123;//标记下传 tree[k*2].f+=tree[k].f; tree[k*2+1].f+=tree[k].f; tree[k*2].w+=tree[k].f*(tree[k*2].r-tree[k*2].l+1); tree[k*2+1].w+=tree[k].f*(tree[k*2+1].r-tree[k*2+1].l+1); tree[k].f=0;&#125;inline void ask_point(int k)&#123;//单点查询 if(tree[k].l==tree[k].r)&#123; ans=tree[k].w; return ; &#125; if(tree[k].f) down(k); int m=(tree[k].l+tree[k].r)/2; if(x&lt;=m) ask_point(k*2); else ask_point(k*2+1);&#125;inline void change_point(int k) &#123;//单点修改 if(tree[k].l==tree[k].r)&#123; tree[k].w+=y; return; &#125; if(tree[k].f) down(k); int m=(tree[k].l+tree[k].r)/2; if(x&lt;=m) change_point(k*2); else change_point(k*2+1); tree[k].w=tree[k*2].w+tree[k*2+1].w; &#125;inline void ask_interval(int k) &#123;//区间查询 if(tree[k].l&gt;=a&amp;&amp;tree[k].r&lt;=b) &#123; ans+=tree[k].w; return; &#125; if(tree[k].f) down(k); int m=(tree[k].l+tree[k].r)/2; if(a&lt;=m) ask_interval(k*2); if(b&gt;m) ask_interval(k*2+1);&#125;inline void change_interval(int k) &#123;//区间修改 if(tree[k].l&gt;=a&amp;&amp;tree[k].r&lt;=b)&#123; tree[k].w+=(tree[k].r-tree[k].l+1)*y; tree[k].f+=y; return; &#125; if(tree[k].f) down(k); int m=(tree[k].l+tree[k].r)/2; if(a&lt;=m) change_interval(k*2); if(b&gt;m) change_interval(k*2+1); tree[k].w=tree[k*2].w+tree[k*2+1].w;&#125;int main()&#123; scanf(\"%d\",&amp;n);//n个节点 build(1,1,n);//建树 scanf(\"%d\",&amp;m);//m种操作 for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d\",&amp;p); ans=0; if(p==1)&#123; scanf(\"%d\",&amp;x); ask_point(1);//单点查询,输出第x个数 printf(\"%d\",ans); &#125; else if(p==2)&#123; scanf(\"%d%d\",&amp;x,&amp;y); change_point(1);//单点修改 &#125; else if(p==3)&#123; scanf(\"%d%d\",&amp;a,&amp;b);//区间查询 ask_interval(1); printf(\"%d\\n\",ans); &#125; else&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;y);//区间修改 change_interval(1); &#125; &#125;&#125;","categories":[{"name":"数据结构模板","slug":"数据结构模板","permalink":"https://anoyer.cn/categories/数据结构模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"对数器模板","slug":"对数器模版","date":"2018-10-03T16:19:05.000Z","updated":"2019-01-24T04:43:26.333Z","comments":true,"path":"article/对数器模版.html","link":"","permalink":"https://anoyer.cn/article/对数器模版.html","excerpt":"","text":"博主CSDN123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//需要建立主路径 和主路径下sample/ 保证程序文件存在#include &lt;bits/stdc++.h&gt;using namespace std;string mpat(\"D:/dsq/\"); //主路径 注意末尾跟'/'!!!! linuxpwd查看当前路径string an(\"A\"), bn(\"B\"); //程序名字int brek = 5; //几个错误停止 -1不停止int cmpt = 1; //编译模式void exec(const string &amp;cmd, string &amp;res)&#123; char buf[1024]; FILE *fp = _popen(cmd.c_str(), \"r\"); //linux下改为popen while (fgets(buf, 1024, fp)) res.append(buf); _pclose(fp); //linux下改为pclose&#125;void wrfile(const string &amp;path, stringstream &amp;ss)&#123; string str; FILE *fp = fopen(path.c_str(), \"wb\"); while (getline(ss, str)) fprintf(fp, \"%s\\r\\n\", str.c_str()); fclose(fp);&#125;long long d_rand(long long l, long long r)&#123; int k = rand() % 4; long long t = rand(); for (int i = 0; i &lt; k; i++) t = t &lt;&lt; 16 | rand(); return l + t % (r - l + 1);&#125;double f_rand(double l, double r)&#123; double t = rand() / 32767.0; return l + t * (r - l);&#125;char c_rand(const string &amp;ch)&#123; return ch[rand() % ch.size()];&#125;void sample(stringstream &amp;sout) //样例生成&#123;&#125;int main()&#123; srand(time(NULL)); rand(); if (cmpt) //编译功能 &#123; system((\"g++ \" + mpat + an + \".cpp -o \" + mpat + an + \".exe -std=c++11\").c_str()); //C++11支持 system((\"g++ \" + mpat + bn + \".cpp -o \" + mpat + bn + \".exe -std=c++11\").c_str()); &#125; string num, aout, bout, spat = mpat + \"sample/\"; //样例生成子路径 stringstream ss; int cnt = 0, wa = 0; for (int i = 1; i &lt;= brek; i++) &#123; ss.clear(), ss &lt;&lt; i, ss &gt;&gt; num; remove((spat + num + \"samp.txt\").c_str()); remove((spat + num + \"ans\" + an + \".txt\").c_str()); remove((spat + num + \"ans\" + bn + \".txt\").c_str()); &#125; while (wa &lt; brek &amp;&amp; cnt &lt; 1e4) //几个错误停止 极限1W个样例 &#123; ss.str(\"\"), ss.clear(), ss &lt;&lt; wa + 1, ss &gt;&gt; num; aout.clear(), bout.clear(), ss.clear(); sample(ss); wrfile(spat + num + \"samp.txt\", ss); cout &lt;&lt; ++cnt; exec(mpat + an + \".exe &lt; \" + spat + num + \"samp.txt\", aout); exec(mpat + bn + \".exe &lt; \" + spat + num + \"samp.txt\", bout); if (aout != bout) &#123; ss.clear(), ss.str(aout); wrfile(spat + num + \"ans\" + an + \".txt\", ss); ss.clear(), ss.str(bout); wrfile(spat + num + \"ans\" + bn + \".txt\", ss); ++wa; &#125; cout &lt;&lt; \"\\t\" &lt;&lt; wa &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"对数器","slug":"对数器","permalink":"https://anoyer.cn/categories/对数器/"}],"tags":[]},{"title":"后缀自动机模板","slug":"后缀自动机模板","date":"2018-10-03T08:56:15.000Z","updated":"2019-01-24T04:43:04.567Z","comments":true,"path":"article/后缀自动机模板.html","link":"","permalink":"https://anoyer.cn/article/后缀自动机模板.html","excerpt":"","text":"博主CSDNSAM常解决的问题：问题1.给定文本T，询问格式如下：给定字符串P，问P是否是T的子串。问题2.给定字符串S，问它有多少不同的子串。（模板中的GetSubNum函数）问题3.给定字符串S，求其所有不同子串的总长度。问题4.给定字符串S，一系列询问——给出整数K_i，计算S的所有子串排序后的第K_i个。问题5.给定字符串S，找到和它循环同构的字典序最小字符串。问题.给定文本T，询问格式如下：给定字符串P，希望找出P作为子串在文本T中出现了多少次（出现区间可以相交）。问题6.给定文本T，询问格式如下：给定字符串P，求P在文本中第一次出现的位置。问题7.给定文本T，询问格式如下：给定字符串P，要求给出P在T中的所有出现位置（出现区间可以相交）。问题8.给定两个字符串S和T。要求找出它们的最长公共子串，即一个字符串X，它同时是S和T的子串。模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define maxc 28using namespace std;const int maxn = 1e6 + 5;const int mod = 1e9 + 7;typedef long long ll;int len[maxn * 2], //最长子串的长度(该节点字串数量=len[x]-len[link[x]])link[maxn * 2], //后缀链接(最短串前部减少一个字符所到达的状态)cnt[maxn * 2], //被后缀连接的数nex[maxn * 2][maxc], //状态转移(尾部加一个字符的下一个状态)(图)idx, //节点编号last; //最后节点ll epos[maxn * 2]; // enpos数（该状态子串出现数量）char str[maxn];ll a[maxn]; //长度为i的子串出现最大次数void Iint() &#123; //初始化 last = idx = 1; //1表示root起始点 空集 link[1] = len[1] = 0;&#125;//SAM建图void Extend(int c) &#123; //插入字符，为字符ascll码值 int x = ++idx; //创建一个新节点x; len[x] = len[last] + 1; // 长度等于最后一个节点+1 epos[x] = 1; //接受节点子串除后缀连接还需加一 int p; //第一个有C转移的节点; for (p = last; p &amp;&amp; !nex[p][c]; p = link[p])nex[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新节点 if (!p)link[x] = 1, cnt[1]++; //全部都没有c的转移 直接将新节点后缀连接到起点 else &#123; int q = nex[p][c]; //p通过c转移到的节点 if (len[p] + 1 == len[q]) //pq是连续的 link[x] = q, cnt[q]++; //将新节点后缀连接指向q即可,q节点的被后缀连接数+1 else &#123; int nq = ++idx; //不连续 需要复制一份q节点 len[nq] = len[p] + 1; //令nq与p连续 link[nq] = link[q]; //因后面link[q]改变此处不加cnt memcpy(nex[nq], nex[q], sizeof(nex[q])); //复制q的信息给nq for (; p&amp;&amp;nex[p][c] == q; p = link[p]) nex[p][c] = nq; //沿着后缀连接 将所有通过c转移为q的改为nq link[q] = link[x] = nq; //将x和q后缀连接改为nq cnt[nq] += 2; // nq增加两个后缀连接 &#125; &#125; last = x; //更新最后处理的节点&#125;void GetNpos() &#123; //求npos数，即该节点字串出现次数 queue&lt;int&gt;q; for (int i = 1; i &lt;= idx; i++) if (!cnt[i])q.push(i); //将所有没被后缀连接指向的节点入队 while (!q.empty()) &#123; int x = q.front(); q.pop(); epos[link[x]] += epos[x]; //子串数量等于所有后缀连接指向该节点的子串数量和+是否为接受节点 if (--cnt[link[x]] == 0)q.push(link[x]); //当所有后缀连接指向该节点的处理完毕后再入队 &#125;&#125;void GetSubNum() &#123; //求不相同字串数量 ll ans = 0; for (int i = 2; i &lt;= idx; i++)ans += len[i] - len[link[i]]; //一状态子串数量等于len[i]-len[link[i]] printf(\"%lld\\n\",ans);&#125;void GetSubMax() &#123; //求出所有长度为k的子串中出现次数最多的子串出现次数 GetNpos(); int n = strlen(str); for (int i = 1; i &lt;= idx; i++)a[len[i]] = max(a[len[i]], epos[i]); //长度≤k的子串中出现次数最多的子串出现次数的最小值 for (int i = n - 1; i &gt;= 1; i--)a[i] = max(a[i], a[i + 1]); //求一遍后缀最大值就是答案 for (int i = 1; i &lt;= n; i++)printf(\"%lld\\n\", a[i]);&#125;int main() &#123; //freopen(\"c:/input.txt\",\"r\",stdin); return 0;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"HDU-4300-Clairewd’s message（KMP+特判）","slug":"HDU-4300-Clairewd’s-message（KMP-特判）","date":"2018-09-30T06:45:51.000Z","updated":"2019-01-24T04:40:50.304Z","comments":true,"path":"article/HDU-4300-Clairewd’s-message（KMP-特判）.html","link":"","permalink":"https://anoyer.cn/article/HDU-4300-Clairewd’s-message（KMP-特判）.html","excerpt":"","text":"博主链接题目题意：先给你一个密码表。然后给你一个不一定完整的串。原串满足前一半是密码，后一半是明码。要求你最小的补全这个串。题解：设给的串长度为len,则1…(len+1)/2的字母一定是密码。我们将1…(len+1)/2的字母全部安装密码表转换成原文，然后将得到的串求Next数组。再根据Next数组求出最大的相等的前后缀（长度一定小于或等于len/2，题目要求），然后输出就可以。然后这里一定要先加一个特判是不是不存在相等的前后缀，也就是s[1]!=s[len],这时输出原串一次，再输出一次原串全解密的串.代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 1e6 + 10;const int mod = 1e9 + 7;typedef long long ll;char s[maxn],s1[maxn];char t[maxn];char m[33];int nex[maxn];void Get_nex() &#123; int j = 0; for (int i = 1; s[i]; i++) &#123; while (s[i] != s[j + 1] &amp;&amp; j != 0)j = nex[j]; if (s[i] == s[j + 1] &amp;&amp; i != 1)j++; nex[i] = j; &#125;&#125;int main() &#123; int t,n; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%s\", m+1); scanf(\"%s\", s+1); int len = strlen(s+1); for (int i = 1;i&lt;=len+1; i++)s1[i] = s[i]; for (int j = 1; j &lt;= (len +1)/ 2; j++) &#123; //进行原串前半部分解密 for (int i = 1; i &lt;= 26; i++) &#123; if (s[j] == m[i]) &#123; s[j] = 'a' + i-1; break; &#125; &#125; &#125; Get_nex(); int nn =0; int a = nex[len]; if (a == 0) &#123; // 如果不存在相等的前后缀 printf(\"%s\", s1 + 1); for (int j = (len+1)/2+1; j &lt;= len; j++) &#123; for (int i = 1; i &lt;= 26; i++) &#123; if (s[j] == m[i]) &#123; s[j] = 'a' + i - 1; break; &#125; &#125; &#125; printf(\"%s\\n\", s+1); continue; &#125; while (a != 0) &#123; //找出最大的相等的前后缀且长度小于或等于len/2 if (s[a] == s[len]) &#123; if (a &lt;= len / 2)nn = max(nn, a); a = nex[a]; &#125; &#125; printf(\"%s\", s1+1); for (int i = nn+1; i &lt;= len -nn; ++i)printf(\"%c\",s[i]); printf(\"\\n\"); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"HDU-2594-Simpsons’ Hidden Talents（KMP的next数组应用）","slug":"HDU-2594-Simpsons’-Hidden-Talents（KMP的next数组应用）","date":"2018-09-28T14:57:50.000Z","updated":"2019-01-24T04:40:22.900Z","comments":true,"path":"article/HDU-2594-Simpsons’-Hidden-Talents（KMP的next数组应用）.html","link":"","permalink":"https://anoyer.cn/article/HDU-2594-Simpsons’-Hidden-Talents（KMP的next数组应用）.html","excerpt":"","text":"博主链接题目题意：给你两个串，求第一个串的前缀和第二个串的后缀的相同长度题解：( 这题和POJ2752基本一样，都是利用next性质求公共前后缀 )。利用strcat(s,s1)将两个串接起来,利用KMP的next数组性质如果s[next[n-1]]=s[n],则此时前后缀相同，然后再开始回滚，若s[next[n-1]] == s[n-1]，则子串s[0,1,2,…,next[n-1]]是满足条件的子串。然后判断s[next[next[n-1]]] == s[n-1]是否成立，这样一直回滚，直到next[next[…..next[n-1]]] == -1为止，这样求出最长的长度ans，判断ans是否大于两个串的较短串的长度，如果大于ans=min(len1,len2);(因为如果ans大于min，则一定存在长度为min的公共前后缀)代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 7;char s[maxn],s1[maxn];int nex[maxn],len;void Get_Nex() &#123; int j = -1; for (int i = 0; s[i]; i++) &#123; while (s[i] != s[j + 1] &amp;&amp; j != -1)j = nex[j]; if (s[i] == s[j + 1] &amp;&amp; i != 0)j++; nex[i] = j; &#125;&#125;int main() &#123; while (scanf(\"%s\", s) != EOF) &#123; scanf(\"%s\", s1); int len1 = strlen(s1); int len2 = strlen(s); strcat(s, s1); len = len1 + len2; Get_Nex(); int a = nex[len - 1], ans = 0, mi = min(len1, len2); while (a != -1) &#123; if (s[a] == s[len - 1]) &#123; if (ans &lt; a + 1)ans = a + 1; a = nex[a]; &#125; &#125; if (ans &gt; mi)ans = mi; for (int i = 0; i &lt; ans; i++) &#123; putchar(s[i]); if (i == ans - 1)printf(\" \"); &#125; printf(\"%d\\n\", ans); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"POJ2752-Seek-the-Name-Seek-the-Fame（找相同的前后缀）","slug":"POJ-2752-Seek-the-Name-Seek-the-Fame（找相同的前后缀）","date":"2018-09-28T11:00:01.000Z","updated":"2019-01-24T04:42:06.728Z","comments":true,"path":"article/POJ-2752-Seek-the-Name-Seek-the-Fame（找相同的前后缀）.html","link":"","permalink":"https://anoyer.cn/article/POJ-2752-Seek-the-Name-Seek-the-Fame（找相同的前后缀）.html","excerpt":"","text":"题目博主博客题意：求一个串中相同前后缀长度，并输出思路：利用KMP的next数组性质；如果s[next[n-1]]=s[n],则此时前后缀相同，然后再开始回滚，==若s[next[n-1]] == s[n-1]，则子串s[0,1,2,…,next[n-1]]是满足条件的子串==。然后判断s[next[next[n-1]]] == s[n-1]是否成立，这样一直回滚，直到next[next[…..next[n-1]]] == -1为止代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;stack&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 4e5 + 10;const int mod = 1e9 + 7;typedef long long ll;char s[maxn];int nex[maxn];int len;void Get_Nex() &#123; int j = -1; for (int i = 0; i &lt; len; i++) &#123; while (s[i] != s[j + 1] &amp;&amp; j != -1)j = nex[j]; if (s[i] == s[j + 1] &amp;&amp; i != 0)j++; nex[i] = j; &#125;&#125;stack&lt;int&gt;M;int main() &#123; while (scanf(\"%s\", s) != EOF) &#123; len = strlen(s); Get_Nex(); int a = nex[len - 1]; M.push(len); while (a != -1) &#123; if (s[a] == s[len - 1]) &#123; M.push(a + 1); a = nex[a]; &#125; &#125; while (!M.empty()) &#123; printf(\"%d \", M.top()); M.pop(); &#125; puts(\"\"); //for (int i = 0; i &lt; len; i++)printf(\"%d \", nex[i]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"POJ-3080 Blue Jeans(kmp+暴力求子串)","slug":"POJ-3080-Blue-Jeans-kmp-暴力求子串","date":"2018-09-26T14:09:17.000Z","updated":"2019-01-24T04:42:10.842Z","comments":true,"path":"article/POJ-3080-Blue-Jeans-kmp-暴力求子串.html","link":"","permalink":"https://anoyer.cn/article/POJ-3080-Blue-Jeans-kmp-暴力求子串.html","excerpt":"","text":"题目题意：给一个n，输入n个长度为60的字符串，求==最长公共子串==（2&lt;n&lt;=10),如果公共串长度大于等于3就输出这个子串（~~开始真的是瞎了，看了题直接将所有字符串连接来，求了波next数组，然后完美求出了子串长度，却发现要求是输出子串，心里***~~）**思路：(==KMP+暴力求子串==)枚举第一个字符串的不同长度子串，判断她是否为下面多有的公共子串？如果是的话，那么我们就表明找到，则比较其长度，如果比已经找到的串长，那么就替换结果串 否则按字典序比较。取字典序考前的，就可以。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;bits/stdc++.h&gt;using namespace std;char str[10][62];char substr[62];char result[62];char temp[62];int next[62];int len, n, max;void get_next() &#123; next[0] = -1; int j = -1; for (int i = 1; i &lt; len; i++) &#123; while (j &gt; -1 &amp;&amp; substr[j + 1] != substr[i]) j = next[j]; if (substr[j + 1] == substr[i]) j++; next[i] = j; &#125;&#125;void kmp() &#123; int j, m; get_next(); for (int k = 1; k &lt; n; k++) &#123; j = -1, m = -1;//m最好取-1 for (int i = 0; i &lt; 60; i++) &#123; while (j &gt; -1 &amp;&amp; substr[j + 1] != str[k][i]) j = next[j]; if (substr[j + 1] == str[k][i]) j++; if (j &gt; m) m = j; //m取可匹配到的最大值 &#125; if (m &lt; max) max = m;//max取可匹配到的最小值，公共子串以最小者为准 &#125;&#125;int main() &#123; int t, i, ans; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d\", &amp;n); for (i = 0; i &lt; n; i++) scanf(\"%s\", str[i]); ans = 0; for (i = 0; i &lt; 58; i++) &#123; strcpy(substr, str[0] + i);//枚举第一个串的所有后缀串 len = 60 - i; max = 65; kmp(); if (max &gt; ans) &#123; ans = max; strncpy(result, str[0] + i, ans + 1); result[ans + 1] = '\\0'; &#125; else if (max == ans) &#123; //若有相等长度，取字典序小者 strncpy(temp, str[0] + i, ans + 1); temp[ans + 1] = '\\0'; if (strcmp(result, temp) &gt; 0) strcpy(result, temp); &#125; &#125; if (ans &gt;= 2) printf(\"%s\\n\", result); else printf(\"no significant commonalities\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"暴力题","slug":"暴力题","permalink":"https://anoyer.cn/tags/暴力题/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"},{"name":"POJ","slug":"POJ","permalink":"https://anoyer.cn/tags/POJ/"}]},{"title":"C/C++文件读写大杂烩","slug":"C++文件读写","date":"2018-09-25T14:46:08.000Z","updated":"2019-01-24T04:47:21.102Z","comments":true,"path":"article/C++文件读写.html","link":"","permalink":"https://anoyer.cn/article/C++文件读写.html","excerpt":"","text":"c++：ifstream12345fstream in; //读文件in.open(\"路径\"); //只读 可以放在fstreaam in(\"路径\");fstream out; //写文件out.open(\"路径\");out.close();//关闭文件如果文件不存在返回错误1234if (!in.is_open()) &#123; //文件不存在，返回错误，并生成一个文件 cout &lt;&lt; \"Error!\" &lt;&lt; endl; exit(1); //终止程序&#125;如果文件不存在新建12fstream in;in.open(\"路径\",fstream::out||fstream::in);成功打开文件后写入数组,写入文件12in&gt;&gt;a[i];out&lt;&lt;a[i];C：stdio.h ,stdlib.h123456789FILE *fp; //文件指针变量fp=fopen(\"路径\",“文件使用方式”); //文件使用方式：r,w,a,rb,wb,ab,r+,w+,a+,rb+,wb+,ab+fclose(fp); //关闭文件fgetc(fp); //从fp指向文件读入一个字符fputs(ch,fp); //把字符写入fp指向文件fgets(str,n,fp); //从fp指向文件中读入一个长度为n-1的字符串存在str中fputs(str,fp) //把str写入fp指向文件fprintf(fp,\"%d%s\",i,str); //向fp中输入整数i,字符串str;fscanf(fp,\"%d%s\",i,str); //从fp文件中读出一个整数一个字符串给整数i,字符串str二进制读写–常用于读写结构体12fread(变量地址,size,count,fp); //从fp指的文件中读入连续count个size字节数据写入到变量fwrite(变量地址,size,count,fp); //从变量中取出连续count个size字节数据写入到fp指向文件中","categories":[{"name":"C++语法","slug":"C-语法","permalink":"https://anoyer.cn/categories/C-语法/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://anoyer.cn/tags/语法/"}]},{"title":"Codeforces Round 512--C.Vasya and Golden Ti","slug":"Codeforces-Round-512-Div-2-based-on-Technocup-2019-Elimination-Round-1-C-Vasya-and-Golden-Ti","date":"2018-09-23T16:00:44.000Z","updated":"2019-01-24T04:38:30.191Z","comments":true,"path":"article/Codeforces-Round-512-Div-2-based-on-Technocup-2019-Elimination-Round-1-C-Vasya-and-Golden-Ti.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-512-Div-2-based-on-Technocup-2019-Elimination-Round-1-C-Vasya-and-Golden-Ti.html","excerpt":"","text":"题目题意：给你一个由0-9组成的串，问能不能将串分成2份及两份以上，使每份数和相等解题思路：先特判下如果串中只有一种字符且串长度大于2则肯定可以，然后求出把0消去后串的前缀和（因为0对和没影响。再枚举i（i从1到n）位的前缀和num[i]，再看看（i-n）中有多少个前缀和num[j]能整除num[i]，如果满足的数量ans大于等于2且num[n]/ans==num[i],则一定可以分成ans份，否则输出no代码：123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;char s[110];int num[110];int main() &#123; int n; scanf(\"%d\", &amp;n); scanf(\"%s\", s+1); int cnt = 1; for(int i=1;i&lt;=n;i++)&#123; if (s[i] == '0')continue; num[cnt] = num[cnt - 1] + s[i] - '0'; cnt++; &#125; int flag = 1; for (int i = 1; i &lt;n; i++) &#123; if (s[i] != s[i + 1])flag = 0; &#125; if (flag&amp;&amp;n &gt;= 2) &#123; printf(\"YES\\n\"); return 0; &#125; for (int i = 1; i &lt; cnt; i++) &#123; int ans = 0; for (int j = i; j &lt; cnt; j++) &#123; if (num[j] % num[i] == 0)ans++; &#125; if (ans &gt;= 2 &amp;&amp; num[cnt - 1] % num[i] == 0 &amp;&amp; num[cnt - 1] == num[i]*ans) &#123; printf(\"YES\\n\"); return 0; &#125; &#125; printf(\"NO\\n\");&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"思维题","slug":"思维题","permalink":"https://anoyer.cn/tags/思维题/"}]},{"title":"Codeforces Round 512--B.Vasya and Cornfield","slug":"Codeforces-Round-512-Div-2-based-on-Technocup-2019-Elimination-Round-1-B-Vasya-and-Cornfield","date":"2018-09-23T15:51:08.000Z","updated":"2019-01-24T04:38:30.896Z","comments":true,"path":"article/Codeforces-Round-512-Div-2-based-on-Technocup-2019-Elimination-Round-1-B-Vasya-and-Cornfield.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-512-Div-2-based-on-Technocup-2019-Elimination-Round-1-B-Vasya-and-Cornfield.html","excerpt":"","text":"题目题意：给出一个矩形，顶点坐标具有笛卡尔性质，然后m次询问，每次询问给一个点，温这个点是否再矩形内解题思路：因为矩形顶点具有笛卡尔性质所以矩形4条边的方程分别为y=a+x,y=a-x,y=x-a,y=2*n-d-x,所以判断下点和4条边的关系便可值答案代码：12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;typedef long long ll;int main() &#123; int n, d; scanf(\"%d%d\", &amp;n, &amp;d); int m; scanf(\"%d\", &amp;m); int x, y; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); if (x + d&gt;=y&amp;&amp;x - d&lt;=y&amp;&amp;d - x &lt;=y &amp;&amp; 2 * n - d - x &gt;= y)printf(\"YES\\n\"); else printf(\"NO\\n\"); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"思维题","slug":"思维题","permalink":"https://anoyer.cn/tags/思维题/"}]},{"title":"HDU-1358-Period（KMP求前缀循环节）","slug":"HDU-1358-Period（KMP求前缀循环节）","date":"2018-09-23T07:50:11.000Z","updated":"2019-01-24T04:39:56.815Z","comments":true,"path":"article/HDU-1358-Period（KMP求前缀循环节）.html","link":"","permalink":"https://anoyer.cn/article/HDU-1358-Period（KMP求前缀循环节）.html","excerpt":"","text":"题目题意：给定一个字符串，求出所有循环的前缀串，输出前缀串的长度和循环的次数（大于一才算循环串）解题思路：思路是先构造出 next[] 数组，下标为 i，定义一个变量 j = i - next[i] 就是next数组下标和下标对应值的差，如果这个差能整除下标 i，即 i%j==0 ,则说明下标i之前的字符串（周期性字符串长度为 i）一定可以由一个前缀周期性的表示出来，这个前缀的长度为刚才求得的那个差，即 j，则这个前缀出现的次数为 i/j 。所以最后输出i和i/j即可。代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 1e6 + 5;char s[maxn];int nex[maxn];int n;void get_nex() &#123; int j = -1; for (int i = 0; s[i]; i++) &#123; while (s[i] != s[j + 1] &amp;&amp; j != -1)j = nex[j]; if (s[i] == s[j + 1]&amp;&amp;i!=0)j++; nex[i] = j; &#125;&#125;void Solve() &#123; for (int i = 1; i &lt; n; i++) &#123; int L = i - nex[i]; if ((i + 1) % L == 0 &amp;&amp; (i+1) / L &gt; 1) &#123; printf(\"%d %d\\n\", i+1, (i+1) / L); &#125; &#125;&#125;int main() &#123; int Case = 0; while (scanf(\"%d\", &amp;n)) &#123; if (n == 0)break; scanf(\"%s\", s); get_nex(); printf(\"Test case #%d\\n\",++Case); Solve(); printf(\"\\n\"); //for(int i=0;i&lt;n;i++)printf(\"%d \",nex[i]); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://anoyer.cn/tags/HDU/"},{"name":"KMP","slug":"KMP","permalink":"https://anoyer.cn/tags/KMP/"},{"name":"字符串题解","slug":"字符串题解","permalink":"https://anoyer.cn/tags/字符串题解/"}]},{"title":"Codeforces-Round-511-Div-2-C-Enlarge-GCD","slug":"Codeforces-Round-511-Div-2-C-Enlarge-GCD","date":"2018-09-21T16:56:54.000Z","updated":"2019-01-24T04:38:31.481Z","comments":true,"path":"article/Codeforces-Round-511-Div-2-C-Enlarge-GCD.html","link":"","permalink":"https://anoyer.cn/article/Codeforces-Round-511-Div-2-C-Enlarge-GCD.html","excerpt":"","text":"题目链接解题思路题解：先求出元素的最大公因子，开一个数组num记录每个数出现次数，再利用素数筛，求出所有数有当前质数因子的的个数代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 1.5e7 + 10;const int mod = 1e9 + 7;typedef long long ll;int P[maxn], num[maxn], a[300005], p[300005];int gcd(int a, int b)&#123; if (!b) return a; return gcd(b, a % b);&#125;int main() &#123; int n,d=0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); num[a[i]]++; if (!d) d = a[i]; else d = gcd(d, a[i]); &#125; int ans = n; for (int i = d + 1; i &lt; maxn; i++) if (!P[i]) &#123; int cnt = 0, j; for (j = i; j &lt; maxn; j += i) P[j] = 1, cnt += num[j]; ans = min(ans, n - cnt); &#125; if (ans &lt; n)printf(\"%d\\n\", ans); else printf(\"-1\\n\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://anoyer.cn/categories/题解/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://anoyer.cn/tags/codeforces/"},{"name":"思维题","slug":"思维题","permalink":"https://anoyer.cn/tags/思维题/"}]},{"title":"后缀数组DA模板","slug":"后缀数组模板","date":"2018-09-18T13:46:12.000Z","updated":"2019-01-24T04:43:00.699Z","comments":true,"path":"article/后缀数组模板.html","link":"","permalink":"https://anoyer.cn/article/后缀数组模板.html","excerpt":"","text":"sufﬁx array倍增算法 O(n*logn)待排序数组⻓长度为n,放在0~n-1中,在后⾯面补⼀一个0da(str, sa, rank, height, n, m);例如:n = 8;num[] = { 1, 1, 2, 1, 1, 1, 1, 2, $ }; 注意num后⼀一位为0,其他⼤大于0rank[] = { 4, 6, 8, 1, 2, 3, 5, 7, 0 }; rank[0~n-1]为有效值,rank[n]必定为0无效值sa[] = { 8, 3, 4, 5, 0, 6, 1, 7, 2 }; sa[1~n]为有效值,sa[0]必定为n是⽆无效值height[]= { 0, 0, 3, 2, 3, 1, 2, 0, 1 }; height[2~n]为有效值稍微改动可以求⻓长公共前缀，需要注意两串串起始位置相同的情况另外需要注意的是部分数组需要开两倍空间⼤大⼩小12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* Problem: JZOJ1598(询问一个字符串中有多少至少出现两次的子串) Content: SA's Code and Explanation Author : Anoyer*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int MAXN = 100005;char ch[MAXN], All[MAXN];int SA[MAXN], rank[MAXN], Height[MAXN], tax[MAXN], tp[MAXN], a[MAXN], n, m; char str[MAXN];//rank[i] 第i个后缀的排名; SA[i] 排名为i的后缀位置; Height[i] 排名为i的后缀与排名为(i-1)的后缀的LCP//tax[i] 计数排序辅助数组; tp[i] rank的辅助数组(计数排序中的第二关键字),与SA意义一样。//a为原串void RSort() &#123; //rank第一关键字,tp第二关键字。 for (int i = 0; i &lt;= m; i ++) tax[i] = 0; for (int i = 1; i &lt;= n; i ++) tax[rank[tp[i]]] ++; for (int i = 1; i &lt;= m; i ++) tax[i] += tax[i-1]; for (int i = n; i &gt;= 1; i --) SA[tax[rank[tp[i]]] --] = tp[i]; //确保满足第一关键字的同时，再满足第二关键字的要求&#125; //计数排序,把新的二元组排序。int cmp(int *f, int x, int y, int w) &#123; return f[x] == f[y] &amp;&amp; f[x + w] == f[y + w]; &#125; //通过二元组两个下标的比较，确定两个子串是否相同void Suffix() &#123; //SA for (int i = 1; i &lt;= n; i ++) rank[i] = a[i], tp[i] = i; m = 127 ,RSort(); //一开始是以单个字符为单位，所以(m = 127) for (int w = 1, p = 1, i; p &lt; n; w += w, m = p) &#123; //把子串长度翻倍,更新rank //w 当前一个子串的长度; m 当前离散后的排名种类数 //当前的tp(第二关键字)可直接由上一次的SA的得到 for (p = 0, i = n - w + 1; i &lt;= n; i ++) tp[++ p] = i; //长度越界,第二关键字为0 for (i = 1; i &lt;= n; i ++) if (SA[i] &gt; w) tp[++ p] = SA[i] - w; //更新SA值,并用tp暂时存下上一轮的rank(用于cmp比较) RSort(), swap(rank, tp), rank[SA[1]] = p = 1; //用已经完成的SA来更新与它互逆的rank,并离散rank for (i = 2; i &lt;= n; i ++) rank[SA[i]] = cmp(tp, SA[i], SA[i - 1], w) ? p : ++ p; &#125; //离散：把相等的字符串的rank设为相同。 //LCP int j, k = 0; for(int i = 1; i &lt;= n; Height[rank[i ++]] = k) for( k = k ? k - 1 : k, j = SA[rank[i] - 1]; a[i + k] == a[j + k]; ++ k); //这个知道原理后就比较好理解程序&#125;void Init() &#123; scanf(\"%s\", str+1); n = strlen(str+1); for (int i = 1; i &lt;=n; i ++) a[i ] = str[i];&#125;int main() &#123; Init(); Suffix(); for(int i=1;i&lt;=n;i++)cout&lt;&lt;SA[i]&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; printf(\"%s\\n\",str+SA[i]); &#125; /*int ans = Height[2]; for (int i = 3; i &lt;= n; i ++) ans += max(Height[i] - Height[i - 1], 0); printf(\"%d\\n\", ans); */&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"AC自动机模板","slug":"AC自动机模板","date":"2018-09-17T16:06:04.000Z","updated":"2019-01-24T04:39:04.752Z","comments":true,"path":"article/AC自动机模板.html","link":"","permalink":"https://anoyer.cn/article/AC自动机模板.html","excerpt":"","text":"经常用来解决多模式匹配问题：就是有多个模式串P1,P2,P3…，Pm，求出所有这些模式串在连续文本T1….n中的所有可能出现的位置。例如：求出模式集合{“nihao”,”hao”,”hs”,”hsr”}在给定文本”sdmfhsgnshejfgnihaofhsrnihao”中所有可能出现的位置给出L个模式字符串（加总长度为N），以及长度为M大文本，要求从大文本中提取每个模式字符串出现的位置。如果使用KMP算法，时间复杂度将达到O(LM+N)，而使用AC自动机可以在O(N+M)时间复杂度内解决这一问题，当L很大时，AC自动机的优势非常明显。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define ll long long int#define max_n 1000050#define max_tot 500050#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 1e5 + 7;struct Ac &#123; struct state &#123; //节点状态 int next[26]; int fail, cnt;//指针fail 到这个节点有cnt个串结束 &#125;stable[max_tot]; int size; //当前AC自动机节点个数 queue&lt;int&gt;q; void init() &#123; //初始化 met(stable); size = 1; while (!q.empty())q.pop(); &#125; void insert(char *s) &#123; //将模式串插入trie树 int now = 0; //代表走到那个节点 for (int i = 0; s[i]; i++) &#123; char ch = s[i]-'a'; if (!stable[now].next[ch]) //节点不存在该字母边，则新建一个 stable[now].next[ch] = size++; now = stable[now].next[ch]; &#125; stable[now].cnt++;//结束位置++； &#125; void build() &#123; //构造失配fail指针，要构造当前节点fail指针需先构造爸爸节点 for (int i = 0; i &lt; 26; i++)if (stable[0].next[i])q.push(stable[0].next[i]); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (stable[u].next[i]) &#123; //如果有i这条边 枚举下他儿子 int v = stable[u].fail; int a = stable[u].next[i]; while (v) &#123; //一直按箭头的fail if (stable[v].next[i]) &#123; //如果他某个祖先有i这条边 stable[a].fail = stable[v].next[i]; break; &#125; v = stable[v].fail; &#125; if (!stable[a].fail)stable[a].fail = stable[0].next[i]; q.push(stable[u].next[i]); //节点加进去 &#125; &#125; &#125; &#125; int get(int u) &#123; //算所有祖先的和 int res = 0; while (u) &#123; res = res + stable[u].cnt; stable[u].cnt = 0; //计算后不再计算，如果要计算不清零 u = stable[u].fail; &#125; return res; &#125; int match(char *s) &#123; //匹配 int res = 0, now = 0; for (int i = 0; s[i]; i++) &#123; char ch = s[i]-'a'; if (stable[now].next[ch]) //如果当前状态太能找到后继节点，则走他 now = stable[now].next[ch]; else &#123; //否则只能跳爸爸 int p = stable[now].fail; while (p &amp;&amp; stable[p].next[ch] == 0)p = stable[p].fail; //始终没找到，只能指根节点 //找到就跳对应地方 now = stable[p].next[ch]; &#125; if (stable[now].cnt)res = res + get(now);// &#125; return res; &#125;&#125;Ac;char s[max_n];int main(int argc, char *argv[]) &#123;#ifdef LOCAL freopen(\"C:/input.txt\", \"r\", stdin);#endif&#125;应用：查找母串中各单词出现次数–对应题目P3796123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define ll long long int#define max_n 1000050#define max_tot 500050#define met(a) memset(a,0,sizeof(a))#define fup(i,a,n,b) for(int i=a;i&lt;n;i+=b)#define fow(j,a,n,b) for(int j=a;j&gt;0;j-=b)#define MOD(x) (x)%modusing namespace std;const int maxn = 1e5 + 7;struct aa &#123; int i; int cnt;&#125;ans[180];int cmp(aa a, aa b) &#123; if (a.cnt == b.cnt)return a.i &lt; b.i; else return a.cnt &gt; b.cnt;&#125;struct Ac &#123; struct state &#123; //节点状态 int next[26]; int fail, cnt;//指针fail 到这个节点有cnt个串结束 &#125;stable[max_tot]; int size; //当前AC自动机节点个数 queue&lt;int&gt;q; void init() &#123; //初始化 met(stable); size = 1; while (!q.empty())q.pop(); for (int i = 0; i &lt;= 150; i++) &#123; ans[i].i = i; ans[i].cnt = 0; &#125; &#125; void insert(char *s,int n) &#123; //将模式串插入trie树 int now = 0; //代表走到那个节点 for (int i = 0; s[i]; i++) &#123; char ch = s[i]-'a'; if (!stable[now].next[ch]) //节点不存在该字母边，则新建一个 stable[now].next[ch] = size++; now = stable[now].next[ch]; &#125; stable[now].cnt=n;//结束位置++； &#125; void build() &#123; //构造失配fail指针，要构造当前节点fail指针需先构造爸爸节点 for (int i = 0; i &lt; 26; i++)if (stable[0].next[i])q.push(stable[0].next[i]); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (stable[u].next[i]) &#123; //如果有i这条边 枚举下他儿子 int v = stable[u].fail; int a = stable[u].next[i]; while (v) &#123; //一直按箭头的fail if (stable[v].next[i]) &#123; //如果他某个祖先有i这条边 stable[a].fail = stable[v].next[i]; break; &#125; v = stable[v].fail; &#125; if (!stable[a].fail)stable[a].fail = stable[0].next[i]; q.push(stable[u].next[i]); //节点加进去 &#125; &#125; &#125; &#125; void get(int u) &#123; //算所有祖先的和 int res = 0; u = stable[u].fail; while (u) &#123; if(stable[u].cnt)ans[stable[u].cnt].cnt++; //找个数 u = stable[u].fail; &#125; return; &#125; int match(char *s) &#123; //匹配 int res = 0, now = 0; for (int i = 0; s[i]; i++) &#123; char ch = s[i]-'a'; if (stable[now].next[ch]) //如果当前状态太能找到后继节点，则走他 now = stable[now].next[ch]; else &#123; //否则只能跳爸爸 int p = stable[now].fail; while (p &amp;&amp; stable[p].next[ch] == 0)p = stable[p].fail; //始终没找到，只能指根节点 //找到就跳对应地方 now = stable[p].next[ch]; &#125; if (stable[now].cnt) &#123; ans[stable[now].cnt].cnt++; &#125; get(now); &#125; return res; &#125;&#125;Ac;char s[max_n];char s1[200][80];int main(int argc, char *argv[]) &#123; /*ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);*/ int t, n; while (scanf(\"%d\", &amp;n)&amp;&amp;n!=0) &#123; Ac.init(); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", s1[i]); Ac.insert(s1[i], i); &#125; Ac.build(); scanf(\"%s\", s); Ac.match(s); sort(ans, ans + n+1, cmp); printf(\"%d\\n\", ans[0].cnt); printf(\"%s\\n\", s1[ans[0].i]); for (int i = 1; i &lt; n; i++) &#123; if (ans[i].cnt == ans[0].cnt)printf(\"%s\\n\", s1[ans[i].i]); else break; &#125; &#125; return 0;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"字符串Hash模板","slug":"字符串Hash模板","date":"2018-09-17T15:56:56.000Z","updated":"2019-01-24T04:43:17.601Z","comments":true,"path":"article/字符串Hash模板.html","link":"","permalink":"https://anoyer.cn/article/字符串Hash模板.html","excerpt":"","text":"字符串 Hash注意：m选择足够大的质数（至少大于字符串个数）12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;bits/stdc++.h&gt;#define ll long long intusing namespace std;ll gethash(char *s,int m)&#123; ll h=0; for(int i=0;s[i];i++) h=((h&lt;&lt;8)+s[i])%m; return h;&#125;int main()&#123; #ifdef LOCAL //freopen(\"C:/Users/Administrator/Desktop/input.txt\",\"r\",stdin); #endif char a[100]=\"22222222222222222222222222222\"; char b[100]=\"22222222222222222222222223222\"; printf(\"%lld\\n\",gethash(a,1e9+7)); printf(\"%lld\\n\",gethash(b,1e9+7));&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"Karp-Rabin算法模板","slug":"Karp-Rabin算法模板","date":"2018-09-17T15:53:25.000Z","updated":"2019-01-24T04:41:28.253Z","comments":true,"path":"article/Karp-Rabin算法模板.html","link":"","permalink":"https://anoyer.cn/article/Karp-Rabin算法模板.html","excerpt":"","text":"Karp Rabin 算法是利用hash函数的特性进行字符串匹配的。KR算法对模式串和循环中每一次要匹配的子串按一定的hash函数求值，如果hash值相同，才进一步比较这两个串是否真正相等12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#define d 256 //字符表中字符数目 using namespace std;string s,p;void RK(int q)&#123; //assert( s&amp;&amp; p &amp;&amp; q &gt; 0 ); //如果传递的有错，则打印提示 int m=p.size(); int n=s.size(); int p_h=0; //模式串hash int s_h=0; //s串hash int h=1; for(int i=0;i&lt;m-1;i++)h=(h*d)%q; //h表示ts+1 = 10(31415 - 10000*3) +2 = 14152中的10000 for(int i=0;i&lt;m;i++)&#123; p_h= ( d * p_h + p[i] ) % q; s_h= ( d * s_h + s[i] ) % q; &#125; //求出开始p_h 和 s_h for(int i=0;i&lt;n-m;i++)&#123; if(p_h==s_h)&#123; int j; for(j=0;j&lt;m;j++) if(s[i+j]!=p[j])break; if(j==m)printf(\"P occurs with shifts: %d\\n\",i); &#125; if(i&lt;n-m)&#123; s_h=(d*(s_h-s[i]*h)+s[i+m])%q; if(s_h&lt;0) s_h+=q; &#125; &#125;&#125;int main()&#123; s=\"GEEKlmnaS FOR GEEKlmnaS njknaskjdaskjbdkjasbdjas njabijbaslbckjsbfGEEKlmnaS FOR GEEKlmnaS\"; p=\"GEEKlmna\"; int mod=127; ////需要比s长度大 RK(mod);&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"KMP模板及优化","slug":"KMP模板及优化","date":"2018-09-17T15:49:38.000Z","updated":"2019-01-24T04:41:37.073Z","comments":true,"path":"article/KMP模板及优化.html","link":"","permalink":"https://anoyer.cn/article/KMP模板及优化.html","excerpt":"","text":"解决问题：字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。 或者给你两个字符串，查找一个字符串在另外一个字符串中出现了几次1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10001;int next[maxn];char s[maxn];char p[maxn];int cnt=0;void prefix_next(int n)&#123; next[0]=0; int len=0; int i=1; while(i&lt;n)&#123; if(p[i]==p[len])&#123; len++; next[i]=len; &#125; else &#123; if(len&gt;0)&#123; len=next[len-1]; &#125; else&#123; next[i++]=len; &#125; &#125; &#125; return;&#125;void move_next(int n)&#123; for(int i=n-1;i&gt;0;i--)&#123; next[i]=next[i-1]; &#125; next[0]=-1; return;&#125;void kmp_search()&#123; int n=strlen(p); int m=strlen(s); prefix_next(n); move_next(n); int i=0; int j=0; while(i&lt;m)&#123; if(s[i]==p[j]&amp;&amp;j==n-1)&#123; printf(\"No.%d--&gt;%d\\n\",++cnt,i-j); j=next[j]; &#125; if(s[i]==p[j])&#123; i++; j++; &#125; else&#123; j=next[j]; if(j==-1)&#123; i++;j++; &#125; &#125; &#125; if(cnt==0)cout&lt;&lt;\"NO FOUD\"&lt;&lt;endl; return;&#125;int main()&#123; cin&gt;&gt;s; cin&gt;&gt;p; kmp_search();&#125;KMP优化模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;char s[1000005],t[200000];int slen,tlen;int nex[200000];//nex数组大小和短串一致int ans,a,b,c,d,n,m;inline void get_nex()&#123; int j=-1;//j初始化为-1 for (int i=0;i&lt;tlen;i++)&#123; while (t[i]!=t[j+1] &amp;&amp; j!=-1)//如果下一个不同，那么j就变成next[j]，注意next[j]是小于j的，无论j取任何值 j=nex[j];//往前回溯 if (t[i]==t[j+1] &amp;&amp; i!=0) j++;//如果相同，j++ nex[i]=j;//这个是把算的j的值（就是相同的最大前缀和最大后缀长）赋给next[i] &#125;&#125;inline void kmp()&#123; int j=-1; for (int i=0;i&lt;slen;i++)&#123; while (s[i]!=t[j+1] &amp;&amp; j!=-1) j=nex[j]; if (s[i]==t[j+1]) j++; if (j==tlen-1) ans++,j=nex[j]; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++)&#123; ans=0; scanf(\"%s %s\",t,s); slen=strlen(s); tlen=strlen(t);//这两个长度应该设为全局变量最开始时求出，不能用一次求一次 get_nex(); kmp(); printf(\"%d\\n\",ans); &#125;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"Sunday算法模板","slug":"Sunday算法模板","date":"2018-09-17T15:47:27.000Z","updated":"2019-01-24T04:42:46.629Z","comments":true,"path":"article/Sunday算法模板.html","link":"","permalink":"https://anoyer.cn/article/Sunday算法模板.html","excerpt":"","text":"Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：1只不过Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;string s,p;int next_[257];void getnext()&#123; int len=p.size(); for(int i=0;i&lt;256;i++)next_[i]=-1; for(int i=0;i&lt;len;i++)next_[p[i]]=i; //打next_表，记录模式串相应字符的位置 &#125;int sunday()&#123; int slen=s.size(); int plen=p.size(); if(slen==0)return -1; //如果s的长度为0，不需要匹配，直接返回-1 for(int i=0;i&lt;slen-plen;)&#123; int j=i; //s[j] int k=0; //p[k] for(;k&lt;plen&amp;&amp;j&lt;slen&amp;&amp;s[j]==p[k];j++,k++);//一直匹配，找到失配 j 和 k if(k==plen) //说明已经找到一段匹配串 return i; //如果要查找出现次数，改成cnt++ else&#123; if(i+plen&lt;slen)i+=(plen-next_[s[i+plen]]); else return -1;// //如果要查找出现次数，改成return cnt &#125; &#125; return -1;&#125;int main()&#123; s=\"I love DNF and Code\"; p=\"love\"; getnext(); if(sunday())printf(\"you find it at %d\\n\",sunday()); else printf(\"sorry,you do not find it!\\n\"); &#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"字符串编辑距离模板","slug":"字符串编辑距离模板","date":"2018-09-17T15:40:35.000Z","updated":"2019-01-24T04:43:22.746Z","comments":true,"path":"article/字符串编辑距离模板.html","link":"","permalink":"https://anoyer.cn/article/字符串编辑距离模板.html","excerpt":"","text":"编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由⼀一个转成 另一个所需的少编辑操作次数。许可的编辑操作包括将⼀一个字符替换成另一个字符，插入一个字 符，删除一个字符12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 5; int T, cas = 0; int n, m; int dp[N][N]; char s[N], t[N]; int main()&#123; while(scanf(\"%s%s\",s,t)!=EOF)&#123; int n=(int)strlen(s),m=(int)strlen(t); for(int i=0;i&lt;=n;i++)&#123; dp[i][0]=i; &#125; for(int i=0;i&lt;=m;i++)&#123; dp[0][i]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+1; dp[i][j]=min(dp[i][j],dp[i-1][j-1]+(s[i-1]!=t[j-1])); &#125; &#125; printf(\"%d\\n\",dp[n][m]); &#125;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"Manacher回文串算法（马拉车）模板","slug":"Manacher回文串算法（马拉车）模板","date":"2018-09-17T15:37:45.000Z","updated":"2019-01-24T04:41:41.874Z","comments":true,"path":"article/Manacher回文串算法（马拉车）模板.html","link":"","permalink":"https://anoyer.cn/article/Manacher回文串算法（马拉车）模板.html","excerpt":"","text":"求一个串中最长回文串的长度给定一个字符串，求出其最长回文子串。例如：（1）s=”abcd”, 最长回文长度为 1；（2）s=”ababa”, 最长回文长度为 5；（3）s=”abccb”, 最长回文长度为 4，即 bccb。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;string.h&gt;#include&lt;algorithm&gt; using namespace std;char s[111111];char s_new[111111*2];int p[111111*2];int Init()&#123; int len = strlen(s); s_new[0] = '$'; s_new[1] = '#'; int j = 2; for (int i = 0; i &lt; len; i++) &#123; s_new[j++] = s[i]; s_new[j++] = '#'; &#125; s_new[j] = '\\0'; //别忘了哦 //printf(\"%s\\n\",s_new); return j; //返回s_new的长度 &#125;int Manacher()&#123; int len = Init(); //取得新字符串长度并完成向s_new的转换 int maxLen = -1; //最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) &#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); //需搞清楚上面那张图含义, mx和2*id-i的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) //不需边界判断，因为左有'$',右有'\\0' p[i]++; //我们每走一步i，都要和mx比较，我们希望mx尽可能的远，这样才能更有机会执行if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) &#123; id = i; mx = i + p[i]; &#125; maxLen = max(maxLen, p[i] - 1); // printf(\"%d %d %d\\n\",mx,id,maxLen); &#125; /*for(int i=1;i&lt;=len;i++)printf(\"%d \",p[i]); printf(\"\\n\");*/ return maxLen;&#125;int main()&#123; while (~scanf(\"%s\", s)) &#123; printf(\"%d\\n\", Manacher()); &#125; return 0;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"拓展KMP模板","slug":"拓展KMP模板","date":"2018-09-17T15:31:25.000Z","updated":"2019-01-24T04:43:30.967Z","comments":true,"path":"article/拓展KMP模板.html","link":"","permalink":"https://anoyer.cn/article/拓展KMP模板.html","excerpt":"","text":"博主CSDN扩展KMPnext[i]表示为模式串S2中以i为起点的后缀字符串和模式串S2的最长公共前缀长度.extend[i]表示为以字符串S1中以i为起点的后缀字符串和模式串S2的最长公共前缀长度.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100010;//字符串长度最大值 int next[maxn],ex[maxn];//ex数组即为extend数组char s[maxn],s2[maxn];int n;//预处理计算next数组void getnext()&#123; int i=0,j,po,len=strlen(s); next[0]=len;//初始化next[0] while(s[i]==s[i+1]&amp;&amp;i+1&lt;len)//计算next[1] i++; next[1]=i; po=1;//初始化po的位置 for(i=2;i&lt;len;i++)&#123; if(next[i-po]+i&lt;next[po]+po)//第一种情况，可以直接得到next[i]的值 next[i]=next[i-po]; else //第二种情况，要继续匹配才能得到next[i]的值 &#123; j=next[po]+po-i; if(j&lt;0)j=0;//如果i&gt;po+next[po],则要从头开始匹配 while(i+j&lt;len&amp;&amp;s[j]==s[j+i])//计算next[i] j++; next[i]=j; po=i;//更新po的位置 &#125; &#125; &#125; //计算extend数组void extend()&#123; int i=0,j,po,len=strlen(s),l2=strlen(s2); getnext();//计算子串的next数组 while(s[i]==s2[i]&amp;&amp;i&lt;len)i++; ex[0]=i; po=0;//初始化po的位置 for(i=1;i&lt;len;i++)&#123; if(next[i-po]+i&lt;ex[po]+po) ex[i]=next[i-po];//第一种情况 else&#123; j=ex[po]+po-i; if(j&lt;0)j=0;//如果j&gt;ex[po]+po则从头开始匹配 while(i+j&lt;len&amp;&amp;j&lt;&lt;l2&amp;&amp;s[j+i]==s2[j])//计算ex[i] j++; ex[i]=j; po=i; &#125; &#125; &#125;int main()&#123;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"KMP最短公共祖先","slug":"KMP最短公共祖先","date":"2018-09-17T15:28:55.000Z","updated":"2019-01-24T04:41:33.503Z","comments":true,"path":"article/KMP最短公共祖先.html","link":"","permalink":"https://anoyer.cn/article/KMP最短公共祖先.html","excerpt":"","text":"HDU1841–题意是给出两个串，用这两个串组成一个新串，使新串包含这两个串，问这个新串的长度最小是多少，显然，对于两个串A，B，A如果是B的字串或者B如果是A的字串的话，直接输出那个母串的长度即可，如果没有这种关系，那么看一个串的后缀是否是另一个串的前缀如果某个串的后缀与另一个串的前缀的公共部分最长，则答案=A.length+B.length-公共长度。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std; const int N = 1000100;char a[3][2*N];int fail[2*N];inline int max(int a, int b)&#123; return (a &gt; b) ? a : b;&#125;int kmp(int &amp;i, int &amp;j, char* str, char* pat)&#123; int k; memset(fail, -1, sizeof(fail)); for (i = 1; pat[i]; ++i) &#123; for (k = fail[i - 1]; k &gt;= 0 &amp;&amp; pat[i] != pat[k + 1]; k = fail[k]); if (pat[k + 1] == pat[i]) &#123; fail[i] = k + 1; &#125; &#125; i = j = 0; while (str[i] &amp;&amp; pat[j]) &#123; if (pat[j] == str[i]) &#123; i++; j++; &#125; else if (j == 0) &#123; i++; &#125; else &#123; j = fail[j - 1] + 1; &#125; &#125; if (pat[j]) &#123; return -1; &#125; else &#123; return i - j; &#125;&#125;int main(int argc, const char * argv[])&#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int i, j, l1 = 0, l2 = 0; cin &gt;&gt; a[0] &gt;&gt; a[1]; int len1 = (int)strlen(a[0]), len2 = (int)strlen(a[1]), val; val = kmp(i, j, a[1], a[0]); if (val != -1) &#123; l1 = len1; &#125; else &#123; if (i == len2 &amp;&amp; j - 1 &gt;= 0 &amp;&amp; a[1][len2 - 1] == a[0][j - 1]) &#123; l1 = j; &#125; &#125; val = kmp(i, j, a[0], a[1]); if (val != -1) &#123; l2 = len2; &#125; else &#123; if (i == len1 &amp;&amp; j - 1 &gt;= 0 &amp;&amp; a[0][len1 - 1] == a[1][j - 1]) &#123; l2 = j; &#125; &#125; printf(\"%d\\n\", len1 + len2 - max(l1, l2)); &#125; return 0;&#125;","categories":[{"name":"字符串模板","slug":"字符串模板","permalink":"https://anoyer.cn/categories/字符串模板/"}],"tags":[{"name":"ACM模板","slug":"ACM模板","permalink":"https://anoyer.cn/tags/ACM模板/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-17T13:40:12.000Z","updated":"2018-12-02T06:44:04.838Z","comments":true,"path":"article/hello-world.html","link":"","permalink":"https://anoyer.cn/article/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://anoyer.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://anoyer.cn/tags/Hexo/"}]},{"title":"文章模板","slug":"模板","date":"2018-03-01T13:46:12.000Z","updated":"2018-12-02T06:37:05.230Z","comments":true,"path":"article/模板.html","link":"","permalink":"https://anoyer.cn/article/模板.html","excerpt":"","text":"","categories":[],"tags":[]}]}